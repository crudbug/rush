
del /F /Q ..\bin\*.ilk
del /F /Q ..\bin\*.pdb

del /F /Q .\*.ncb
attrib -R -S -A -H .\*.suo
del /F /Q .\*.suo
del /F /Q .\*.user

del /F /Q .\proj\*.vsp
rem del /F /Q .\proj\*.filters
del /F /Q .\proj\*.psess
del /F /Q .\proj\*.sdf
del /F /Q .\proj\*.ncb
attrib -R -S -A -H .\proj\*.suo
del /F /Q .\proj\*.suo
del /F /Q .\proj\*.user

rd /S /Q .\proj\debug
rd /S /Q .\proj\Release

del /F /Q .\rush.asm
del /F /Q .\rush.cpp
del /F /Q .\rush.exe

del /F /Q .\example\test\*.exe
del /F /Q .\example\test\*.cpp
del /F /Q ..\bin\rush_gpp.asm
del /F /Q ..\bin\rush_nasm.asm
del /F /Q ..\bin\rush_gpp.exe
del /F /Q ..\bin\rush_nasm.exe

pause#include "back/zmain.h"

#ifdef EMSCRIPTEN
extern "C" int js_main(char* s)
{
	return !zmain::compile((uchar*)s);
}
#else
#ifndef __GNUC__
int main()
{
	return !zmain::compile(null);
}
#else
int main(int argc,char* argv[])
{
	xf::get_xf()->argc=argc;
	xf::get_xf()->argv=argv;
	return !zmain::compile(null);
}
#endif
#endif
﻿#pragma once

#include "../front/yexp.h"
#include "zopt.h"

//生成汇编代码
//tfunc.vsent->vasm
//返回指针或引用或int的表达式需要放入ebx中
//指针或int的引用是对本身的值进行判断
//其它类型的引用是对引用进行判断
struct zasm
{
	static rbool process(tsh& sh,tfunc& tfi)
	{
		for(int i=0;i<tfi.vsent.count();i++)
		{
			rbuf<tasm> vasm;
			ifn(proc_ret(sh,tfi.vsent[i],vasm,tfi))
			{
				rserror(tfi.vsent[i],"build asm error");
				return false;
			}
			if(tconf::c_op_match)
			{
				yopt::op_match(sh,vasm);
			}
			if(tconf::c_op_merge)
			{
				yopt::op_add_sub(sh,vasm);
			}
			for(int j=0;j<vasm.count();j++)
			{
				vasm[j].pos=tfi.vsent[i].pos;
			}
			tfi.vasm+=vasm;
		}
		add_asm_ebp(sh,tfi);
		return true;
	}

	static void push_double(const tsh& sh,rbuf<tasm>& vasm,double dval)
	{
		vasm+=rf::vstr(rskey(c_push),rstr(*((uint*)(&dval)+1)));
		vasm+=rf::vstr(rskey(c_push),rstr(*((uint*)(&dval))));
	}

	static rbool add_asm_ebp(const tsh& sh,tfunc& tfi)
	{
		rbuf<tasm> vasm;
		tasm item;
		item.pos=tfi.pos;
		int size=yfind::get_func_local_size(tfi);
		ifn(tconf::c_op_zero&&size==0)
		{
			item.vstr=rf::vstr(rskey(c_sub),rskey(c_esp),
				rsoptr(c_comma),rstr(size));
			vasm+=item;
		}
		rbool b_use_ebp=use_ebp(sh,tfi.vasm);
		rbool protect_ebx=(tfi.name.get_left()==r_char('~')&&
			!yfind::is_empty_struct_type(sh,tfi.ptci->name)&&
			!tfi.vsent.empty()||tfi.is_cfunc);
		if(b_use_ebp)
		{
			item.vstr=rf::vstr(rskey(c_push),rskey(c_ebp));
			vasm+=item;
			item.vstr=rf::vstr(rskey(c_mov),rskey(c_ebp),
				rsoptr(c_comma),rskey(c_esp));
			vasm+=item;
		}
		if(protect_ebx)
		{
			item.vstr=rf::vstr(rskey(c_push),rskey(c_ebx));
			vasm+=item;
		}
		if(tfi.is_cfunc)
		{
			//todo 如果ebx、esi、edi未修改则不用保护
			item.vstr=rf::vstr(rskey(c_push),rskey(c_esi));
			vasm+=item;
			item.vstr=rf::vstr(rskey(c_push),rskey(c_edi));
			vasm+=item;
		}
		vasm+=tfi.vasm;
		item.pos=tfi.pos;
		if(tfi.is_cfunc)
		{
			//todo: change to one line
			item.vstr.clear();
			item.vstr.push(rskey(c_pop));
			item.vstr.push(rskey(c_edi));
			vasm.push(item);

			item.vstr.clear();
			item.vstr.push(rskey(c_pop));
			item.vstr.push(rskey(c_esi));
			vasm.push(item);
		}
		if(protect_ebx)
		{
			item.vstr.clear();
			item.vstr.push(rskey(c_pop));
			item.vstr.push(rskey(c_ebx));
			vasm.push(item);
		}
		if(b_use_ebp)
		{
			item.vstr.clear();
			item.vstr.push(rskey(c_pop));
			item.vstr.push(rskey(c_ebp));
			vasm.push(item);
		}
		ifn(tconf::c_op_zero&&size==0)
		{
			item.vstr.clear();
			item.vstr.push(rskey(c_add));
			item.vstr.push(rskey(c_esp));
			item.vstr.push(rsoptr(c_comma));
			item.vstr.push(rstr(size));
			vasm.push(item);
		}
		size=yfind::get_func_param_size(tfi);
		if(size>0)
		{
			item.vstr.clear();
			item.vstr.push(rskey(c_reti));
			item.vstr.push(rstr(size));
			vasm.push(item);
		}
		else
		{
			item.vstr.clear();
			item.vstr.push(rskey(c_retn));
			vasm.push(item);
		}
		tfi.vasm=r_move(vasm);
		return true;
	}

	static rbool use_ebp(const tsh& sh,const rbuf<tasm>& vasm)
	{
		if(!tconf::c_op_ebp)
		{
			return true;
		}
		for(int i=0;i<vasm.count();i++)
		{
			for(int j=0;j<vasm[i].vstr.count();j++)
			{
				if(vasm[i].vstr[j]==rskey(c_ebp))
				{
					return true;
				}
			}
		}
		return false;
	}

	static rbool proc_ret(tsh& sh,const tsent& src,rbuf<tasm>& vasm,
		tfunc& tfi,int level=0)
	{
		rstr name=src.vword.get_bottom().val;
		if(sh.m_key.is_asm_ins(name)||ybase::is_tag<tword>(src.vword))
		{
			vasm+=ybase::vword_to_vstr(src.vword);
			return true;
		}
		//返回常量
		if(src.vword.count()==1)
		{
			if(src.vword[0].is_cint())
			{
				//经测试如果是小程序rskey(c_mov)比"mov"效率高
				vasm+=rf::vstr(rskey(c_mov),rskey(c_ebx),
					rsoptr(c_comma),src.vword[0].val);
				return true;
			}
			elif(sh.m_key.is_asm_reg(src.vword[0].val))
			{
				vasm+=rf::vstr(rskey(c_mov),rskey(c_ebx),
					rsoptr(c_comma),src.vword[0].val);
				return true;
			}
			elif(src.vword[0].is_cpoint())
			{
				if(src.vword[0].is_caddr())
				{
					vasm+=rf::vstr(rskey(c_mov),
						rskey(c_ebx),rsoptr(c_comma),
						src.vword[0].val);
				}
				else
				{
					vasm+=rf::vstr(rskey(c_mov),
						rskey(c_ebx),rsoptr(c_comma),
						src.vword[0].val.sub_trim(1));
				}
				return true;
			}
		}
		if(src.vword.count()==7&&src.vword[1].val==rsoptr(c_addr))
		{
			vasm+=rf::vstr(rskey(c_mov),rskey(c_ebx),rsoptr(c_comma),
				rsoptr(c_mbk_l),rsoptr(c_addr),rsoptr(c_comma),
				src.vword[3].val,rsoptr(c_comma),src.vword[5].val,
				rsoptr(c_mbk_r));
			return true;
		}
		//返回变量
		tdata* ptdi=yfind::local_search(tfi,
			get_src_in(sh,src).vword.get(0).val);
		if(ptdi!=null)
		{
			if(yfind::is_type_mebx(sh,src.type))
			{
				vasm+=rf::vstr(rskey(c_lea),rskey(c_esi),
					rsoptr(c_comma),rsoptr(c_mbk_l),
					rskey(c_ebp),rsoptr(c_plus),
					rstr(ptdi->off),rsoptr(c_mbk_r));
				//这里还可以优化
				if(!add_esi(sh,ptdi->type,vasm,src))
				{
					rserror("");
					return false;
				}
				vasm+=rf::vstr(rskey(c_mov),rskey(c_ebx),
					rsoptr(c_comma),rsoptr(c_mbk_l),
					rskey(c_esi),rsoptr(c_mbk_r));
				if(ybase::is_quote(src.type)&&
					(ybase::get_tname(src.type)==rskey(c_int)||
					ybase::is_point(ybase::get_tname(src.type))))
				{
					vasm+=rf::vstr(rskey(c_mov),rskey(c_ebx),
						rsoptr(c_comma),rsoptr(c_mbk_l),
						rskey(c_ebx),rsoptr(c_mbk_r));
				}
			}
			return true;
		}
		//返回函数
		return proc_ret_func(sh,src,vasm,tfi,level);
	}

	static rbool proc_ret_func(tsh& sh,const tsent& src,rbuf<tasm>& vasm,
		tfunc& tfi,int level)
	{
		tdata retval;
		if(!a_exp(sh,get_src_in(sh,src),vasm,retval,tfi,level))
		{
			return false;
		}
		int size;
		//多数函数返回void，因此加上这句判断可以提高效率
		if(src.type!=rskey(c_void)&&yfind::is_type_mebx(sh,src.type))
		{
			vasm+=rf::vstr(rskey(c_mov),rskey(c_esi),
				rsoptr(c_comma),rskey(c_esp));
			int cur=vasm.count();
			if(!add_esi(sh,retval.type,vasm,src))
			{
				rserror("");
				return false;
			}
			if(cur==vasm.count())
			{
				vasm.pop();
				vasm+=rf::vstr(rskey(c_mov),rskey(c_ebx),
					rsoptr(c_comma),rsoptr(c_mbk_l),
					rskey(c_esp),rsoptr(c_mbk_r));
			}
			else
			{
				vasm+=rf::vstr(rskey(c_mov),rskey(c_ebx),
					rsoptr(c_comma),rsoptr(c_mbk_l),
					rskey(c_esi),rsoptr(c_mbk_r));
			}
			if(ybase::is_quote(src.type)&&
				(ybase::get_tname(src.type)==rskey(c_int)||
				ybase::is_point(ybase::get_tname(src.type))))
			{
				vasm+=rf::vstr(rskey(c_mov),rskey(c_ebx),
					rsoptr(c_comma),rsoptr(c_mbk_l),
					rskey(c_ebx),rsoptr(c_mbk_r));
			}
		}
		if(!destruct_ret(sh,retval,vasm))
		{
			rserror("");
			return false;
		}
		size=yfind::get_ceil_space(retval);
		vasm+=rf::vstr(rskey(c_add),rskey(c_esp),rsoptr(c_comma),size);
		return true;
	}
	
	//解析表达式生成汇编代码
	static rbool a_exp(tsh& sh,const tsent& src,rbuf<tasm>& vasm,tdata& retval,
		tfunc& tfi,int level=0)
	{
		if(level>c_rs_deep)
		{
			rserror("");
			return false;
		}
		level++;
		if(src.vword.get_bottom().val!=rsoptr(c_mbk_l)||
			src.vword.get_top().val!=rsoptr(c_mbk_r))
		{
			rserror("");
			return false;
		}
		if(src.vword.get(1).val==rsoptr(c_dot))
		{
			rserror("");
			return false;
		}
		int size;
		rbuf<rbuf<tword> > vlisp;
		yexp::get_vlisp(sh,src.vword,vlisp);
		if(src.vword.get(1).val==rskey(c_pcall))
		{
			if(vlisp.count()!=5)
			{
				rserror("");
				return false;
			}
			retval.type=vlisp[1].get(0).val;
			retval.size=yfind::get_type_size(sh,retval.type);
			size=yfind::get_ceil_space(retval);
			vasm+=rf::vstr(rskey(c_sub),rskey(c_esp),
				rsoptr(c_comma),size);
			rbuf<rbuf<tword> > vparam;
			yexp::get_vlisp(sh,vlisp[4],vparam);
			rbuf<tsent> vsent;
			yexp::get_vsent(vparam,vsent,src);
			for(int i=vsent.count()-1;i>=0;i--)
			{
				//todo:已有类型数组无需重新获取
				if(!yexp::p_exp(sh,vsent[i],tfi,level,tenv()))
				{
					return false;
				}
			}
			for(int i=vsent.count()-1;i>=0;i--)
			{
				tdata tdi;
				tdi.type=ybase::get_tname(vsent[i].type);
				tdi.size=yfind::get_type_size(sh,tdi.type);
				if(!pass_param(sh,vsent[i],tdi,vasm,tfi,level))
				{
					return false;
				}
			}
			tsent sent=src;
			sent.vword=vlisp[3];
			if(!yexp::p_exp(sh,sent,tfi,level,tenv()))
			{
				return false;
			}
			if(!proc_ret(sh,sent,vasm,tfi,level))
			{
				return false;
			}
			if(sent.type==rstr("rp<void>"))
			{
				vasm+=rf::vstr(rskey(c_call),rskey(c_ebx));
			}
			else
			{
				rserror("");
				return false;
			}
			return true;
		}
		if(vlisp.count()!=3)
		{
			rserror("");
			return false;
		}
		yexp::get_vlisp(sh,vlisp[2],vlisp);
		rbuf<tsent> vsent;
		yexp::get_vsent(vlisp,vsent,src);
		for(int i=vsent.count()-1;i>=0;i--)
		{
			if(!yexp::p_exp(sh,vsent[i],tfi,level,tenv()))
			{
				return false;
			}
		}
		rstr cname=src.vword.get(1).val;
		rstr fname=src.vword.get(3).val;//p_exp已经合并了name_dec
		tclass* ptci=yfind::class_search(sh,cname);
		if(null==ptci)
		{
			rserror("");
			return false;
		}
		tfunc* ptfi=yfind::func_search_dec(*ptci,fname);
		if(ptfi==null)
		{
			rserror("");
			return false;
		}
		retval=ptfi->retval;
		if(tconf::c_op_empty_func&&
			yfind::is_empty_struct_type(sh,ptci->name)&&
			(yfind::is_destruct(sh,*ptfi)||
			yfind::is_emptystruct(sh,*ptfi)))
		{
			return true;
		}
		if(ptfi->param.count()!=vsent.count())
		{
			rserror("");
			return false;
		}
		size=yfind::get_ceil_space(retval);
		vasm+=rf::vstr(rskey(c_sub),rskey(c_esp),rsoptr(c_comma),size);
		for(int i=vsent.count()-1;i>=0;i--)
		{
			if(!pass_param(sh,vsent[i],ptfi->param[i],vasm,tfi,level))
			{
				return false;
			}
		}
		vasm+=ybase::get_func_declare_call(sh,*ptci,*ptfi);
		return true;
	}

	static rbool pass_param(tsh& sh,const tsent& src,const tdata& dst,rbuf<tasm>& vasm,
		tfunc& tfi,int level)
	{
		if(src.vword.empty())
		{
			rserror("");
			return false;
		}
		int size;
		tsent src_in=get_src_in(sh,src);
		if(src_in.vword.get(1).val==rskey(c_pcall)||
			yfind::is_class(sh,src_in.vword.get(1).val))
		{
			//先申请参数空间
			size=yfind::get_ceil_space(dst);
			vasm+=rf::vstr(rskey(c_sub),rskey(c_esp),
				rsoptr(c_comma),size);
			//递归处理子表达式
			tdata retval;
			if(!a_exp(sh,src_in,vasm,retval,tfi,level))
			{
				return false;
			}
			//获取传递参数的地址分别放入esi和edi中，
			//包括函数返回后再dot，如int.get().m_in
			if(!obtain_var_addr_f(sh,retval,src,vasm))
			{
				rserror("");
				return false;
			}
			//传递参数
			if(!copy_param(sh,src.type,dst.type,vasm))
			{
				rserror("");
				return false;
			}
			//析构返回值
			if(!destruct_ret(sh,retval,vasm))
			{
				rserror("");
				return false;
			}
			//释放栈
			size=yfind::get_ceil_space(retval);
			vasm+=rf::vstr(rskey(c_add),rskey(c_esp),
				rsoptr(c_comma),size);
		}
		elif(src.vword[0].is_cint())
		{
			vasm+=rf::vstr(rskey(c_push),src.vword[0].val);
		}
		elif(src.vword[0].is_cuint())
		{
			vasm+=rf::vstr(rskey(c_push),src.vword[0].val.sub_trim(1));
		}
		elif(src.vword[0].is_cdouble())
		{
			double dval=src.vword[0].val.todouble();
			push_double(sh,vasm,dval);
		}
		elif(src.vword.count()==7&&
			src.vword.get(1).val==rsoptr(c_addr)&&
			src.vword[0].val==rsoptr(c_mbk_l))
		{
			rbuf<rstr> vstr=ybase::vword_to_vstr(src.vword);
			vstr.push_front(rskey(c_push));
			vasm+=vstr;
		}
		elif(src.vword[0].is_cpoint())
		{
			if(src.vword.get_bottom().is_caddr())
			{
				vasm+=rf::vstr(rskey(c_push),src.vword[0].val);
			}
			else
			{
				vasm+=rf::vstr(rskey(c_push),src.vword[0].val.sub_trim(1));
			}
		}
		elif(src.vword[0].is_cstr())
		{
			vasm+=rf::vstr(rskey(c_push),src.vword[0].val);
		}
		elif(sh.m_key.is_asm_reg(src.vword[0].val))
		{
			vasm+=rf::vstr(rskey(c_push),src.vword[0].val);
		}
		else
		{
			rstr name=src_in.vword.get(0).val;
			tdata* ptdi=yfind::local_search(tfi,name);
			if(ptdi==null)
			{
				tfi.name.printl();
				rserror(name);
				return false;
			}
			int cur=vasm.count()+3;
			if(!obtain_var_addr_var(sh,src,dst,ptdi,vasm))
			{
				rserror("");
				return false;
			}
			if(cur==vasm.count()&&tconf::c_op_pass)
			{
				if(yfind::is_op_pass_type(sh,dst.type)&&
					dst.type==src.type)
				{
					vasm.m_count-=3;
					vasm+=rf::vstr(rskey(c_push),rsoptr(c_mbk_l),
						rskey(c_ebp),rsoptr(c_plus),
						rstr(ptdi->off),rsoptr(c_mbk_r));
					return true;
				}
				if(ybase::is_quote(dst.type)&&ybase::is_quote(src.type))
				{
					vasm.m_count-=3;
					vasm+=rf::vstr(rskey(c_push),rsoptr(c_mbk_l),
						rskey(c_ebp),rsoptr(c_plus),
						rstr(ptdi->off),rsoptr(c_mbk_r));
					return true;
				}
				if(ybase::is_quote(dst.type))
				{
					vasm.m_count-=3;
					vasm+=rf::vstr(rskey(c_lea),rskey(c_esi),
						rsoptr(c_comma),rsoptr(c_mbk_l),
						rskey(c_ebp),rsoptr(c_plus),
						rstr(ptdi->off),rsoptr(c_mbk_r));
					vasm+=rf::vstr(rskey(c_push),rskey(c_esi));
					return true;
				}
			}
			//调用拷贝构造函数时还可以优化
			return copy_param(sh,src.type,dst.type,vasm);
		}
		return true;
	}

	static rbool obtain_var_addr_var(const tsh& sh,const tsent& src,const tdata& dst,
		const tdata* ptdi,rbuf<tasm>& vasm)
	{
		int size=yfind::get_ceil_space(dst);
		vasm+=rf::vstr(rskey(c_sub),rskey(c_esp),rsoptr(c_comma),size);
		vasm+=rf::vstr(rskey(c_mov),rskey(c_edi),rsoptr(c_comma),
			rskey(c_esp));
		vasm+=rf::vstr(rskey(c_lea),rskey(c_esi),rsoptr(c_comma),
			rsoptr(c_mbk_l),rskey(c_ebp),rsoptr(c_plus),
			rstr(ptdi->off),rsoptr(c_mbk_r));
		return add_esi(sh,ptdi->type,vasm,src);
	}

	static rbool obtain_var_addr_f(const tsh& sh,tdata& retval,
		const tsent& src,rbuf<tasm>& vasm)
	{
		int size=yfind::get_ceil_space(retval);
		vasm+=rf::vstr(rskey(c_lea),rskey(c_edi),rsoptr(c_comma),
			rsoptr(c_mbk_l),rskey(c_esp),rsoptr(c_plus),
			rstr(size),rsoptr(c_mbk_r));
		vasm+=rf::vstr(rskey(c_mov),rskey(c_esi),rsoptr(c_comma),
			rskey(c_esp));
		return add_esi(sh,retval.type,vasm,src);
	}

	static tsent get_src_in(const tsh& sh,const tsent& src)
	{
		if(src.vword.get(1).val!=rsoptr(c_dot))
		{
			return src;
		}
		tsent sent=src;
		int start=0;
		while(start+2<src.vword.count()&&
			  src.vword[start].val==rsoptr(c_mbk_l)&&
			  src.vword[start+1].val==rsoptr(c_dot))
		{
			start+=3;
		}
		if(src.vword[start].val==rsoptr(c_mbk_l))
		{
			int right=ybase::find_symm_mbk(sh,src.vword,start);
			sent.vword=src.vword.sub(start,right+1);
		}
		else
		{
			sent.vword=src.vword.sub(start,start+1);
		}
		return r_move(sent);
	}
	
	// [ . , [ . , [ . , a , b ] , c ] , d ]
	static rbool add_esi(const tsh& sh,rstr type,rbuf<tasm>& vasm,const tsent& src)
	{
		int start=0;
		const rbuf<tword>& v=src.vword;
		if(v.get(1).val!=rsoptr(c_dot))
		{
			return true;
		}
		while(start+2<v.count()&&
			v[start].val==rsoptr(c_mbk_l)&&
			v[start+1].val==rsoptr(c_dot))
		{
			start+=3;
		}
		int right=start+2;
		if(v[start].val==rsoptr(c_mbk_l))
		{
			right=ybase::find_symm_mbk(sh,v,start);
			if(right>=v.count())
			{
				return false;
			}
			right+=2;
		}
		for(int i=0;i<start;i+=3)
		{
			tclass* ptci=yfind::class_search_t(sh,type);
			if(null==ptci)
			{
				return false;
			}
			tdata* ptdi=yfind::data_member_search(*ptci,v.get(right).val);
			if(null==ptdi)
			{
				return false;
			}
			if(ybase::is_quote(type))
			{
				vasm+=rf::vstr(rskey(c_mov),rskey(c_esi),
					rsoptr(c_comma),rsoptr(c_mbk_l),
					rskey(c_esi),rsoptr(c_mbk_r));
			}
			if(ptdi->off!=0)
			{
				vasm+=rf::vstr(rskey(c_add),rskey(c_esi),
					rsoptr(c_comma),ptdi->off);
			}
			type=ptdi->type;
			right+=3;
		}
		return true;
	}

	//src的真实地址已经存储在esi中,dst的地址在edi中
	static rbool copy_param(const tsh& sh,const rstr& src,
		const rstr& dst,rbuf<tasm>& vasm)
	{
		//指针可以随意转换
		if(ybase::is_point(dst)&&ybase::is_point(src)||
			dst==rskey(c_rd32)&&yfind::get_type_size(sh,src)==4)
		{
			vasm+=rf::vstr(rskey(c_mov),rsoptr(c_mbk_l),
				rskey(c_edi),rsoptr(c_mbk_r),
				rsoptr(c_comma),rsoptr(c_mbk_l),
				rskey(c_esi),rsoptr(c_mbk_r));
			return true;
		}
		//目标是引用
		if(ybase::is_quote(dst))
		{
			if(ybase::is_quote(src))
			{
				//源是引用
				vasm+=rf::vstr(rskey(c_mov),rsoptr(c_mbk_l),
					rskey(c_edi),rsoptr(c_mbk_r),
					rsoptr(c_comma),rsoptr(c_mbk_l),
					rskey(c_esi),rsoptr(c_mbk_r));
			}				
			else
			{
				//源是对象
				vasm+=rf::vstr(rskey(c_mov),rsoptr(c_mbk_l),
					rskey(c_edi),rsoptr(c_mbk_r),
					rsoptr(c_comma),rskey(c_esi));
			}
			return true;
		}
		if(tconf::c_op_pass)
		{
			if(yfind::is_op_pass_type(sh,dst))
			{
				if(ybase::is_quote(src))
				{
					//源是引用
					vasm+=rf::vstr(rskey(c_mov),rskey(c_esi),
						rsoptr(c_comma),rsoptr(c_mbk_l),
						rskey(c_esi),rsoptr(c_mbk_r));
				}
				vasm+=rf::vstr(rskey(c_mov),rsoptr(c_mbk_l),
					rskey(c_edi),rsoptr(c_mbk_r),
					rsoptr(c_comma),rsoptr(c_mbk_l),
					rskey(c_esi),rsoptr(c_mbk_r));
				return true;
			}
			if(dst==rskey(c_double)||dst==rskey(c_int64))
			{
				if(ybase::is_quote(src))
				{
					vasm+=rf::vstr(rskey(c_mov),rskey(c_esi),
						rsoptr(c_comma),rsoptr(c_mbk_l),
						rskey(c_esi),rsoptr(c_mbk_r));
				}
				vasm+=rf::vstr(rskey(c_mov),rsoptr(c_mbk_l),
					rskey(c_edi),rsoptr(c_mbk_r),
					rsoptr(c_comma),rsoptr(c_mbk_l),
					rskey(c_esi),rsoptr(c_mbk_r));
				vasm+=rf::vstr(rskey(c_mov),rsoptr(c_mbk_l),
					rskey(c_edi),rsoptr(c_plus),"4",
					rsoptr(c_mbk_r),rsoptr(c_comma),
					rsoptr(c_mbk_l),rskey(c_esi),
					rsoptr(c_plus),"4",rsoptr(c_mbk_r));
				return true;
			}
		}
		//目标是对象需要调用拷贝构造函数
		if(ybase::is_quote(src))
		{
			//源是引用
			vasm+=rf::vstr(rskey(c_push),rsoptr(c_mbk_l),
				rskey(c_esi),rsoptr(c_mbk_r));
		}
		else
		{
			//源是对象
			vasm+=rf::vstr(rskey(c_push),rskey(c_esi));
		}
		vasm+=rf::vstr(rskey(c_push),rskey(c_edi));
		tclass* ptci=yfind::class_search_t(sh,src);
		if(ptci==null)
		{
			return false;
		}
		tfunc* pcopystruct=yfind::copystruct_search(*ptci);
		if(pcopystruct==null)
		{
			return false;
		}
		vasm+=ybase::get_func_declare_call(sh,*ptci,*pcopystruct);
		return true;
	}

	static rbool destruct_ret(const tsh& sh,const tdata& retval,rbuf<tasm>& vasm)
	{
		rstr type=retval.type;
		if(ybase::is_quote(type))
		{
			return true;
		}
		if(type==rskey(c_void))
		{
			return true;
		}
		tclass* ptci=yfind::class_search(sh,type);
		if(ptci==null)
		{
			return false;
		}
		tfunc* pdestruct=yfind::destruct_search(*ptci);
		if(pdestruct==null)
		{
			return false;
		}
		if(tconf::c_op_empty_func&&yfind::is_empty_struct_type(sh,type))
		{
			return true;
		}
		vasm+=rf::vstr(rskey(c_mov),rskey(c_esi),
			rsoptr(c_comma),rskey(c_esp));
		vasm+=rf::vstr(rskey(c_push),rskey(c_esi));
		vasm+=ybase::get_func_declare_call(sh,*ptci,*pdestruct);
		return true;
	}
};
﻿#pragma once

#include "../front/ysent.h"
#include "../front/yword.h"
#include "zasm.h"

//生成二进制代码类
struct zbin
{
	//将一个函数翻译成二进制代码
	static rbool process(tsh& sh,tfunc& tfi)
	{
		if(!tfi.vasm.empty())
		{
			return true;
		}
		if(!cp_vword_to_vasm(sh,tfi,tenv()))
		{
			return false;
		}
		for(int i=0;i<tfi.vasm.count();i++)
		{
			if(!proc_asm(sh,tfi.vasm,tfi.vasm[i]))
			{
				rserror(tfi.vasm[i],"asm error");
				return false;
			}
			tfi.vasm[i].ptfi=&tfi;
		}
		return true;
	}

	//从函数的词表编译到vasm
	static rbool cp_vword_to_vasm(tsh& sh,tfunc& tfi,tenv env)
	{
		ifn(ysent::process(sh,tfi,env))
		{
			rserror(tfi,"sent error");
			return false;
		}
		ifn(zasm::process(sh,tfi))
		{
			rserror(tfi,"asm error");
			return false;
		}
		return true;
	}

	static rbool proc_vasm(tsh& sh,rbuf<tasm>& vasm)
	{
		for(int i=0;i<vasm.count();i++)
		{
			if(!proc_asm(sh,vasm[i]))
			{
				return false;
			}
		}
		return true;
	}

	static rbool proc_asm(tsh& sh,tasm& oasm)
	{
		rbuf<tasm> vasm;
		return proc_asm(sh,vasm,oasm);
	}
	
	//将汇编代码翻译成二进制代码
	static rbool proc_asm(tsh& sh,rbuf<tasm>& vasm,tasm& oasm)
	{
		if(ybase::is_tag<rstr>(oasm.vstr))
		{
			oasm.ins.type=tins::c_nop_n;
			return true;
		}
		oasm.ins.type=sh.m_key.get_key_index(oasm.vstr.get_bottom());
		if(oasm.ins.type>tkey::c_rn)
		{
			rserror(oasm);
			return false;
		}
		if(oasm.vstr.count()==2&&
			ybase::is_jmp_ins(oasm.ins.type)&&
			!sh.m_key.is_asm_reg(oasm.vstr[1]))
		{
			int line=oasm.vstr[1].toint();
			int i;
			for(i=0;i<vasm.count();i++)
			{
				if(ybase::is_tag<rstr>(vasm[i].vstr)&&
					vasm[i].vstr[0]==oasm.vstr[1])
				{
					break;
				}
			}
			if(i>=vasm.count())
			{
				rserror(oasm);
				return false;
			}
			oasm.ins.type*=6;
			oasm.ins.first.type=topnd::c_imme;
			oasm.ins.first.val=(uint)(&vasm[i]);
			return true;
		}
		oasm.ins.type*=6;
		if(!a_asm(sh,oasm))
		{
			rserror(oasm);
			return false;
		}
		return true;
	}

	static int find_comma(tsh& sh,rbuf<rstr>& v)
	{
		int count1=0;
		int count2=0;
		int i;
		for(i=1;i<v.count();i++)
		{
			if(rsoptr(c_sbk_l)==v[i])
			{
				count1++;
			}
			elif(rsoptr(c_sbk_r)==v[i])
			{
				count1--;
			}
			elif(rsoptr(c_mbk_l)==v[i])
			{
				count2++;
			}
			elif(rsoptr(c_mbk_r)==v[i])
			{
				count2--;
			}
			elif(count1==0&&count2==0&&v[i]==rsoptr(c_comma))
			{
				break;
			}
		}
		return i;
	}

	static rbool a_asm(tsh& sh,tasm& item)
	{
		int i=find_comma(sh,item.vstr);
		if(!a_opnd(sh,item,i-1,item.vstr.sub(1,i),item.ins.first))
		{
			return false;
		}
		if(!a_opnd(sh,item,i+1,item.vstr.sub(i+1),item.ins.second))
		{
			return false;
		}
		if(!obtain_qrun_type(item.ins))
		{
			return false;
		}
		if(item.ins.type==tins::c_calle_i)
		{
			ifn(sh.m_func_list.exist((char*)(item.ins.first.val)))
			{
				rserror((char*)(item.ins.first.val));
				return false;
			}
			item.ins.first.val=(int)(sh.m_func_list[(char*)(item.ins.first.val)]);
		}
		return true;
	}

	static rbool obtain_qrun_type(tins& ins)
	{
		if(ins.second.type==topnd::c_null)
		{
			if(ins.first.type==topnd::c_null)
			{
				;
			}
			elif(ins.first.type==topnd::c_imme)
			{
				;
			}
			elif(ins.first.type==topnd::c_reg)
			{
				ins.type+=1;
			}
			elif(ins.first.type==topnd::c_addr)
			{
				ins.type+=2;
			}
			else
			{
				return false;
			}
		}
		else
		{
			if(ins.second.type==topnd::c_imme)
			{
				if(ins.first.type==topnd::c_reg)
				{
					;
				}
				elif(ins.first.type==topnd::c_addr)
				{
					ins.type+=1;
				}
				else
				{
					;
				}
			}
			elif(ins.second.type==topnd::c_reg)
			{
				if(ins.first.type==topnd::c_reg)
				{
					ins.type+=2;
				}
				elif(ins.first.type==topnd::c_addr)
				{
					ins.type+=3;
				}
				else
				{
					return false;
				}
			}
			elif(ins.second.type==topnd::c_addr)
			{
				if(ins.first.type==topnd::c_reg)
				{
					ins.type+=4;
				}
				elif(ins.first.type==topnd::c_addr)
				{
					ins.type+=5;
				}
				else
				{
					return false;
				}
			}
			else
			{
				return false;
			}
		}
		return true;
	}

	static rbool a_opnd(tsh& sh,tasm& item,int index,const rbuf<rstr>& v,topnd& o)
	{
		if(v.empty())
		{
			return true;
		}
		if(v.count()==1)
		{
			if(v.top().is_number())
			{
				//123
				o.type=topnd::c_imme;
				o.val=v.top().touint();
			}
			elif(v[0].get_bottom()==r_char('\"'))
			{
				//"abc"
				trans_cstr(v[0]);
				if(index>=item.vstr.count())
				{
					return false;
				}
				item.vstr[index]=v[0];
				o.type=topnd::c_imme;
				o.val=(uint)(item.vstr[index].begin());
			}
			else
			{
				//ebp
				o.type=topnd::c_reg;
				o.off=get_reg_off(sh,v.top());
			}
		}
		elif(v.count()==3)
		{
			if(v.bottom()==rsoptr(c_mbk_l)&&
				v.top()==rsoptr(c_mbk_r))
			{
				//[ebp]
				o.type=topnd::c_addr;
				o.off=get_reg_off(sh,v[1]);
				o.val=0;
			}
			elif(v.bottom()==rsoptr(c_sbk_l)&&
				v.top()==rsoptr(c_sbk_r)&&
				v[1].is_number())//todo:
			{
				o.type=topnd::c_imme;
				o.val=v[1].touint();
			}
			else
			{
				return false;
			}
		}
		elif(v.count()==5)
		{
			//[ebp+2]
			o.type=topnd::c_addr;
			o.off=get_reg_off(sh,v[1]);
			o.val=v[3].touint();
			if(v[2]==rsoptr(c_minus))
			{
				o.val=-o.val;
			}
		}
		elif(v.count()==7&&v[1]==rsoptr(c_addr))
		{
			tclass* ptci=yfind::class_search(sh,v[3]);
			if(ptci==null)
			{
				return false;
			}
			tfunc* ptfi=yfind::func_search_dec(*ptci,v[5]);
			if(ptfi==null)
			{
				return false;
			}
			ifn(process(sh,*ptfi))
			{
				return false;
			}
			o.type=topnd::c_imme;
			o.val=(int)(ptfi->vasm.begin());
			return true;
		}
		elif(v.count()==0)
		{
			return true;
		}
		else
		{
			return false;
		}
		if(o.off>=r_size(treg))
		{
			return false;
		}
		return true;
	}

	static void trans_cstr(rstr& src)
	{
		if(src.count()<2)
		{
			return;
		}
		rstr dst;
		for(int i=1;i<src.count()-1;i++)
		{
			if(src[i]==r_char('\\'))
			{
				if(src.get(i+1)==r_char('b'))
				{
					dst+=r_char('\b');
				}
				elif(src.get(i+1)==r_char('n'))
				{
					dst+=r_char('\n');
				}
				elif(src.get(i+1)==r_char('r'))
				{
					dst+=r_char('\r');
				}
				elif(src.get(i+1)==r_char('\0'))
				{
					dst+=r_char('\0');
				}
				elif(src.get(i+1)==r_char('x'))
				{
					uchar ch=(uchar)(rstr::hextodec(
						src.sub(i+2,i+4)).touint());
					dst+=ch;
					i=i+3;
					continue;
				}
				else
				{
					dst+=src.get(i+1);
				}
				i++;
			}
			else
			{
				dst+=src[i];
			}
		}
		src=r_move(dst);
		src.m_buf.push((uchar)0);
	}

	static int get_reg_off(tsh& sh,const rstr& s)
	{
		treg reg;
		int ret=r_size(treg);
		if(rskey(c_eax)==s)
		{
			ret=(uchar*)(&reg.eax)-(uchar*)(&reg);
		}
		elif(rskey(c_ebx)==s)
		{
			ret=(uchar*)(&reg.ebx)-(uchar*)(&reg);
		}
		elif(rskey(c_ecx)==s)
		{
			ret=(uchar*)(&reg.ecx)-(uchar*)(&reg);
		}
		elif(rskey(c_edx)==s)
		{
			ret=(uchar*)(&reg.edx)-(uchar*)(&reg);
		}
		elif(rskey(c_esi)==s)
		{
			ret=(uchar*)(&reg.esi)-(uchar*)(&reg);
		}
		elif(rskey(c_edi)==s)
		{
			ret=(uchar*)(&reg.edi)-(uchar*)(&reg);
		}
		elif(rskey(c_esp)==s)
		{
			ret=(uchar*)(&reg.esp)-(uchar*)(&reg);
		}
		elif(rskey(c_ebp)==s)
		{
			ret=(uchar*)(&reg.ebp)-(uchar*)(&reg);
		}
		elif(rskey(c_eip)==s)
		{
			ret=(uchar*)(&reg.eip)-(uchar*)(&reg);
		}
		return ret;
	}
};
﻿#pragma once

#include "znasm.h"

struct zgpp
{
	static rbool process(tsh& sh)
	{
		tfunc* ptfi=yfind::func_search(*sh.m_main,"main");
		if(ptfi==null)
		{
			rserror("main not find");
			return false;
		}
		rstr result;
		rbuf<tfunc*> vdec;
		ifn(proc_func(sh,*ptfi,result,vdec))
		{
			rserror("gpp error");
			return false;
		}
		rstr result_s;
		build_struct_dec(sh,result_s);
		rstr head;
		head+=("#include \""+rcode::utf8_to_gbk(
			ybase::get_rs_dir())+"ext/mingw/gpp.h\"\n");

		head+="\n";

		head+=result_s;
		head+="\n";
		head+="_MAIN _PMAIN;\n";
		head+="\n";
		for(int i=0;i<vdec.count();i++)
		{
			head+=get_func_dec(*vdec[i])+";\n";
		}
		head+="\n";
		head+="int main(){main2Emain2829();return 0;}\n";
		head+="\n";
		head+=result;
		rstr name=ybase::get_main_name(sh)+".cpp";
		rfile file;
		ifn(file.open_n(name,"rw"))
		{
			rserror("file open error");
			return false;
		}
		ifn(file.write(head.size(),head.begin()))
		{
			rserror("file write error");
			return false;
		}
		return true;
	}

	static void build_struct_dec(tsh& sh,rstr& result)
	{
		rset<tgpp> list;//tgpp按照指针大小排序，故每次生成的结构体顺序不一定相同
		for(tclass* p=sh.m_class.begin();p!=sh.m_class.end();p=sh.m_class.next(p))
		{
			tgpp item;
			item.p=p;
			item.visit=false;
			list.insert(item);
		}
		for(tgpp* q=list.begin();q!=list.end();q=list.next(q))
		{
			ifn(q->visit)
			{
				q->visit=true;
				build_struct_dec_one(sh,q,list,result);
			}
		}
	}

	static void build_struct_dec_one(tsh& sh,tgpp* q,rset<tgpp>& list,rstr& result)
	{
		if(is_internal_type(sh,q->p->name))
		{
			return;
		}
		for(int i=0;i<q->p->vdata.count();i++)
		{
			if(ybase::is_quote(q->p->vdata[i].type))
			{
				continue;
			}
			tclass* pclass=yfind::class_search(sh,q->p->vdata[i].type);
			if(pclass==null)
			{
				continue;
			}
			tgpp* pitem=list.find(tgpp(pclass));
			if(pitem==null)
			{
				continue;
			}
			if(pitem->visit)
			{
				continue;
			}
			pitem->visit=true;
			build_struct_dec_one(sh,pitem,list,result);
		}
		result+="struct ";
		if(q->p->name=="main")
		{
			result+="_MAIN";
		}
		else
		{
			result+=type_trans(q->p->name);
		}
		result+="\n{\n";
		for(int i=0;i<q->p->vdata.count();i++)
		{
			result+="	"+type_trans(q->p->vdata[i].type)+" "+q->p->vdata[i].name+";\n";
			if(q->p->vdata[i].count>1)
			{
				result+="	"+type_trans(q->p->vdata[i].type)+" "+q->p->vdata[i].name+"_";
				result+=rstr("[")+(q->p->vdata[i].count-1)+"];\n";
			}
		}
		result+="};\n";
	}

	static rbool is_internal_type(tsh& sh,const rstr& s)
	{
		return ybase::is_basic_type(sh,s)||yfind::is_empty_struct_type(sh,s)||s=="ushort"||s=="int64";
	}

	static rstr type_trans(const rstr& s)
	{
		if(s.sub(0,3)=="rp<")
		{
			if(s.get_right()==r_char('&'))
			{
				return "void*&";
			}
			else
			{
				return "void*";
			}
		}
		if(s.get_right()==r_char('&'))
		{
			return znasm::symbol_trans(s.sub(0,s.count()-1))+"&";
		}
		return znasm::symbol_trans(s);
	}

	static rstr get_func_dec(tfunc& tfi)
	{
		return (type_trans(tfi.retval.type)+" "+znasm::get_nasm_symbol(tfi)+
			"("+get_func_param_declare(tfi)+")");
	}

	static rstr get_func_param_declare(const tfunc& tfi)
	{
		rstr s;
		for(int j=0;j<tfi.param.count();j++)
		{
			if(j!=0)
			{
				s+=",";
			}
			s+=type_trans(tfi.param[j].type)+" "+tfi.param[j].name;
		}
		return r_move(s);
	}

	static void replace_template_type(tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			tclass* ptci=yfind::class_search(sh,v[i].val);
			if(ptci==null)
			{
				continue;
			}
			v[i].val=type_trans(v[i].val);
		}
	}

	static rbool proc_func(tsh& sh,tfunc& tfi,rstr& result,
		rbuf<tfunc*>& vdec,int level=0)
	{
		if(level>300)
		{
			rserror(tfi,"gpp level overflow");
			return false;
		}
		level++;
		if(tfi.count==1)
		{
			return true;
		}
		tfi.count=1;
		if(tfi.is_final)
		{
			replace_template_type(sh,tfi.vword);
			result+=get_func_dec(tfi)+"\n";
			result+="{\n";
			if(tfi.name=="*"&&tfi.param.count()==1&&tfi.ptci->name.sub(0,3)=="rp<")
			{
				//todo:
				result+="return *("+type_trans(ybase::get_tname(tfi.retval.type))+"*)this;";
			}
			else
			{
				rbuf<rstr> vstr=ybase::vword_to_vstr(tfi.vword);
				result+=rstr::join<rstr>(vstr," ");
			}
			result+="\n}\n\n";
			vdec+=&tfi;
			return true;
		}
		if(tfi.vsent.empty())
		{
			ifn(ysent::process(sh,tfi,tenv()))
			{
				rserror(tfi,"sent error");
				return false;
			}
		}
		int id=0;
		ifn(ret_var_proc(sh,tfi,id))
		{
			rserror("");
			return false;
		}
		ifn(param_var_proc(sh,tfi,id))
		{
			rserror("");
			return false;
		}
		for(int i=0;i<tfi.vsent.count();i++)
		{
			if(sh.m_key.is_asm_ins(tfi.vsent[i].vword.get_bottom().val))
			{
				continue;
			}
			if(ybase::is_tag<tword>(tfi.vsent[i].vword))
			{
				continue;
			}
			if(tfi.vsent[i].vword.get(1)==rsoptr(c_equal))
			{
				continue;
			}
			ifn(yexp::p_exp(sh,tfi.vsent[i],tfi,0,tenv()))
			{
				return false;
			}
		}
		rstr symbol=znasm::get_nasm_symbol(tfi);
		result+=get_func_dec(tfi)+"//"+tfi.ptci->name+"."+tfi.name_dec+"\n";
		result+="{\n";
		result+="	int ebx;\n";
		if(tfi.retval.type!=rskey(c_void))
		{
			result+="	";
			if(ybase::is_quote(tfi.retval.type))
			{
				result+=type_trans(tfi.retval.type.sub_trim(1))+"*";
			}
			else
			{
				result+=type_trans(tfi.retval.type);
			}
			result+=" "+tfi.retval.name+";\n";
		}
		for(int i=0;i<tfi.local.count();i++)
		{
			if(!ybase::is_quote(tfi.local[i].type)&&tfi.local[i].name!=rskey(c_pmain))
			{
				result+="	";
				result+=type_trans(tfi.local[i].type)+" "+tfi.local[i].name;
				result+=";\n";
			}
		}
		result+="\n";
		rbuf<rbuf<rstr> > vtemp;
		for(int i=0;i<tfi.vsent.count();i++)
		{
			if(ybase::is_tag<tword>(tfi.vsent[i].vword))
			{
				vtemp+=rf::vstr(tfi.vsent[i].vword[0].val,tfi.vsent[i].vword[1].val);
				//todo:_func_end标号有时不是必须的
				continue;
			}
			rbuf<rstr> vstr=ybase::vword_to_vstr(tfi.vsent[i].vword);
			if(is_call(sh,vstr))
			{
				ifn(call_trans(sh,tfi,vstr))
				{
					return false;
				}
			}
			//只有int或者int&可以作为逻辑判断条件
			if(ybase::get_tname(tfi.vsent[i].type)=="int")
			{
				vstr.push_front("=");
				vstr.push_front("ebx");
			}
			vtemp+=vstr;
		}
		ifn(ret_quote_trans(vtemp,tfi))
		{
			rserror("");
			return false;
		}
		control_trans(tfi,vtemp);
		for(int i=0;i<vtemp.count();i++)
		{
			ifn(ybase::is_tag<rstr>(vtemp[i]))
			{
				result+="	";
			}
			result+=rstr::join<rstr>(vtemp[i]," ");
			result+=" ;\n";
		}
		if(tfi.retval.type!=rskey(c_void))
		{
			if(ybase::is_quote(tfi.retval.type))
			{
				result+="	return *"+tfi.retval.name+";\n";
			}
			else
			{
				result+="	return "+tfi.retval.name+";\n";
			}
		}
		result+="}\n\n";
		for(int i=0;i<tfi.vsent.count();i++)
		{
			if(ybase::is_tag<tword>(tfi.vsent[i].vword))
			{
				continue;
			}
			rbuf<rstr> vstr=ybase::vword_to_vstr(tfi.vsent[i].vword);
			ifn(proc_func_v(sh,tfi,result,vdec,level,vstr))
			{
				return false;
			}
		}
		vdec+=&tfi;
		return true;
	}

	static rbool ret_quote_trans(rbuf<rbuf<rstr> >& v,tfunc& tfi)
	{
		ifn(ybase::is_quote(tfi.retval.type))
		{
			return true;
		}
		for(int i=1;i<v.count();i++)
		{
			ifn(v[i].get_left()=="jmp"&&v[i].get(1)=="_func_end")
			{
				continue;
			}
			//上一句不一定是原来的返回语句，中间只可能间隔析构函数，析构函数特征是无返回值
			int j;
			for(j=i-1;j>=0;j--)
			{
				ifn(tfi.vsent[j].type=="void"||tfi.vsent[j].type.empty())
				{
					break;
				}
			}
			if(j<0)
			{
				return false;
			}
			if(v[j].count()>2&&v[j][0]=="ebx"&&v[j][1]=="=")
			{
				v[j]=v[j].sub(2);
			}
			v[j]=rf::vstr(tfi.retval.name,"=","&")+v[j];
		}
		return true;
	}

	static void control_trans(tfunc& tfi,rbuf<rbuf<rstr> >& v)
	{
		rbuf<rbuf<rstr> > result;
		for(int i=0;i<v.count();i++)
		{
			if(v[i].get_left()=="jebxz")
			{
				rbuf<rstr> temp;
				temp+="if";
				temp+="(";
				temp+="!";
				temp+="ebx";
				temp+=")";
				temp+="jmp";
				temp+=v[i].get(1);
				result+=temp;
			}
			elif(v[i].get_left()=="jebxnz")
			{
				rbuf<rstr> temp;
				temp+="if";
				temp+="(";
				temp+="ebx";
				temp+=")";
				temp+="jmp";
				temp+=v[i].get(1);
				result+=temp;
			}
			elif(v[i].get_left()=="cnesb")
			{
				rbuf<rstr> temp;
				temp+="ebx";
				temp+="=";
				temp+=v[i].get(1);
				temp+="!=";
				temp+=v[i].get(3);
				result+=temp;
			}
			elif(v[i].get_left()=="cesb")
			{
				rbuf<rstr> temp;
				temp+="ebx";
				temp+="=";
				temp+=v[i].get(1);
				temp+="==";
				temp+=v[i].get(3);
				result+=temp;
			}
			elif(v[i].get_left()=="mov")
			{
				rbuf<rstr> temp;
				int j;
				for(j=0;j<tfi.local.count();j++)
				{
					if(tfi.local[j].name==v[i].get(1)&&ybase::is_quote(tfi.local[j].type))
					{
						temp+=type_trans(tfi.local[j].type);
						temp+=v[i].get(1);
						temp+="=";
						temp+="*("+type_trans(tfi.local[j].type).sub_trim(1)+"*)";
						temp+=v[i].get(3);
						result+=temp;
						break;
					}
				}
				if(j<tfi.local.count())
				{
					continue;
				}
				temp+=v[i].get(1);
				temp+="=";
				temp+=v[i].get(3);
				result+=temp;
			}
			else
			{
				result+=v[i];
			}
		}
		v=result;
	}

	static rbool proc_func_v(tsh& sh,tfunc& tfi,rstr& result,
		rbuf<tfunc*>& vdec,int level,const rbuf<rstr>& v)
	{
		if(v.count()==1)
		{
			return true;
		}
		if(v.get(1)==rsoptr(c_equal))
		{
			return proc_func_v(sh,tfi,result,vdec,level,v.sub(2));
		}
		if(v.get_left()==rsoptr(c_mbk_l))
		{
			if(v.get(1)==rsoptr(c_addr)&&v.count()==7)
			{
				tclass* ptci=yfind::class_search(sh,v[3]);
				if(ptci==null)
				{
					rserror("");
					return false;
				}
				tfunc* ptfi=yfind::func_search_dec(*ptci,v[5]);
				if(ptfi==null)
				{
					rserror("");
					return false;
				}
				ifn(proc_func(sh,*ptfi,result,vdec,level))
				{
					return false;
				}
				return true;
			}
			if(v.get(1)==rsoptr(c_dot))
			{
				rbuf<rbuf<rstr> > vparam=ybase::comma_split<rstr>(
					sh,v.sub(1,v.count()-1));
				if(vparam.count()!=3)
				{
					rserror("");
					return false;
				}
				ifn(proc_func_v(sh,tfi,result,vdec,level,vparam[1]))
				{
					return false;
				}
				return true;
			}
			if(v.get(1)==rskey(c_pcall))
			{
				rbuf<rbuf<rstr> > vparam=ybase::comma_split<rstr>(
					sh,v.sub(1,v.count()-1));
				if(vparam.count()!=5)
				{
					rserror("");
					return false;
				}
				ifn(proc_func_v(sh,tfi,result,vdec,level,vparam[3]))
				{
					return false;
				}
				vparam=ybase::comma_split<rstr>(
					sh,vparam[4].sub(1,vparam[4].count()-1));
				for(int i=0;i<vparam.count();i++)
				{
					ifn(proc_func_v(sh,tfi,result,vdec,level,vparam[i]))
					{
						return false;
					}
				}
				return true;
			}
			tfunc* ptfi=call_find(sh,v);
			if(ptfi==null)
			{
				rserror("");
				return false;
			}
			rbuf<rbuf<rstr> > vparam=ybase::comma_split<rstr>(
				sh,v.sub(6,v.count()-2));
			for(int i=0;i<vparam.count();i++)
			{
				ifn(proc_func_v(sh,tfi,result,vdec,level,vparam[i]))
				{
					return false;
				}
			}
			ifn(proc_func(sh,*ptfi,result,vdec,level))
			{
				return false;
			}
			return true;
		}
		return true;
	}

	static rbool is_call(tsh& sh,const rbuf<rstr>& v)
	{
		if(v.get(1)==rsoptr(c_equal))
		{
			return is_call(sh,v.sub(2));
		}
		if(call_find(sh,v)!=null)
		{
			return true;
		}
		return v.get(0)=="["&&(v.get(1)==rskey(c_pcall)||v.get(1)==rsoptr(c_dot));
	}

	static tfunc* call_find(tsh& sh,const rbuf<rstr>& v)
	{
		if(v.get(1)==rsoptr(c_equal))
		{
			return call_find(sh,v.sub(2));
		}
		tclass* ptci=yfind::class_search(sh,v.get(1));
		if(ptci==null)
		{
			return null;
		}
		rstr fname=v.get(3);
		return yfind::func_search_dec(*ptci,fname);
	}

	static rbool dot_trans(tsh& sh,tfunc& tfi,rbuf<rstr>& v)
	{
		rbuf<rstr> result;
		rbuf<rbuf<rstr> > vparam=ybase::comma_split<rstr>(
			sh,v.sub(1,v.count()-1));
		if(vparam.count()!=3)
		{
			rserror("");
			return false;
		}
		ifn(call_trans(sh,tfi,vparam[1]))
		{
			return false;
		}
		ifn(call_trans(sh,tfi,vparam[2]))
		{
			return false;
		}
		result+=vparam[1];
		result+=".";
		result+=vparam[2];
		v=result;
		return true;
	}

	static rbool is_cpoint(const rstr& val)
	{
		return val.sub(0,val.count()-1).is_number()&&val.get_right()==r_char('p');
	}

	static rbool call_trans(tsh& sh,tfunc& tfi,rbuf<rstr>& v)
	{
		if(v.get(1)==rsoptr(c_equal))
		{
			rbuf<rstr> temp=v.sub(2);
			rbool retval=call_trans(sh,tfi,temp);
			v=v.sub(0,2)+temp;
			return retval;
		}
		if(v.count()==1)
		{
			if(v[0].get_left()==r_char('\"'))
			{
				v[0]="(void*)"+v[0];
			}
			elif(is_cpoint(v[0]))
			{
				v[0]="(void*)"+v[0].sub(0,v[0].count()-1);
			}
			elif(v[0].is_number())
			{
				v[0]+="u";
			}
			return true;
		}
		if(v.get_left()==rsoptr(c_mbk_l))
		{
			if(v.count()==7&&v[1]=="&")
			{
				v=rf::vstr("((void*)&"+znasm::symbol_trans(v[3]+"."+v[5])+")");
				return true;
			}
			if(v.get(1)==".")
			{
				return dot_trans(sh,tfi,v);
			}
			if(v.get(1)==rskey(c_pcall))
			{
				rbuf<rbuf<rstr> > vparam=ybase::comma_split<rstr>(
					sh,v.sub(1,v.count()-1));
				if(vparam.count()!=5)
				{
					rserror("");
					return false;
				}
				for(int i=1;i<vparam[2].count()-1;i+=2)
				{
					vparam[2][i]=type_trans(vparam[2][i]);
				}
				ifn(call_trans(sh,tfi,vparam[3]))
				{
					return false;
				}
				v=rf::vstr("(("+type_trans(vparam[1].get(0))+" (*)("+
					rstr::join<rstr>(vparam[2].sub(1,vparam[2].count()-1),"")+"))"+
					rstr::join<rstr>(vparam[3],"")+")(");
				vparam=ybase::comma_split<rstr>(
					sh,vparam[4].sub(1,vparam[4].count()-1));
				for(int i=0;i<vparam.count();i++)
				{
					if(i!=0)
					{
						v[0]+=",";
					}
					ifn(call_trans(sh,tfi,vparam[i]))
					{
						return false;
					}
					v[0]+=rstr::join<rstr>(vparam[i],"");
				}
				v[0]+=")";
				return true;
			}
			tfunc* ptfi=call_find(sh,v);
			if(ptfi==null)
			{
				rserror("");
				return false;
			}
			rbuf<rstr> result;
			result+=znasm::get_nasm_symbol(*ptfi);
			result+="(";
			rbuf<rbuf<rstr> > vparam=ybase::comma_split<rstr>(
				sh,v.sub(6,v.count()-2));
			for(int i=0;i<vparam.count();i++)
			{
				if(i!=0)
				{
					result+=",";
				}
				ifn(call_trans(sh,tfi,vparam[i]))
				{
					return false;
				}
				result+=vparam[i];
			}
			result+=")";
			v=result;
			return true;
		}
		rserror("");
		return false;
	}

	static rbool ret_var_proc(tsh& sh,tfunc& tfi,int& id)
	{
		for(int j=0;j<c_rs_deep;j++)
		{
			for(int i=0;i<tfi.vsent.count();i++)
			{
				ifn(ret_var_proc_one(sh,tfi.vsent[i].vword,id,tfi))
				{
					return false;
				}
			}
			ifn(ybase::part_vsent(tfi.vsent))
			{
				return true;
			}
		}
		return false;
	}

	static rbool ret_var_proc_one(tsh& sh,rbuf<tword>& v,int& id,tfunc& tfi)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i]!=rsoptr(c_mbk_l))
			{
				continue;
			}
			rstr type;
			if(v.get(i+1).val==rskey(c_pcall))
			{
				type=v.get(i+3).val;
			}
			else
			{
				tclass* ptci=yfind::class_search(sh,v.get(i+1).val);
				if(ptci==null)
				{
					continue;
				}
				tfunc* ptfi=yfind::func_search_dec(*ptci,v.get(i+3).val);
				if(ptfi==null)
				{
					continue;
				}
				type=ptfi->retval.type;
			}
			if(ybase::is_quote(type))
			{
				continue;
			}
			if(yfind::is_empty_struct_type(sh,type)||
				type==rskey(c_void))
			{
				continue;
			}
			if(v.get(i-1)==rsoptr(c_equal))
			{
				continue;
			}
			int right=ybase::find_symm_mbk(sh,v,i);
			if(right>=v.count())
			{
				return false;
			}
			rstr name=rstr("_GRET")+id;
			id++;
			rbuf<tword> vword;
			tfi.local.push(tdata(type,name));
			vword+=name;
			vword+=rsoptr(c_equal);
			vword+=v.sub(i,right+1);
			vword+=rsoptr(c_semi);
			if(i!=0)
			{
				vword+=v.sub(0,i);
				vword+=name;
				vword+=v.sub(right+1);
			}
			vword+=rsoptr(c_semi);
			vword+=rsoptr(c_mbk_l);
			vword+=type;
			vword+=rsoptr(c_comma);
			vword+="~"+type+"("+type+"&)";
			vword+=rsoptr(c_comma);
			vword+=rsoptr(c_mbk_l);
			vword+=name;
			vword+=rsoptr(c_mbk_r);
			vword+=rsoptr(c_mbk_r);
			v=r_move(vword);
			return true;
		}
		return true;
	}

	static rbool param_var_proc(tsh& sh,tfunc& tfi,int& id)
	{
		for(int j=0;j<c_rs_deep;j++)
		{
			for(int i=0;i<tfi.vsent.count();i++)
			{
				ifn(param_var_proc_one(sh,tfi.vsent[i].vword,id,tfi))
				{
					return false;
				}
			}
			ifn(ybase::part_vsent(tfi.vsent))
			{
				return true;
			}
		}
		return false;
	}

	static rbool param_var_proc_one(tsh& sh,rbuf<tword>& v,int& id,tfunc& tfi)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i]!=rsoptr(c_mbk_l))
			{
				continue;
			}
			tclass* ptci=yfind::class_search(sh,v.get(i+1).val);
			if(ptci==null)
			{
				continue;
			}
			tfunc* ptfi=yfind::func_search_dec(*ptci,v.get(i+3).val);
			if(ptfi==null)
			{
				continue;
			}
			int right=ybase::find_symm_mbk(sh,v,i);
			if(right>=v.count())
			{
				return false;
			}
			rbuf<rbuf<tword> > vparam=ybase::comma_split<tword>(sh,v.sub(i+6,right-1));
			for(int j=0;j<ptfi->param.count();j++)
			{
				rstr type=ptfi->param[j].type;
				if(ybase::is_quote(type))
				{
					continue;
				}
				if(yfind::is_empty_struct_type(sh,type))
				{
					continue;
				}
				if(vparam[j].count()==1&&vparam[j][0].val.sub(0,7)=="_GPARAM")
				{
					continue;
				}
				rstr name=rstr("_GPARAM")+id;
				id++;
				rbuf<tword> vword;
				tfi.local.push(tdata(type,name));
				vword+=rsoptr(c_mbk_l);
				vword+=type;
				vword+=rsoptr(c_comma);
				vword+=type+"("+type+"&,"+type+"&)";
				vword+=rsoptr(c_comma);
				vword+=rsoptr(c_mbk_l);
				vword+=name;
				vword+=rsoptr(c_comma);
				vword+=vparam[j];
				vword+=rsoptr(c_mbk_r);
				vword+=rsoptr(c_mbk_r);
				vword+=rsoptr(c_semi);
				vword+=v.sub(0,i+6);
				vparam[j].clear();
				vparam[j]+=name;
				for(int k=0;k<vparam.count();k++)
				{
					if(k!=0)
					{
						vword+=rsoptr(c_comma);
					}
					vword+=vparam[k];
				}
				vword+=v.sub(right-1);
				v=r_move(vword);
				return true;
			}
		}
		return true;
	}
};
﻿#pragma once

#include "../front/ypre.h"
#include "zjiti.h"
#include "zjitf.h"
#include "znasm.h"

struct zjit
{
	static rbool run(tsh& sh)
	{
#ifndef _RS
		tfunc* ptfi=yfind::func_search(*sh.m_main,"__declare");
		if(ptfi!=null)
		{
			func_to_x86(sh,*ptfi,tenv());
		}
		ptfi=yfind::func_search(*sh.m_main,"main_c");
		if(ptfi==null)
		{
			rf::printl("main not find");
			return false;
		}
		ifn(func_to_x86(sh,*ptfi,tenv()))
		{
			return false;
		}
		((void (*)())(ptfi->code))();
#endif
		return true;
	}

	//将一个函数翻译成X86代码
	static rbool func_to_x86(tsh& sh,tfunc& tfi,tenv env)
	{
		if(!tfi.vasm.empty())
		{
			return true;
		}
		if(!zbin::cp_vword_to_vasm(sh,tfi,env))
		{
			return false;
		}
		int size=tfi.vasm.count()*6;//todo 估算法并不是最好的方法
		size=r_ceil_div(size,4096)*4096;
		if(tfi.code==null)
		{
			tfi.code=xf::alloc_v(size);
			if(tfi.code==null)
			{
				return false;
			}
			sh.m_addr.insert(taddr(
				(uint)(tfi.code),(uint)(tfi.code+size),&tfi));
		}
		int cur=0;
		for(int i=0;i<tfi.vasm.count();i++)
		{
			if(ybase::is_tag<rstr>(tfi.vasm[i].vstr))
			{
				continue;
			}
			tfi.vasm[i].ptfi=&tfi;
			ifn(a_asm(sh,tfi.vasm[i]))
			{
				return false;
			}
			tfi.vasm[i].start=tfi.code+cur;
			rstr s=asm_to_x86(sh,tfi.vasm[i],tfi.code+cur);
			if(s.empty())
			{
				rserror(tfi.vasm[i],"can't build jit ins");
				return false;
			}
			if(cur+s.count()>size)
			{
				rserror(tfi,"func too big");
				return false;
			}
			xf::memcpy(tfi.code+cur,s.begin(),s.count());
			cur+=s.count();
		}
		for(int i=0;i<tfi.vasm.count();i++)
		{
			ifn(fix_addr(sh,tfi.vasm[i],tfi.vasm))
			{
				return false;
			}
		}
		return true;
	}

	static rbool fix_addr(tsh& sh,tasm& oasm,rbuf<tasm>& vasm)
	{
		ifn(oasm.vstr.count()==2&&
			ybase::is_jmp_ins(oasm.ins.type)&&
			!sh.m_key.is_asm_reg(oasm.vstr[1]))
		{
			return true;
		}
		int line=oasm.vstr[1].toint();
		int i;
		for(i=0;i<vasm.count();i++)
		{
			if(ybase::is_tag<rstr>(vasm[i].vstr)&&
				vasm[i].vstr[0]==oasm.vstr[1])
			{
				break;
			}
		}
		if(i>=vasm.count())
		{
			rserror(oasm);
			return false;
		}
		ifn(a_asm(sh,oasm))
		{
			return false;
		}
		int j;
		for(j=i+1;j<vasm.count();j++)
		{
			ifn(ybase::is_tag<rstr>(vasm[j].vstr))
			{
				break;
			}
		}
		if(j>=vasm.count())
		{
			rserror(oasm);
			return false;
		}
		oasm.ins.first.type=topnd::c_imme;
		oasm.ins.first.val=(uint)(vasm[j].start);
		uchar* real=oasm.start;
		rstr s=asm_to_x86(sh,oasm,real);
		if(s.empty())
		{
			return false;
		}
		xf::memcpy(real,s.begin(),s.count());
		return true;
	}

	static rstr asm_to_x86(tsh& sh,tasm& item,uchar* start)
	{
#ifndef _RS
		tins& ins=item.ins;
		rbuf<rstr>& vstr=item.vstr;
		rstr s;
		switch(ins.type)
		{
		case tkey::c_calle:
			return p_calle(sh,ins,start);
		case tkey::c_call:
			return zjiti::b_call(ins,start);
		case tkey::c_retn:
			return zjiti::b_retn();
		case tkey::c_reti:
			return zjiti::b_reti(ins);
		case tkey::c_push:
			return zjiti::b_push(ins);
		case tkey::c_pop:
			return zjiti::b_pop(ins);
		case tkey::c_jmp:
			return zjiti::b_jmp(ins,start);
		case tkey::c_jebxz:
			return (rsj4(b_cmp,rskey(c_ebx),rsoptr(c_comma),"0")+
				zjiti::b_jz(ins,start+6));
		case tkey::c_jebxnz:
			return (rsj4(b_cmp,rskey(c_ebx),rsoptr(c_comma),"0")+
				zjiti::b_jnz(ins,start+6));
		case tkey::c_nop:
			return zjiti::b_nop();
		case tkey::c_lea:
			if(znasm::count_mbk_l(vstr)!=2)
			{
				return zjiti::b_lea(ins);
			}
			//应该检查b_lea是否返回空串
			return (rsj4(b_lea,rskey(c_ecx),rsoptr(c_comma),rsjb)+
				rsj4(b_mov,rsja,rsoptr(c_comma),rskey(c_ecx)));
		case tkey::c_mov:
			if(znasm::count_mbk_l(vstr)!=2)
			{
				return zjiti::b_mov(ins);
			}
			return (rsj4(b_mov,rskey(c_ecx),rsoptr(c_comma),rsjb)+
				rsj4(b_mov,rsja,rsoptr(c_comma),rskey(c_ecx)));
		case tkey::c_movb:
			return (rsj4(b_movb_cl_addr,rskey(c_ecx),rsoptr(c_comma),rsjb)+
				rsj4(b_movb_addr_cl,rsja,rsoptr(c_comma),rskey(c_ecx)));
		case tkey::c_movl:
			s+=rsj4(b_mov,rskey(c_ecx),rsoptr(c_comma),rsjb);
			s+=rsj4(b_mov,rsja,rsoptr(c_comma),rskey(c_ecx));
			ins.first.val+=4;
			ins.second.val+=4;
			s+=rsj4(b_mov,rskey(c_ecx),rsoptr(c_comma),rsjb);
			s+=rsj4(b_mov,rsja,rsoptr(c_comma),rskey(c_ecx));
			return r_move(s);
		case tkey::c_add:
			if(znasm::count_mbk_l(vstr)!=2)
			{
				return zjiti::b_add(ins);
			}
			return (rsj4(b_mov,rskey(c_ecx),rsoptr(c_comma),rsjb)+
				rsj4(b_add,rsja,rsoptr(c_comma),rskey(c_ecx)));
		case tkey::c_sub:
			if(znasm::count_mbk_l(vstr)!=2)
			{
				return zjiti::b_sub(ins);
			}
			return (rsj4(b_mov,rskey(c_ecx),rsoptr(c_comma),rsjb)+
				rsj4(b_sub,rsja,rsoptr(c_comma),rskey(c_ecx)));
		case tkey::c_imul:
			return (rsj4(b_mov,rskey(c_ecx),rsoptr(c_comma),rsja)+
				rsj4(b_imul,rskey(c_ecx),rsoptr(c_comma),rsjb)+
				rsj4(b_mov,rsja,rsoptr(c_comma),rskey(c_ecx)));
		case tkey::c_idiv:
			return (rsj4(b_mov,rskey(c_eax),rsoptr(c_comma),rsja)+
				zjiti::b_cdq()+
				rsj4(b_mov,rskey(c_ecx),rsoptr(c_comma),rsjb)+
				rsj4(b_idiv,rskey(c_ecx),rsoptr(c_comma),"0")+
				rsj4(b_mov,rsja,rsoptr(c_comma),rskey(c_eax)));
		case tkey::c_imod:
			return (rsj4(b_mov,rskey(c_eax),rsoptr(c_comma),rsja)+
				zjiti::b_cdq()+
				rsj4(b_mov,rskey(c_ecx),rsoptr(c_comma),rsjb)+
				rsj4(b_idiv,rskey(c_ecx),rsoptr(c_comma),"0")+
				rsj4(b_mov,rsja,rsoptr(c_comma),rskey(c_edx)));
		case tkey::c_udiv:
			return (rsj4(b_mov,rskey(c_eax),rsoptr(c_comma),rsja)+
				rsj4(b_xor,rskey(c_edx),rsoptr(c_comma),rskey(c_edx))+
				rsj4(b_mov,rskey(c_ecx),rsoptr(c_comma),rsjb)+
				rsj4(b_udiv,rskey(c_ecx),rsoptr(c_comma),"0")+
				rsj4(b_mov,rsja,rsoptr(c_comma),rskey(c_eax)));
		case tkey::c_umod:
			return (rsj4(b_mov,rskey(c_eax),rsoptr(c_comma),rsja)+
				rsj4(b_xor,rskey(c_edx),rsoptr(c_comma),rskey(c_edx))+
				rsj4(b_mov,rskey(c_ecx),rsoptr(c_comma),rsjb)+
				rsj4(b_udiv,rskey(c_ecx),rsoptr(c_comma),"0")+
				rsj4(b_mov,rsja,rsoptr(c_comma),rskey(c_edx)));
		case tkey::c_cesb:
			return jcmp(sh,item,zjiti::b_sete_bl());
		case tkey::c_cnesb:
			return jcmp(sh,item,zjiti::b_setne_bl());
		case tkey::c_cgsb:
			return jcmp(sh,item,zjiti::b_setg_bl());
		case tkey::c_cgesb:
			return jcmp(sh,item,zjiti::b_setge_bl());
		case tkey::c_clsb:
			return jcmp(sh,item,zjiti::b_setl_bl());
		case tkey::c_clesb:
			return jcmp(sh,item,zjiti::b_setle_bl());
		case tkey::c_ucgsb:
			return jcmp(sh,item,zjiti::b_seta_bl());
		case tkey::c_ucgesb:
			return jcmp(sh,item,zjiti::b_setae_bl());
		case tkey::c_uclsb:
			return jcmp(sh,item,zjiti::b_setb_bl());
		case tkey::c_uclesb:
			return jcmp(sh,item,zjiti::b_setbe_bl());
		case tkey::c_band:
			if(znasm::count_mbk_l(vstr)!=2)
			{
				return zjiti::b_and(ins);
			}
			return (rsj4(b_mov,rskey(c_ecx),rsoptr(c_comma),rsjb)+
				rsj4(b_and,rsja,rsoptr(c_comma),rskey(c_ecx)));
		case tkey::c_bor:
			if(znasm::count_mbk_l(vstr)!=2)
			{
				return zjiti::b_or(ins);
			}
			return (rsj4(b_mov,rskey(c_ecx),rsoptr(c_comma),rsjb)+
				rsj4(b_or,rsja,rsoptr(c_comma),rskey(c_ecx)));
		case tkey::c_bxor:
			if(znasm::count_mbk_l(vstr)!=2)
			{
				return zjiti::b_xor(ins);
			}
			return (rsj4(b_mov,rskey(c_ecx),rsoptr(c_comma),rsjb)+
				rsj4(b_xor,rsja,rsoptr(c_comma),rskey(c_ecx)));
		case tkey::c_bnot:
			return zjiti::b_not(ins);
		}
#endif
		return rstr();
	}

	static rstr jcmp(tsh& sh,tasm& item,const rstr& cont)
	{
		rstr s;
		if(znasm::count_mbk_l(item.vstr)==2)
		{
			s+=zjiti::b_mov(build_ins(sh,rskey(c_nop),rskey(c_ecx),
				rsoptr(c_comma),znasm::get_opnd2_v(item.vstr)));
			s+=zjiti::b_cmp(build_ins(sh,rskey(c_nop),
				znasm::get_opnd1_v(item.vstr),
				rsoptr(c_comma),rskey(c_ecx)));
		}
		else
		{
			s+=zjiti::b_cmp(item.ins);
		}
		s+=zjiti::b_mov(build_ins(sh,rskey(c_nop),rskey(c_ebx),rsoptr(c_comma),"0"));
		s+=cont;
		return r_move(s);
	}

	static rstr p_calle(tsh& sh,tins& ins,uchar* start)
	{
		char* name=(char*)(ins.first.val);
		void* addr=null;
		if(sh.m_func_list.find(name)!=null)
		{
			addr=sh.m_func_list[name];
		}
		if(addr==null)
		{
			//addr=zjitf::find_dll_full(name);
			return rstr();
		}
		ins.first.val=(int)addr;
		return zjiti::b_call(ins,start);
	}

	static rbool a_asm(tsh& sh,tasm& item)
	{
		int type=sh.m_key.get_key_index(item.vstr.get_bottom());
		if(ybase::is_jmp_ins(type)&&item.vstr.count()==2&&
			!sh.m_key.is_asm_reg(item.vstr[1]))
		{
			item.ins.type=type;
			item.ins.first.type=topnd::c_imme;
			item.ins.second.type=topnd::c_imme;
			return true;
		}
		int i=zbin::find_comma(sh,item.vstr);
		if(!a_opnd(sh,item,i-1,item.vstr.sub(1,i),item.ins.first))
		{
			return false;
		}
		if(!a_opnd(sh,item,i+1,item.vstr.sub(i+1),item.ins.second))
		{
			return false;
		}
		item.ins.type=sh.m_key.get_key_index(item.vstr.get_bottom());
		return true;
	}

	static rbool a_opnd(tsh& sh,tasm& item,int index,const rbuf<rstr>& v,topnd& o)
	{
		if(v.count()==7&&v[1]==rsoptr(c_addr))
		{
			tfunc* ptfi=znasm::call_find(sh,item);
			if(ptfi==null)
			{
				return false;
			}
			ifn(func_to_x86(sh,*ptfi,tenv()))
			{
				return false;
			}
			o.type=topnd::c_imme;
			o.val=(uint)(ptfi->code);
			return true;
		}
		return zbin::a_opnd(sh,item,index,v,o);
	}

	static tins build_ins(tsh& sh,rstr s1,rstr s2,rstr s3,rstr s4)
	{
		tasm item;
		item.vstr+=s1;
		item.vstr+=s2;
		item.vstr+=s3;
		item.vstr+=s4;
		a_asm(sh,item);
		return item.ins;
	}

	static tins build_ins(tsh& sh,rstr s1,rstr s2,rstr s3,rbuf<rstr> s4)
	{
		tasm item;
		item.vstr+=s1;
		item.vstr+=s2;
		item.vstr+=s3;
		item.vstr+=s4;
		a_asm(sh,item);
		return item.ins;
	}

	static tins build_ins(tsh& sh,rstr s1,rbuf<rstr> s2,rstr s3,rstr s4)
	{
		tasm item;
		item.vstr+=s1;
		item.vstr+=s2;
		item.vstr+=s3;
		item.vstr+=s4;
		a_asm(sh,item);
		return item.ins;
	}
};
﻿#pragma once

#include "../struct/tbase.h"

//jit基础类
struct zjitb
{
	static rstr build_one(int one)
	{
		rstr s;
		s.set_size(1);
		s[0]=one;
		return r_move(s);
	}

	static rstr build_two(int one,int two)
	{
		rstr s;
		s.set_size(2);
		s[0]=one;
		s[1]=two;
		return r_move(s);
	}

	static rstr build_three(int one,int two,int three)
	{
		rstr s;
		s.set_size(3);
		s[0]=one;
		s[1]=two;
		s[2]=three;
		return r_move(s);
	}

	static rstr build_i(const tins& ins,int one)
	{
		rstr s;
		s.set_size(5);
		s[0]=one;
		*(int*)(&s[1])=ins.first.val;
		return r_move(s);
	}

	static rstr build_r(const tins& ins,int one)
	{
		rstr s;
		s.set_size(1);
		s[0]=one;
		set_reg_bit(ins.first.off,&s[0]);
		return r_move(s);
	}

	static rstr build_r(const tins& ins,int one,int two)
	{
		rstr s;
		s.set_size(2);
		s[0]=one;
		s[1]=two;
		set_reg_bit(ins.first.off,&s[1]);
		return r_move(s);
	}

	static rstr build_a(const tins& ins,int one,int two)
	{
		rstr s;
		if(ins.first.off==treg::c_esp)
		{
			s.set_size(7);
		}
		else
		{
			s.set_size(6);
		}
		s[0]=one;
		s[1]=two;
		set_addr_bit(ins.first.off,&s[1],ins.first.val);
		return r_move(s);
	}

	static rstr build_relative(const tins& ins,uchar* start,int one)
	{
		rstr s;
		s.set_size(5);
		s[0]=one;
		*(int*)(&s[1])=ins.first.val-((int)start+s.count());
		return r_move(s);
	}

	static rstr build_relative(const tins& ins,uchar* start,int one,int two)
	{
		rstr s;
		s.set_size(6);
		s[0]=one;
		s[1]=two;
		*(int*)(&s[2])=ins.first.val-((int)start+s.count());
		return r_move(s);
	}

	static rstr build_ri(const tins& ins,int one)
	{
		rstr s;
		s.set_size(5);
		s[0]=one;
		set_reg_bit(ins.first.off,&s[0]);
		*(int*)(&s[1])=ins.second.val;
		return r_move(s);
	}

	static rstr build_ri(const tins& ins,int one,int two)
	{
		rstr s;
		s.set_size(6);
		s[0]=one;
		s[1]=two;
		set_reg_bit(ins.first.off,&s[1]);
		*(int*)(&s[2])=ins.second.val;
		return r_move(s);
	}

	static rstr build_rr(const tins& ins,int one,int two)
	{
		rstr s;
		s.set_size(2);
		s[0]=one;
		s[1]=two;
		set_reg_bit_center(ins.first.off,&s[1]);
		set_reg_bit(ins.second.off,&s[1]);
		return r_move(s);
	}

	static rstr build_ra(const tins& ins,int one,int two)
	{
		rstr s;
		if(ins.second.off==treg::c_esp)
		{
			s.set_size(7);
		}
		else
		{
			s.set_size(6);
		}
		s[0]=one;
		s[1]=two;
		set_reg_bit_center(ins.first.off,&s[1]);
		set_addr_bit(ins.second.off,&s[1],ins.second.val);
		return r_move(s);
	}

	static rstr build_ai(const tins& ins,int one,int two)
	{
		rstr s;
		if(ins.first.off==treg::c_esp)
		{
			s.set_size(11);
			*(int*)&s[7]=ins.second.val;
		}
		else
		{
			s.set_size(10);
			*(int*)&s[6]=ins.second.val;
		}
		s[0]=one;
		s[1]=two;
		set_addr_bit(ins.first.off,&s[1],ins.first.val);
		return r_move(s);
	}

	static rstr build_ar(const tins& ins,int one,int two)
	{
		rstr s;
		if(ins.first.off==treg::c_esp)
		{
			s.set_size(7);
		}
		else
		{
			s.set_size(6);
		}
		s[0]=one;
		s[1]=two;
		set_addr_bit(ins.first.off,&s[1],ins.first.val);
		set_reg_bit_center(ins.second.off,&s[1]);
		return r_move(s);
	}

	static rstr build_ra(const tins& ins,int one,int two,int three)
	{
		rstr s;
		if(ins.second.off==treg::c_esp)
		{
			s.set_size(8);
		}
		else
		{
			s.set_size(7);
		}
		s[0]=one;
		s[1]=two;
		s[2]=three;
		set_reg_bit_center(ins.first.off,&s[2]);
		set_addr_bit(ins.second.off,&s[2],ins.second.val);
		return r_move(s);
	}

	//设置寄存器相对寻址位
	static void set_addr_bit(int off,uchar* start,int val)
	{
		if(off==treg::c_esp)
		{
			*start|=0x4;
			*(start+1)=0x24;
			*(int*)(start+2)=val;
			return;
		}
		*(int*)(start+1)=val;
		if(off==treg::c_ebp)
		{
			*start|=0x5;
		}
		elif(off==treg::c_esi)
		{
			*start|=0x6;
		}
		elif(off==treg::c_edi)
		{
			*start|=0x7;
		}
		elif(off==treg::c_eax)
		{
			*start|=0x0;
		}
		elif(off==treg::c_ebx)
		{
			*start|=0x3;
		}
		elif(off==treg::c_ecx)
		{
			*start|=0x1;
		}
		elif(off==treg::c_edx)
		{
			*start|=0x2;
		}
	}

	static void set_reg_bit(int off,uchar* start)
	{
		if(off==treg::c_esp)
		{
			*start|=0x4;
		}
		elif(off==treg::c_ebp)
		{
			*start|=0x5;
		}
		elif(off==treg::c_esi)
		{
			*start|=0x6;
		}
		elif(off==treg::c_edi)
		{
			*start|=0x7;
		}
		elif(off==treg::c_eax)
		{
			*start|=0x0;
		}
		elif(off==treg::c_ebx)
		{
			*start|=0x3;
		}
		elif(off==treg::c_ecx)
		{
			*start|=0x1;
		}
		elif(off==treg::c_edx)
		{
			*start|=0x2;
		}
	}

	static void set_reg_bit_center(int off,uchar* start)
	{
		if(off==treg::c_esp)
		{
			*start|=0x4<<3;
		}
		elif(off==treg::c_ebp)
		{
			*start|=0x5<<3;
		}
		elif(off==treg::c_esi)
		{
			*start|=0x6<<3;
		}
		elif(off==treg::c_edi)
		{
			*start|=0x7<<3;
		}
		elif(off==treg::c_eax)
		{
			*start|=0x0<<3;
		}
		elif(off==treg::c_ebx)
		{
			*start|=0x3<<3;
		}
		elif(off==treg::c_ecx)
		{
			*start|=0x1<<3;
		}
		elif(off==treg::c_edx)
		{
			*start|=0x2<<3;
		}
	}
};
﻿#pragma once

#include "../struct/tbase.h"

//jit函数
struct zjitf
{
	static tsh*& get_psh()
	{
#ifndef _RS
		static tsh* g_psh;
		return g_psh;
#endif
	}

	static void addl(int64* a,int64* b)
	{
		*a+=*b;
	}

	static void subl(int64* a,int64* b)
	{
		*a-=*b;
	}

	static void imull(int64* a,int64* b)
	{
		*a*=*b;
	}

	static void idivl(int64* a,int64* b)
	{
		*a/=*b;
	}

	static void imodl(int64* a,int64* b)
	{
		*a%=*b;
	}

	static rbool cgsbl(int64* a,int64* b)
	{
		return *a>*b;
	}

	static rbool clsbl(int64* a,int64* b)
	{
		return *a<*b;
	}

	static void faddl(double* a,double* b)
	{
		*a+=*b;
	}

	static void fsubl(double* a,double* b)
	{
		*a-=*b;
	}

	static void fmull(double* a,double* b)
	{
		*a*=*b;
	}

	static void fdivl(double* a,double* b)
	{
		*a/=*b;
	}

	static rbool fcgsbl(double* a,double* b)
	{
		return *a>*b;
	}

	static rbool fclsbl(double* a,double* b)
	{
		return *a<*b;
	}

	static uint bshl(uint a,uint b)
	{
		return a<<b; 
	}

	static uint bshr(uint a,uint b)
	{
		return a>>b; 
	}

	static int bsar(int a,int b)
	{
		return a>>b; 
	}

	static void _float_to_double(float a,double* b)
	{
		*b=a;
	}

	//当返回double时X86的ABI是通过xmm返回
	static void sin(double a,double* b)
	{
		*b=::sin(a);
	}

	static void cos(double a,double* b)
	{
		*b=::cos(a);
	}

	static void sqrt(double a,double* b)
	{
		*b=::sqrt(a);
	}

	static void* get_hins()
	{
		return get_psh()->m_hins;
	}

	static void set_main_ret(int a)
	{
		get_psh()->m_ret=a;
	}

	static tfunc* get_cur_func(uchar* pasm)
	{
		taddr* p=get_psh()->m_addr.find(taddr((uint)pasm,(uint)pasm+1,null));
		if(p==null)
		{
			return null;
		}
		return p->ptfi;
	}

	static rset<tclass>* get_vclass()
	{
		return &get_psh()->m_class;
	}

	static void* find_dll_q(const char* name)
	{
		tsh& sh=*get_psh();
		if(sh.m_dll_func.exist(name))
		{
			return sh.m_dll_func[name];
		}
		if(sh.m_func_list.exist(name))
		{
			return sh.m_func_list[name];
		}
		return find_dll_full(name);
	}

	static void* find_dll_full(const char* name)
	{
		return null;
	}

	static void init_addr_list(tsh& sh)
	{
#ifndef _RS
		rsjf("addl",zjitf::addl);
		rsjf("subl",zjitf::subl);
		rsjf("imull",zjitf::imull);
		rsjf("idivl",zjitf::idivl);
		rsjf("imodl",zjitf::imodl);
		rsjf("cgsbl",zjitf::cgsbl);
		rsjf("clsbl",zjitf::clsbl);
		rsjf("faddl",zjitf::faddl);
		rsjf("fsubl",zjitf::fsubl);
		rsjf("fmull",zjitf::fmull);
		rsjf("fdivl",zjitf::fdivl);
		rsjf("fcgsbl",zjitf::fcgsbl);
		rsjf("fclsbl",zjitf::fclsbl);

		rsjf("bshl",zjitf::bshl);
		rsjf("bshr",zjitf::bshr);
		rsjf("bsar",zjitf::bsar);

		rsjf("printf",xf::printf);
		rsjf("_vsnprintf",xf::vsnprintf);
		rsjf("sscanf",xf::sscanf);
		rsjf("sprintf",xf::sprintf);
		rsjf("sprintf64",xf::sprintf64);
		rsjf("int64toa",xf::int64toa);
		rsjf("atoint64",xf::atoint64);
		rsjf("exit",xf::exit);
		rsjf("malloc",xf::malloc);
		rsjf("free",xf::free);
		rsjf("memcpy",xf::memcpy);
		rsjf("strlen",xf::strlen);
		rsjf("system",xf::cmd);

		rsjf("ftell",xf::ftell);
		rsjf("fseek",xf::fseek);
		rsjf("_wfopen",xf::_wfopen);
		rsjf("fclose",xf::fclose);
		rsjf("fread",xf::fread);
		rsjf("fwrite",xf::fwrite);
		rsjf("_wremove",xf::_wremove);

		rsjf("GetCommandLineA",xf::GetCommandLineA);
		rsjf("_FindFirstFileW",xf::FindFirstFileW);
		rsjf("_FindNextFileW",xf::FindNextFileW);
		rsjf("_FindClose",xf::FindClose);
		rsjf("GetTickCount",xf::tick);
		rsjf("_getch",xf::getch);
		rsjf("MultiByteToWideChar",xf::MultiByteToWideChar);
		rsjf("Sleep",xf::sleep);
#endif
	}
};
﻿#pragma once

#include "zjitb.h"

//jit指令类
struct zjiti
{
	static rstr b_call(const tins& ins,uchar* start)
	{
		if(ins.first.type==topnd::c_imme)
		{
			return zjitb::build_relative(ins,start,0xe8);
		}
		elif(ins.first.type==topnd::c_reg)
		{
			return zjitb::build_r(ins,0xff,0xd0);
		}
		elif(ins.first.type==topnd::c_addr)
		{
			return zjitb::build_a(ins,0xff,0x90);
		}
		return rstr();
	}

	static rstr b_retn()
	{
		return zjitb::build_one(0xc3);
	}

	static rstr b_reti(const tins& ins)
	{
		rstr s;
		s.set_size(3);
		s[0]=0xc2;
		if(ins.first.val>65535)
		{
			return rstr();
		}
		*(ushort*)(&s[1])=(ushort)(ins.first.val);//只有16位的reti，截断
		return r_move(s);
	}

	static rstr b_push(const tins& ins)
	{
		if(ins.first.type==topnd::c_imme)
		{
			return zjitb::build_i(ins,0x68);
		}
		elif(ins.first.type==topnd::c_reg)
		{
			return zjitb::build_r(ins,0x50);
		}
		elif(ins.first.type==topnd::c_addr)
		{
			return zjitb::build_a(ins,0xff,0xb0);
		}
		return rstr();
	}

	static rstr b_pop(const tins& ins)
	{
		if(ins.first.type==topnd::c_reg)
		{
			return zjitb::build_r(ins,0x58);
		}
		return rstr();
	}

	static rstr b_jmp(const tins& ins,uchar* start)
	{
		if(ins.first.type==topnd::c_imme)
		{
			return zjitb::build_relative(ins,start,0xe9);
		}
		elif(ins.first.type==topnd::c_reg)
		{
			return zjitb::build_r(ins,0xff,0xe0);
		}
		elif(ins.first.type==topnd::c_addr)
		{
			return zjitb::build_a(ins,0xff,0xa0);
		}
		return rstr();
	}

	static rstr b_jz(const tins& ins,uchar* start)
	{
		if(ins.first.type==topnd::c_imme)
		{
			return zjitb::build_relative(ins,start,0x0f,0x84);
		}
		return rstr();
	}

	static rstr b_jnz(const tins& ins,uchar* start)
	{
		if(ins.first.type==topnd::c_imme)
		{
			return zjitb::build_relative(ins,start,0x0f,0x85);
		}
		return rstr();
	}

	static rstr b_nop()
	{
		return zjitb::build_one(0x90);
	}

	static rstr b_lea(const tins& ins)
	{
		if(ins.first.type==topnd::c_reg&&ins.second.type==topnd::c_addr)
		{
			return zjitb::build_ra(ins,0x8d,0x80);
		}
		return rstr();
	}

	static rstr b_mov(const tins& ins)
	{
		if(ins.first.type==topnd::c_reg)
		{
			if(ins.second.type==topnd::c_imme)
			{
				return zjitb::build_ri(ins,0xb8);
			}
			elif(ins.second.type==topnd::c_reg)
			{
				return zjitb::build_rr(ins,0x8b,0xc0);
			}
			elif(ins.second.type==topnd::c_addr)
			{
				return zjitb::build_ra(ins,0x8b,0x80);
			}
		}
		elif(ins.first.type==topnd::c_addr)
		{
			if(ins.second.type==topnd::c_imme)
			{
				return zjitb::build_ai(ins,0xc7,0x80);
			}
			elif(ins.second.type==topnd::c_reg)
			{
				return zjitb::build_ar(ins,0x89,0x80);
			}
		}
		return rstr();
	}

	static rstr b_movb_cl_addr(const tins& ins)
	{
		rstr s;
		if(ins.second.off==treg::c_esp)
		{
			s.set_size(7);
		}
		else
		{
			s.set_size(6);
		}
		s[0]=0x8a;
		s[1]=0x88;
		zjitb::set_addr_bit(ins.second.off,&s[1],ins.second.val);
		return r_move(s);
	}

	static rstr b_movb_addr_cl(const tins& ins)
	{
		rstr s;
		if(ins.first.off==treg::c_esp)
		{
			s.set_size(7);
		}
		else
		{
			s.set_size(6);
		}
		s[0]=0x88;
		s[1]=0x88;
		zjitb::set_addr_bit(ins.first.off,&s[1],ins.first.val);
		return r_move(s);
	}

	static rstr b_add(const tins& ins)
	{
		if(ins.first.type==topnd::c_reg)
		{
			if(ins.second.type==topnd::c_imme)
			{
				return zjitb::build_ri(ins,0x81,0xc0);
			}
			if(ins.second.type==topnd::c_reg)
			{
				return zjitb::build_rr(ins,0x03,0xc0);
			}
			if(ins.second.type==topnd::c_addr)
			{
				return zjitb::build_ra(ins,0x03,0x80);
			}
		}
		if(ins.first.type==topnd::c_addr)
		{
			if(ins.second.type==topnd::c_imme)
			{
				return zjitb::build_ai(ins,0x81,0x80);
			}
			if(ins.second.type==topnd::c_reg)
			{
				return zjitb::build_ar(ins,0x01,0x80);
			}
		}
		return rstr();
	}

	static rstr b_sub(const tins& ins)
	{
		if(ins.first.type==topnd::c_reg)
		{
			if(ins.second.type==topnd::c_imme)
			{
				return zjitb::build_ri(ins,0x81,0xe8);
			}
			if(ins.second.type==topnd::c_reg)
			{
				return zjitb::build_rr(ins,0x2b,0xc0);
			}
			if(ins.second.type==topnd::c_addr)
			{
				return zjitb::build_ra(ins,0x2b,0x80);
			}
		}
		if(ins.first.type==topnd::c_addr)
		{
			if(ins.second.type==topnd::c_imme)
			{
				return zjitb::build_ai(ins,0x81,0xa8);
			}
			if(ins.second.type==topnd::c_reg)
			{
				return zjitb::build_ar(ins,0x29,0x80);
			}
		}
		return rstr();
	}

	static rstr b_imul(const tins& ins)
	{
		if(ins.first.type==topnd::c_reg&&ins.second.type==topnd::c_addr)
		{
			return zjitb::build_ra(ins,0x0f,0xaf,0x80);
		}
		return rstr();
	}

	static rstr b_idiv(const tins& ins)
	{
		if(ins.first.type==topnd::c_reg)
		{
			return zjitb::build_r(ins,0xf7,0xf8);
		}
		return rstr();
	}

	static rstr b_udiv(const tins& ins)
	{
		if(ins.first.type==topnd::c_reg)
		{
			return zjitb::build_r(ins,0xf7,0xf0);
		}
		return rstr();
	}

	static rstr b_cdq()
	{
		return zjitb::build_one(0x99);
	}

	static rstr b_sete_bl()
	{
		return zjitb::build_three(0x0f,0x94,0xc3);
	}

	static rstr b_setne_bl()
	{
		return zjitb::build_three(0x0f,0x95,0xc3);
	}

	static rstr b_setg_bl()
	{
		return zjitb::build_three(0x0f,0x9f,0xc3);
	}

	static rstr b_setge_bl()
	{
		return zjitb::build_three(0x0f,0x9d,0xc3);
	}

	static rstr b_setl_bl()
	{
		return zjitb::build_three(0x0f,0x9c,0xc3);
	}

	static rstr b_setle_bl()
	{
		return zjitb::build_three(0x0f,0x9e,0xc3);
	}

	static rstr b_seta_bl()
	{
		return zjitb::build_three(0x0f,0x97,0xc3);
	}

	static rstr b_setae_bl()
	{
		return zjitb::build_three(0x0f,0x93,0xc3);
	}

	static rstr b_setb_bl()
	{
		return zjitb::build_three(0x0f,0x92,0xc3);
	}

	static rstr b_setbe_bl()
	{
		return zjitb::build_three(0x0f,0x96,0xc3);
	}

	static rstr b_cmp(const tins& ins)
	{
		if(ins.first.type==topnd::c_reg)
		{
			if(ins.second.type==topnd::c_imme)
			{
				return zjitb::build_ri(ins,0x81,0xf8);
			}
			if(ins.second.type==topnd::c_reg)
			{
				return zjitb::build_rr(ins,0x3b,0xc0);
			}
			if(ins.second.type==topnd::c_addr)
			{
				return zjitb::build_ra(ins,0x3b,0x80);
			}
		}
		if(ins.first.type==topnd::c_addr)
		{
			if(ins.second.type==topnd::c_imme)
			{
				return zjitb::build_ai(ins,0x81,0xb8);
			}
			if(ins.second.type==topnd::c_reg)
			{
				return zjitb::build_ar(ins,0x39,0x80);
			}
		}
		return rstr();
	}

	static rstr b_and(const tins& ins)
	{
		if(ins.first.type==topnd::c_reg)
		{
			if(ins.second.type==topnd::c_imme)
			{
				return zjitb::build_ri(ins,0x81,0xe0);
			}
			if(ins.second.type==topnd::c_reg)
			{
				return zjitb::build_rr(ins,0x23,0xc0);
			}
			if(ins.second.type==topnd::c_addr)
			{
				return zjitb::build_ra(ins,0x23,0x80);
			}
		}
		if(ins.first.type==topnd::c_addr)
		{
			if(ins.second.type==topnd::c_imme)
			{
				return zjitb::build_ai(ins,0x81,0xa0);
			}
			if(ins.second.type==topnd::c_reg)
			{
				return zjitb::build_ar(ins,0x21,0x80);
			}
		}
		return rstr();
	}

	static rstr b_or(const tins& ins)
	{
		if(ins.first.type==topnd::c_reg)
		{
			if(ins.second.type==topnd::c_imme)
			{
				return zjitb::build_ri(ins,0x81,0xc8);
			}
			if(ins.second.type==topnd::c_reg)
			{
				return zjitb::build_rr(ins,0x0b,0xc0);
			}
			if(ins.second.type==topnd::c_addr)
			{
				return zjitb::build_ra(ins,0x0b,0x80);
			}
		}
		if(ins.first.type==topnd::c_addr)
		{
			if(ins.second.type==topnd::c_imme)
			{
				return zjitb::build_ai(ins,0x81,0x88);
			}
			if(ins.second.type==topnd::c_reg)
			{
				return zjitb::build_ar(ins,0x09,0x80);
			}
		}
		return rstr();
	}

	static rstr b_xor(const tins& ins)
	{
		if(ins.first.type==topnd::c_reg)
		{
			if(ins.second.type==topnd::c_imme)
			{
				return zjitb::build_ri(ins,0x81,0xf0);
			}
			if(ins.second.type==topnd::c_reg)
			{
				return zjitb::build_rr(ins,0x33,0xc0);
			}
			if(ins.second.type==topnd::c_addr)
			{
				return zjitb::build_ra(ins,0x33,0x80);
			}
		}
		if(ins.first.type==topnd::c_addr)
		{
			if(ins.second.type==topnd::c_imme)
			{
				return zjitb::build_ai(ins,0x81,0xb0);
			}
			if(ins.second.type==topnd::c_reg)
			{
				return zjitb::build_ar(ins,0x31,0x80);
			}
		}
		return rstr();
	}

	static rstr b_not(const tins& ins)
	{
		if(ins.first.type==topnd::c_reg)
		{
			return zjitb::build_r(ins,0xf7,0xd0);
		}
		elif(ins.first.type==topnd::c_addr)
		{
			return zjitb::build_a(ins,0xf7,0x90);
		}
		return rstr();
	}

	static rstr b_shl_eax_cl()
	{
		return zjitb::build_two(0xd3,0xe0);
	}

	static rstr b_shr_eax_cl()
	{
		return zjitb::build_two(0xd3,0xe8);
	}

	static rstr b_sar_eax_cl()
	{
		return zjitb::build_two(0xd3,0xf8);
	}
};
﻿#pragma once

#ifndef _RS
#include "../xlib/xsock.h"
#endif
#include "../front/yclass.h"
#include "../front/yformat.h"
#include "zvm.h"
#include "zjit.h"
#include "zgpp.h"

//main函数进行参数解析
struct zmain
{
	static rbool compile(uchar* cont)
	{
		tsh sh;
		sh.m_main_cont=cont;
		rbuf<rstr> vparam=rf::get_param();
		if(vparam.count()<2)
		{
			return false;
		}
		sh.m_vdefine.insert_c(tmac(rstr("_RS")));
		if(vparam[1]=="-jit")
		{
			sh.m_mode=tsh::c_jit;
			sh.m_vdefine.insert_c(tmac(rstr("_RJIT")));
		}
		elif(vparam[1]=="-gpp")
		{
			sh.m_mode=tsh::c_gpp;
			sh.m_vdefine.insert_c(tmac(rstr("_RGPP")));
		}
		elif(vparam[1]=="-gpp64")
		{
			sh.m_point_size=8;
			sh.m_mode=tsh::c_gpp;
			sh.m_vdefine.insert_c(tmac(rstr("_RGPP")));
		}
		elif(vparam[1]=="-nasm")
		{
			sh.m_mode=tsh::c_nasm;
			sh.m_vdefine.insert_c(tmac(rstr("_RNASM")));
		}
		else
		{
			sh.m_vdefine.insert_c(tmac(rstr("_RVM")));
		}
		rstr name;
		for(int i=1;i<vparam.count();i++)
		{
			if(vparam[i].get_left()!=r_char('-'))
			{
				name=vparam[i];
				break;
			}
		}
		if(name.get_left()==r_char('\"'))
		{
			name=ybase::del_quote(name);
		}
		name=rcode::gbk_to_utf8(name);
		name=rdir::dir_std(name);
		name=ypre::get_abs_path(name);
		sh.m_main_file=name;
		ybase::init_path(sh.m_path);
		ybase::init_match(sh.m_match);
		ifn(ypre::process(sh))
		{
			rserror("pre process error");
			return false;
		}
		ifn(yformat::process(sh))
		{
			rserror("format error");
			return false;
		}
		ifn(yclass::process(sh))
		{
			rserror("extract class error");
			return false;
		}
		ifn(yclasstl::process(sh))
		{
			rserror("class template replace error");
			return false;
		}
		ifn(ymemb::process(sh))
		{
			rserror("ymemb error");
			return false;
		}
		if(sh.m_mode==tsh::c_vm)
		{
			tfunc* ptfi=yfind::func_search(*sh.m_main,"main");
			if(ptfi==null)
			{
				rf::printl("main not find");
				return false;
			}
			zjitf::init_addr_list(sh);
			ifn(zbin::process(sh,*ptfi))
			{
				return false;
			}
			ifn(zvm::run(sh))
			{
				return false;
			}
		}
		elif(sh.m_mode==tsh::c_jit)
		{
			zjitf::init_addr_list(sh);
			ifn(zjit::run(sh))
			{
				return false;
			}
		}
		elif(sh.m_mode==tsh::c_nasm)
		{
			ifn(znasm::process(sh))
			{
				return false;
			}
		}
		elif(sh.m_mode==tsh::c_gpp)
		{
			ifn(zgpp::process(sh))
			{
				return false;
			}
		}
		return true;
	}
};

//todo C++不支持mixin，只能这么写
rbool r_func_to_x86(tsh& sh,tfunc& tfi,tenv env)
{
	return zjit::func_to_x86(sh,tfi,env);
}
﻿#pragma once

#include "zbin.h"

struct znasm
{
	static rbool process(tsh& sh)
	{
		tfunc* ptfi=yfind::func_search(*sh.m_main,"main");
		if(ptfi==null)
		{
			rf::printl("main not find");
			return false;
		}
		rstr result;
		rbuf<rstr> vconst;
		rset<rstr> scall;
		ifn(proc_func(sh,*ptfi,result,vconst,scall))
		{
			return false;
		}
		rstr head;
		head+=("%include '"+rcode::utf8_to_gbk(
			ybase::get_rs_dir())+"ext/nasm/windemos.inc'\n");
		for(rstr* p=scall.begin();p!=scall.end();p=scall.next(p))
		{
			ifn(is_ex_func(sh,*p))
			{
				head+="IMPORT "+*p+"\n";
			}
		}
		//head+="IMPORT _getch\n"; nasm的一个bug?
		head+="entry demo11\n";
		head+="\n";
		head+="[section .bss]\n";
		head+="align 32\n";
		head+="resb 4\n";
		head+=rstr("_PMAIN_A: resb ")+sh.m_main_data.size()+"\n";
		add_lambda(sh,head);
		head+="\n";
		head+="[section .data]\n";
		head+="align 32\n";
		head+="db 0,0,0,0\n";//防止数据段为空
		add_str(sh,head,vconst);
		
		head+="\n";
		head+="[section .text]\n";
		head+="proc demo11, ptrdiff_t argcount, ptrdiff_t cmdline\n";
		head+="locals none\n";
		head+="	sub esp , 4\n";
		head+="	call main2Emain2829\n";
		head+="	add esp , 4\n";
		head+="	xor eax , eax\n";
		head+="endproc\n";
		head+="proc _rs_main\n";
		head+="locals none\n";
	
		head+=result;
		head+="\n";
		head+="endproc\n";
		head+="\n";

		head+=("%include '"+rcode::utf8_to_gbk(
			ybase::get_rs_dir())+"ext/nasm/exfunc.inc'\n");

		rstr name=ybase::get_main_name(sh)+".asm";
		rfile file;
		ifn(file.open_n(name,"rw"))
		{
			rf::printl("file open error");
			return false;
		}
		ifn(file.write(head.size(),head.begin()))
		{
			rf::printl("file write error");
			return false;
		}
		return true;
	}

	static rbool is_ex_func(tsh& sh,const rstr& s)
	{
		return (s==rskey(c_bshl)||s==rskey(c_bshr)||s==rskey(c_bsar)||
			s=="faddl"||s=="fsubl"||s=="fmull"||s=="fdivl"||s=="fclsbl"||
			s=="addl"||s=="subl");
	}

	static void add_str(tsh& sh,rstr& result,rbuf<rstr>& vconst)
	{
		for(int i=0;i<vconst.count();i++)
		{
			zbin::trans_cstr(vconst[i]);
			add_str_one(result,i,vconst[i]);
		}
	}

	static void add_str_one(rstr& result,int index,const rstr& s)
	{
		result+="_RC_"+rstr(index)+": db ";
		for(int i=0;i<s.count()-1;i++)
		{
			result+=rstr((int)(s[i]))+",";
		}
		result+="0\n";
	}

	static void add_lambda(tsh& sh,rstr& result)
	{
		for(tclass* p=sh.m_class.begin();
			p!=sh.m_class.end();p=sh.m_class.next(p))
		{
			add_lambda(result,*p);
		}
	}

	static void add_lambda(rstr& result,tclass& tci)
	{
		for(tfunc* p=tci.vfunc.begin();p!=tci.vfunc.end();p=tci.vfunc.next(p))
		{
			if(p->lambda_data.empty())
			{
				continue;
			}
			result+=p->name+"_C_P_A: resb "+p->lambda_data.size()+"\n";
		}
	}

	static tfunc* call_find(tsh& sh,tasm& item)
	{
		int i;
		for(i=1;i<item.vstr.count();i++)
		{
			if(item.vstr[i]=="&")
			{
				break;
			}
		}
		//一条指令里最多出现一次&,而且 &操作数 只能是最后一个操作数
		if(i>=item.vstr.count())
		{
			return null;
		}
		i+=2;
		tclass* ptci=yfind::class_search(sh,item.vstr.get(i));
		if(ptci==null)
		{
			return null;
		}
		i+=2;
		rstr fname=item.vstr.get(i);
		return yfind::func_search_dec(*ptci,fname);
	}

	static rstr symbol_trans(const rstr& s)
	{
		rstr ret;
		for(int i=0;i<s.count();i++)
		{
			if(rstr::is_alpha(s[i])||rstr::is_number(s[i])||s[i]==r_char('_'))
			{
				ret+=s[i];
			}
			else
			{
				ret+=rstr::format("%02X",(int)(s[i]));
			}
		}
		return r_move(ret);
	}

	static rstr get_nasm_symbol(tfunc& tfi)
	{
		return symbol_trans(tfi.ptci->name+"."+tfi.name_dec);
	}

	static rbool is_jmp_ins_nasm(const rstr& s)
	{
		return (s=="call"||s=="je"||s=="jne"||s=="jg"||s=="jge"||
			s=="jl"||s=="jle"||s=="ja"||s=="jae"||s=="jb"||s=="jbe");
	}

	//将一个函数翻译成NASM汇编代码
	static rbool proc_func(tsh& sh,tfunc& tfi,rstr& result,
		rbuf<rstr>& vconst,rset<rstr>& scall,int level=0)
	{
		if(level>300)
		{
			rserror(tfi,"nasm level overflow");
			return false;
		}
		level++;
		if(tfi.count==1)
		{
			return true;
		}
		tfi.count=1;
		if(tfi.vasm.empty())
		{
			if(!zbin::cp_vword_to_vasm(sh,tfi,tenv()))
			{
				return false;
			}
		}
		rstr symbol=get_nasm_symbol(tfi);
		result+="\n"+symbol+":\n";
		for(int i=0;i<tfi.vasm.count();i++)
		{
			if(ybase::is_tag<rstr>(tfi.vasm[i].vstr))
			{
				//todo:_func_end标号有时不是必须的
				result+=symbol+"_"+tfi.vasm[i].vstr[0];
				result+=tfi.vasm[i].vstr[1];
				result+="\n";
				continue;
			}
			rstr s;
			ifn(proc_asm(sh,tfi,tfi.vasm[i],s,vconst,scall))
			{
				rserror(tfi.vasm[i]);
				rserror(tfi);
				return false;
			}
			result+=s;
		}
		for(int i=0;i<tfi.vasm.count();i++)
		{
			tfunc* ptfi=call_find(sh,tfi.vasm[i]);
			if(ptfi==null)
			{
				continue;
			}
			ifn(proc_func(sh,*ptfi,result,vconst,scall,level))
			{
				return false;
			}
		}
		return true;
	}

	static void proc_const_str(rbuf<rstr>& vstr,rbuf<rstr>& vconst)
	{
		if(vstr.count()>=2&&vstr[0]=="calle")
		{
			return;
		}
		for(int i=0;i<vstr.count();i++)
		{
			if(vstr[i].get_bottom()==r_char('\"')&&vstr[i].count()>=2)
			{
				vconst.push(vstr[i]);
				vstr[i]="_RC_"+rstr(vconst.count()-1);
			}
		}
	}

	static rbool have_single_esp(tsh& sh,tasm& item)
	{
		for(int i=0;i<item.vstr.count();i++)
		{
			if(item.vstr[i]==rskey(c_esp)||item.vstr[i]==rskey(c_ebp))
			{
				if(item.vstr.get(i-1)!=rsoptr(c_mbk_l))
				{
					return true;
				}
				if(item.vstr.get(i+2).toint()<4)
				{
					return true;
				}
				if(item.vstr.get(i+1)!=rsoptr(c_plus))
				{
					return true;
				}
			}
			if(item.vstr[i].get_bottom()==r_char('\"')&&item.vstr[i].count()>=2)
			{
				return true;
			}
		}
		return false;
	}

	static void fix_esp(tsh& sh,tasm& item)
	{
		for(int i=0;i<item.vstr.count();i++)
		{
			if(item.vstr[i]!=rskey(c_esp)&&item.vstr[i]!=rskey(c_ebp))
			{
				continue;
			}
			if(item.vstr.count()>i+2&&item.vstr[i+2].is_number())
			{
				item.vstr[i+2]=item.vstr[i+2].toint()-4;
			}
		}
	}

	static rbool proc_asm(tsh& sh,tfunc& tfi,tasm& item,
		rstr& result,rbuf<rstr>& vconst,rset<rstr>& scall)
	{
		rbuf<rstr>& vstr=item.vstr;
		proc_const_str(vstr,vconst);
		if(vstr.empty())
		{
			return false;
		}
		int type=sh.m_key.get_key_index(vstr[0]);
		tfunc* ptfi;
		switch(type)
		{
		case tkey::c_calle:
			if(ybase::del_quote(vstr.get(1))!="printf")//todo:
			{
				scall.insert_c(ybase::del_quote(vstr.get(1)));
			}
			result+="	invoke "+ybase::del_quote(vstr.get(1))+"\n";
			return true;
		case tkey::c_call:
			ptfi=call_find(sh,item);
			if(ptfi==null)
			{
				result+=("	call dword "+
					link_vstr(vstr.sub(1))+"\n");
				return true;
			}
			result+="	call "+get_nasm_symbol(*ptfi)+"\n";
			return true;
		case tkey::c_retn:
			result+="	ret\n";
			return true;
		case tkey::c_reti:
			result+="	ret "+vstr.get(1)+"\n";
			return true;
		case tkey::c_push:
			ptfi=call_find(sh,item);
			if(ptfi==null)
			{
				result+="	push dword "+link_vstr(vstr.sub(1))+"\n";
			}
			else
			{
				result+="	push "+get_nasm_symbol(*ptfi)+"\n";
			}
			return true;
		case tkey::c_pop:
			result+="	pop dword "+link_vstr(vstr.sub(1))+"\n";
			return true;
		case tkey::c_jmp:
			result+="	jmp "+get_nasm_symbol(tfi)+"_"+vstr.get(1)+"\n";
			return true;
		case tkey::c_jebxz:
			result+="	cmp ebx , 0\n";
			result+="	jz "+get_nasm_symbol(tfi)+"_"+vstr.get(1)+"\n";
			return true;
		case tkey::c_jebxnz:
			result+="	cmp ebx , 0\n";
			result+="	jnz "+get_nasm_symbol(tfi)+"_"+vstr.get(1)+"\n";
			return true;
		case tkey::c_nop:
			result+="	nop\n";
			return true;
		case tkey::c_lea:
			if(count_mbk_l(vstr)==2)
			{
				result+="	lea ecx , "+get_opnd2(vstr)+"\n";
				result+="	mov "+get_opnd1(vstr)+" , ecx\n";
			}
			else
			{
				result+="	lea dword "+link_vstr(vstr.sub(1))+"\n";
			}
			return true;
		case tkey::c_mov:
			if(count_mbk_l(vstr)==2)
			{
				result+="	mov ecx , "+get_opnd2(vstr)+"\n";
				result+="	mov "+get_opnd1(vstr)+" , ecx\n";
				return true;
			}
			ptfi=call_find(sh,item);
			if(ptfi==null)
			{
				result+="	mov dword "+link_vstr(vstr.sub(1))+"\n";
			}
			else
			{
				result+=("	mov dword "+get_opnd1(vstr)+" , "+
					get_nasm_symbol(*ptfi)+"\n");
			}
			return true;
		case tkey::c_movb:
			result+="	mov cl , "+get_opnd2(vstr)+"\n";
			result+="	mov "+get_opnd1(vstr)+" , cl\n";
			return true;
		case tkey::c_movl:
			return false;
		case tkey::c_add:
			if(count_mbk_l(vstr)==2)
			{
				result+="	mov ecx , "+get_opnd2(vstr)+"\n";
				result+="	add "+get_opnd1(vstr)+" , ecx\n";
			}
			else
			{
				result+=("	add dword "+
					link_vstr(vstr.sub(1))+"\n");
			}
			return true;
		case tkey::c_sub:
			if(count_mbk_l(vstr)==2)
			{
				result+="	mov ecx , "+get_opnd2(vstr)+"\n";
				result+="	sub "+get_opnd1(vstr)+" , ecx\n";
			}
			else
			{
				result+="	sub dword "+link_vstr(vstr.sub(1))+"\n";
			}
			return true;
		case tkey::c_imul:
			result+="	mov ecx , "+get_opnd1(vstr)+"\n";
			result+="	imul ecx , "+get_opnd2(vstr)+"\n";
			result+="	mov "+get_opnd1(vstr)+" , ecx\n";
			return true;
		case tkey::c_idiv:
			result+="	mov eax , "+get_opnd1(vstr)+"\n";
			result+="	cdq\n";
			result+="	mov ecx , "+get_opnd2(vstr)+"\n";
			result+="	idiv ecx\n";
			result+="	mov "+get_opnd1(vstr)+" , eax\n";
			return true;
		case tkey::c_imod:
			result+="	mov eax , "+get_opnd1(vstr)+"\n";
			result+="	cdq\n";
			result+="	mov ecx , "+get_opnd2(vstr)+"\n";
			result+="	idiv ecx\n";
			result+="	mov "+get_opnd1(vstr)+" , edx\n";
			return true;
		case tkey::c_cesb:
			return ncmp(result,vstr,"	sete bl\n");
		case tkey::c_cnesb:
			return ncmp(result,vstr,"	setne bl\n");
		case tkey::c_cgsb:
			return ncmp(result,vstr,"	setg bl\n");
		case tkey::c_cgesb:
			return ncmp(result,vstr,"	setge bl\n");
		case tkey::c_clsb:
			return ncmp(result,vstr,"	setl bl\n");
		case tkey::c_clesb:
			return ncmp(result,vstr,"	setle bl\n");
		case tkey::c_band:
			if(count_mbk_l(vstr)==2)
			{
				result+="	mov ecx , "+get_opnd2(vstr)+"\n";
				result+="	and "+get_opnd1(vstr)+" , ecx\n";
			}
			else
			{
				result+="	and dword "+link_vstr(vstr.sub(1))+"\n";
			}
			return true;
		case tkey::c_bor:
			if(count_mbk_l(vstr)==2)
			{
				result+="	mov ecx , "+get_opnd2(vstr)+"\n";
				result+="	or "+get_opnd1(vstr)+" , ecx\n";
			}
			else
			{
				result+="	or dword "+link_vstr(vstr.sub(1))+"\n";
			}
			return true;
		case tkey::c_bnot:
			result+="	not dword "+link_vstr(vstr.sub(1))+"\n";
			return true;
		case tkey::c_bxor:
			if(count_mbk_l(vstr)==2)
			{
				result+="	mov ecx , "+get_opnd2(vstr)+"\n";
				result+="	xor "+get_opnd1(vstr)+" , ecx\n";
			}
			else
			{
				result+="	xor dword "+link_vstr(vstr.sub(1))+"\n";
			}
			return true;
		case tkey::c_bshl:
			return false;
		case tkey::c_bshr:
			return false;
		case tkey::c_bsar:
			return false;
		case tkey::c_udiv:
			result+="	mov eax , "+get_opnd1(vstr)+"\n";
			result+="	xor edx , edx\n";
			result+="	mov ecx , "+get_opnd2(vstr)+"\n";
			result+="	div ecx\n";
			result+="	mov "+get_opnd1(vstr)+" , eax\n";
			return true;
		case tkey::c_umod:
			result+="	mov eax , "+get_opnd1(vstr)+"\n";
			result+="	xor edx , edx\n";
			result+="	mov ecx , "+get_opnd2(vstr)+"\n";
			result+="	div ecx\n";
			result+="	mov "+get_opnd1(vstr)+" , edx\n";
			return true;
		case tkey::c_ucgsb:
			return ncmp(result,vstr,"	seta bl\n");
		case tkey::c_ucgesb:
			return ncmp(result,vstr,"	setae bl\n");
		case tkey::c_uclsb:
			return ncmp(result,vstr,"	setb bl\n");
		case tkey::c_uclesb:
			return ncmp(result,vstr,"	setbe bl\n");
		case tkey::c_rn:
			if(vstr.count()==3&&
				!sh.m_key.is_asm_reg(vstr[2])&&
				is_jmp_ins_nasm(vstr[1]))
			{
				result+=("	"+vstr[1]+" "+get_nasm_symbol(tfi)+"_"+
					vstr.top()+"\n");
			}
			else
			{
				result+="	"+link_vstr(vstr.sub(1))+"\n";
			}
			return true;
		}
		return false;
	}

	static rbool ncmp(rstr& result,rbuf<rstr>& vstr,const rstr& cont)
	{
		if(count_mbk_l(vstr)==2)
		{
			result+="	mov ecx , "+get_opnd2(vstr)+"\n";
			result+="	cmp "+get_opnd1(vstr)+" , ecx\n";
		}
		else
		{
			result+="	cmp dword "+link_vstr(vstr.sub(1))+"\n";
		}
		result+="	mov ebx , 0\n";
		result+=cont;
		return true;
	}

	static rstr link_vstr(const rbuf<rstr>& v)
	{
		return rstr::join<rstr>(v," ");
	}

	static rstr get_opnd1(rbuf<rstr>& vstr)
	{
		return link_vstr(get_opnd1_v(vstr));
	}

	static rbuf<rstr> get_opnd1_v(rbuf<rstr>& vstr)
	{
		int i;
		int count=0;
		for(i=1;i<vstr.count();i++)
		{
			if("("==vstr[i])
			{
				count++;
			}
			elif(")"==vstr[i])
			{
				count--;
			}
			elif(count==0&&vstr[i]==",")
			{
				break;
			}
		}
		return vstr.sub(1,i);
	}

	static rstr get_opnd2(rbuf<rstr>& vstr)
	{
		return link_vstr(get_opnd2_v(vstr));
	}
	
	//todo: merge to get_opnd1_v
	static rbuf<rstr> get_opnd2_v(rbuf<rstr>& vstr)
	{
		int i;
		int count=0;
		for(i=1;i<vstr.count();i++)
		{
			if("("==vstr[i])
			{
				count++;
			}
			elif(")"==vstr[i])
			{
				count--;
			}
			elif(count==0&&vstr[i]==",")
			{
				break;
			}
		}
		return vstr.sub(i+1);
	}

	static int count_mbk_l(rbuf<rstr>& vstr)
	{
		int sum=0;
		for(int i=0;i<vstr.count();i++)
		{
			if(vstr[i]=="[")
			{
				sum++;
			}
		}
		return sum;
	}
};
﻿#pragma once

#include "../struct/tbase.h"

//优化类
struct yopt
{
	static rbool is_add_sub(const tsh& sh,const rstr& s)
	{
		return s==rskey(c_add)||s==rskey(c_sub);
	}

	static rbool is_add_sub(const tsh& sh,const rbuf<rstr>& v)
	{
		return (v.count()==4&&is_add_sub(sh,v[0])&&
			v[2]==rsoptr(c_comma)&&v[3].is_number());
	}

	static rbool op_add_sub(const tsh& sh,rbuf<tasm>& vasm)
	{
		rbuf<tasm> result;
		for(int i=0;i<vasm.count();i++)
		{
			if(is_add_sub(sh,vasm[i].vstr))
			{
				int j;
				for(j=i+1;j<vasm.count();j++)
				{
					if(!is_add_sub(sh,vasm[j].vstr))
					{
						break;
					}
					if(vasm[j].vstr.get(1)!=vasm[i].vstr.get(1))
					{
						break;
					}
				}
				int val=0;
				for(int k=i;k<j;k++)
				{
					if(vasm[k].vstr.get(0)==rskey(c_add))
					{
						val+=vasm[k].vstr.get(3).toint();
					}
					else
					{
						val-=vasm[k].vstr.get(3).toint();
					}
				}
				if(val<0)
				{
					val=-val;
					vasm[i].vstr[0]=rskey(c_sub);
				}
				else
				{
					vasm[i].vstr[0]=rskey(c_add);
				}
				vasm[i].vstr[3]=rstr(val);
				if(val!=0)
				{
					result.push(vasm[i]);
				}
				i=j-1;
			}
			elif(tconf::c_op_nop&&vasm[i].vstr.count()==1&&
				vasm[i].vstr[0]==rskey(c_nop))
			{
				;
			}
			else
			{
				result.push(vasm[i]);
			}
		}
		vasm=r_move(result);
		return true;
	}

	static rbool match(const rbuf<rstr>& item,const rbuf<rstr>& pick)
	{
		if(item.count()!=pick.count())
		{
			return false;
		}
		for(int i=0;i<item.count();i++)
		{
			if(pick[i]=="@@")
			{
				continue;
			}
			if(pick[i]=="@n"&&item[i].is_number())
			{
				continue;
			}
			if(pick[i]!=item[i])
			{
				return false;
			}
		}
		return true;
	}

	static rbool match(const tasm& item,const tasm& pick)
	{
		return match(item.vstr,pick.vstr);
	}

	static rbool replace(const rbuf<tasm>& item,const rbuf<tasm>& pick,rbuf<tasm>& dst)
	{
		rbuf<rstr> vstr;
		for(int i=0;i<pick.count();i++)
		{
			for(int j=0;j<pick[i].vstr.count();j++)
			{
				if(pick[i].vstr[j].get(0)==r_char('@'))
				{
					vstr.push(item[i].vstr[j]);
				}
			}
		}
		for(int i=0;i<dst.count();i++)
		{
			for(int j=0;j<dst[i].vstr.count();j++)
			{
				//@后面的数字暂时只能是1位数
				if(dst[i].vstr[j].get(0)==r_char('@'))
				{
					int num=dst[i].vstr[j].sub(1).toint();
					if(num>=vstr.count())
					{
						return false;
					}
					dst[i].vstr[j]=vstr[num];
				}
			}
		}
		return true;
	}

	static rbool op_match(const tsh& sh,rbuf<tasm>& vasm)
	{
		rbuf<tasm> result;
		for(int i=0;i<vasm.count();i++)
		{
			int j;
			for(j=0;j<sh.m_match.count();j++)
			{
				int len=sh.m_match[j].src.count();
				if(i+len>vasm.count())
				{
					continue;
				}
				int k;
				for(k=i;k<i+len;k++)
				{
					ifn(match(vasm[k],sh.m_match[j].src[k-i]))
					{
						break;
					}
				}
				if(k<i+len)
				{
					continue;
				}
				rbuf<tasm> temp=sh.m_match[j].dst;
				ifn(replace(vasm.sub(i,i+len),sh.m_match[j].src,temp))
				{
					return false;
				}
				result+=r_move(temp);
				i=i+len-1;
				break;
			}
			if(j>=sh.m_match.count())
			{
				result+=vasm[i];
			}
		}
		vasm=r_move(result);
		return true;
	}
};
﻿#pragma once

#include "zbin.h"
#include "zjitf.h"

struct zvm
{
	static void proc_calle(treg& reg,void* func,int num)
	{
		int count=num/4;
		if(num%4)
		{
			if(count==0)
			{
				reg.eax=((int (*)())func)();
			}
			elif(count==1)
			{
				reg.eax=((int (*)(int))func)(v_pto_int(reg.esp));
			}
			elif(count==2)
			{
				reg.eax=((int (*)(int,int))func)(v_pto_int(reg.esp),v_pto_int(reg.esp+4));
			}
			elif(count==3)
			{
				reg.eax=((int (*)(int,int,int))func)(v_pto_int(reg.esp),v_pto_int(reg.esp+4),v_pto_int(reg.esp+8));
			}
			elif(count==4)
			{
				reg.eax=((int (*)(int,int,int,int))func)(v_pto_int(reg.esp),
					v_pto_int(reg.esp+4),v_pto_int(reg.esp+8),v_pto_int(reg.esp+12));
			}
			elif(count==6)
			{
				reg.eax=((int (*)(int,int,int,int,int,int))func)(v_pto_int(reg.esp),
					v_pto_int(reg.esp+4),v_pto_int(reg.esp+8),v_pto_int(reg.esp+12),
					v_pto_int(reg.esp+16),v_pto_int(reg.esp+20));
			}
		}
		else
		{
			if(count==0)
			{
				((void (*)())func)();
			}
			elif(count==1)
			{
				((void (*)(int))func)(v_pto_int(reg.esp));
			}
			elif(count==2)
			{
				((void (*)(int,int))func)(v_pto_int(reg.esp),v_pto_int(reg.esp+4));
			}
			elif(count==3)
			{
				((void (*)(int,int,int))func)(v_pto_int(reg.esp),v_pto_int(reg.esp+4),v_pto_int(reg.esp+8));
			}
			elif(count==4)
			{
				((void (*)(int,int,int,int))func)(v_pto_int(reg.esp),
					v_pto_int(reg.esp+4),v_pto_int(reg.esp+8),v_pto_int(reg.esp+12));
			}
		}
	}

	//为了提高效率将1条指令分解为6条
	static rbool run(tsh& sh)
	{
#ifndef _RS
		rbuf<tasm> init_vasm;
		rbuf<uchar> stack(tconf::c_stack_size);
		treg reg;
		tins* cur;
		ifn(init(sh,stack,reg,init_vasm))
		{
			rserror("init failed");
			return false;
		}
next:
		cur=(tins*)(reg.eip);
		//((tasm*)cur)->vstr.print();
		//rf::printl();
		
		switch(cur->type)
		{
		case tins::c_rjit_n:
		case tins::c_rjit_n+1:
		case tins::c_rjit_n+2:
		case tins::c_rjit_n+3:
		case tins::c_rjit_n+4:
		case tins::c_rjit_n+5:
			return false;

		case tins::c_calle_i:
			proc_calle(reg,(void*)(v_get_imme(cur->first)),v_get_imme(cur->second));
			v_next_ins;
		case tins::c_calle_i+1:
		case tins::c_calle_i+2:
		case tins::c_calle_i+3:
		case tins::c_calle_i+4:
		case tins::c_calle_i+5:
			return false;

		case tins::c_call_i:
			reg.esp-=4;
			v_pto_uint(reg.esp)=reg.eip+r_size(tasm);
			reg.eip=v_get_imme(cur->first);
			goto next;
		case tins::c_call_r:
			reg.esp-=4;
			v_pto_uint(reg.esp)=reg.eip+r_size(tasm);
			reg.eip=v_get_reg(cur->first);
			goto next;
		case tins::c_call_a:
			reg.esp-=4;
			v_pto_uint(reg.esp)=reg.eip+r_size(tasm);
			reg.eip=v_get_addr(cur->first);
			goto next;
		case tins::c_call_a+1:
		case tins::c_call_a+2:
		case tins::c_call_a+3:
			return false;

		case tins::c_ret_n:
			reg.eip=v_pto_uint(reg.esp);
			reg.esp+=4;
			goto next;
		case tins::c_ret_n+1:
		case tins::c_ret_n+2:
		case tins::c_ret_n+3:
		case tins::c_ret_n+4:
		case tins::c_ret_n+5:
			return false;

		case tins::c_ret_i:
			reg.eip=v_pto_uint(reg.esp);
			reg.esp+=4+v_get_imme(cur->first);
			goto next;
		case tins::c_ret_r:
			reg.eip=v_pto_uint(reg.esp);
			reg.esp+=4+v_get_reg(cur->first);
			goto next;
		case tins::c_ret_a:
			reg.eip=v_pto_uint(reg.esp);
			reg.esp+=4;
			reg.esp+=v_get_addr(cur->first);
			goto next;
		case tins::c_ret_a+1:
		case tins::c_ret_a+2:
		case tins::c_ret_a+3:
			return false;

		case tins::c_push_i:
			reg.esp-=4;
			v_pto_uint(reg.esp)=v_get_imme(cur->first);
			v_next_ins;
		case tins::c_push_r:
			reg.esp-=4;
			v_pto_uint(reg.esp)=v_get_reg(cur->first);
			v_next_ins;
		case tins::c_push_a:
			reg.esp-=4;
			v_pto_uint(reg.esp)=v_get_addr(cur->first);
			v_next_ins;
		case tins::c_push_a+1:
		case tins::c_push_a+2:
		case tins::c_push_a+3:
			return false;

		case tins::c_pop_i:
			return false;
		case tins::c_pop_r:
			v_get_reg(cur->first)=v_pto_uint(reg.esp);
			reg.esp+=4;
			v_next_ins;
		case tins::c_pop_a:
			v_get_addr(cur->first)=v_pto_uint(reg.esp);
			reg.esp+=4;
			v_next_ins;
		case tins::c_pop_a+1:
		case tins::c_pop_a+2:
		case tins::c_pop_a+3:
			return false;

		case tins::c_jmp_i:
			reg.eip=v_get_imme(cur->first);
			goto next;
		case tins::c_jmp_r:
			reg.eip=v_get_reg(cur->first);
			goto next;
		case tins::c_jmp_a:
			reg.eip=v_get_addr(cur->first);
			goto next;
		case tins::c_jmp_a+1:
		case tins::c_jmp_a+2:
		case tins::c_jmp_a+3:
			return false;

		case tins::c_jebxz_i:
			if(reg.ebx)
			{
				reg.eip+=r_size(tasm);
			}
			else
			{
				reg.eip=v_get_imme(cur->first);
			}
			goto next;
		case tins::c_jebxz_r:
			if(reg.ebx)
			{
				reg.eip+=r_size(tasm);
			}
			else
			{
				reg.eip=v_get_reg(cur->first);
			}
			goto next;
		case tins::c_jebxz_a:
			if(reg.ebx)
			{
				reg.eip+=r_size(tasm);
			}
			else
			{
				reg.eip=v_get_addr(cur->first);
			}
			goto next;
		case tins::c_jebxz_a+1:
		case tins::c_jebxz_a+2:
		case tins::c_jebxz_a+3:
			return false;

		case tins::c_jebxnz_i:
			if(reg.ebx)
			{
				reg.eip=v_get_imme(cur->first);
			}
			else
			{
				reg.eip+=r_size(tasm);
			}
			goto next;
		case tins::c_jebxnz_r:
			if(reg.ebx)
			{
				reg.eip=v_get_reg(cur->first);
			}
			else
			{
				reg.eip+=r_size(tasm);
			}
			goto next;
		case tins::c_jebxnz_a:
			if(reg.ebx)
			{
				reg.eip=v_get_addr(cur->first);
			}
			else
			{
				reg.eip+=r_size(tasm);
			}
			goto next;
		case tins::c_jebxnz_a+1:
		case tins::c_jebxnz_a+2:
		case tins::c_jebxnz_a+3:
			return false;

		case tins::c_halt_n:
			break;
		case tins::c_halt_n+1:
		case tins::c_halt_n+2:
		case tins::c_halt_n+3:
		case tins::c_halt_n+4:
		case tins::c_halt_n+5:
			return false;

		case tins::c_nop_n:
			v_next_ins;
		case tins::c_nop_n+1:
		case tins::c_nop_n+2:
		case tins::c_nop_n+3:
		case tins::c_nop_n+4:
		case tins::c_nop_n+5:
			return false;

		case tins::c_lea_ri:
			return false;
		case tins::c_lea_ai:
			return false;
		case tins::c_lea_rr:
			return false;
		case tins::c_lea_ar:
			return false;
		case tins::c_lea_ra:
			v_get_reg(cur->first)=v_get_lea(cur->second);
			v_next_ins;
		case tins::c_lea_aa:
			v_get_addr(cur->first)=v_get_lea(cur->second);
			v_next_ins;

		case tins::c_mov_ri:
			v_get_reg(cur->first)=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_mov_ai:
			v_get_addr(cur->first)=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_mov_rr:
			v_get_reg(cur->first)=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_mov_ar:
			v_get_addr(cur->first)=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_mov_ra:
			v_get_reg(cur->first)=v_get_addr(cur->second);
			v_next_ins;
		case tins::c_mov_aa:
			v_get_addr(cur->first)=v_get_addr(cur->second);
			v_next_ins;

		case tins::c_movb_ri:
		case tins::c_movb_ai:
		case tins::c_movb_rr:
		case tins::c_movb_ar:
		case tins::c_movb_ra:
			return false;
		case tins::c_movb_aa:
			v_get_addr_8(cur->first)=v_get_addr_8(cur->second);
			v_next_ins;

		case tins::c_movl_ri:
		case tins::c_movl_ai:
		case tins::c_movl_rr:
		case tins::c_movl_ar:
		case tins::c_movl_ra:
			return false;
		case tins::c_movl_aa:
			v_get_addr_64(cur->first)=v_get_addr_64(cur->second);
			v_next_ins;

		case tins::c_add_ri:
			v_get_reg(cur->first)+=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_add_ai:
			v_get_addr(cur->first)+=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_add_rr:
			v_get_reg(cur->first)+=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_add_ar:
			v_get_addr(cur->first)+=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_add_ra:
			v_get_reg(cur->first)+=v_get_addr(cur->second);
			v_next_ins;
		case tins::c_add_aa:
			v_get_addr(cur->first)+=v_get_addr(cur->second);
			v_next_ins;

		case tins::c_sub_ri:
			v_get_reg(cur->first)-=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_sub_ai:
			v_get_addr(cur->first)-=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_sub_rr:
			v_get_reg(cur->first)-=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_sub_ar:
			v_get_addr(cur->first)-=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_sub_ra:
			v_get_reg(cur->first)-=v_get_addr(cur->second);
			v_next_ins;
		case tins::c_sub_aa:
			v_get_addr(cur->first)-=v_get_addr(cur->second);
			v_next_ins;
		
		case tins::c_imul_ri:
			v_get_reg(cur->first)*=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_imul_ai:
			v_get_addr(cur->first)*=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_imul_rr:
			v_get_reg(cur->first)*=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_imul_ar:
			v_get_addr(cur->first)*=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_imul_ra:
			v_get_reg(cur->first)*=v_get_addr(cur->second);
			v_next_ins;
		case tins::c_imul_aa:
			v_get_addr(cur->first)*=v_get_addr(cur->second);
			v_next_ins;

		case tins::c_idiv_ri:
			v_get_reg(cur->first)/=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_idiv_ai:
			v_get_addr(cur->first)/=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_idiv_rr:
			v_get_reg(cur->first)/=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_idiv_ar:
			v_get_addr(cur->first)/=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_idiv_ra:
			v_get_reg(cur->first)/=v_get_addr(cur->second);
			v_next_ins;
		case tins::c_idiv_aa:
			v_get_addr(cur->first)/=v_get_addr(cur->second);
			v_next_ins;

		case tins::c_imod_ri:
			v_get_reg(cur->first)%=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_imod_ai:
			v_get_addr(cur->first)%=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_imod_rr:
			v_get_reg(cur->first)%=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_imod_ar:
			v_get_addr(cur->first)%=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_imod_ra:
			v_get_reg(cur->first)%=v_get_addr(cur->second);
			v_next_ins;
		case tins::c_imod_aa:
			v_get_addr(cur->first)%=v_get_addr(cur->second);
			v_next_ins;	
		
		case tins::c_cesb_ri:
			reg.ebx=v_get_reg(cur->first)==v_get_imme(cur->second);
			v_next_ins;
		case tins::c_cesb_ai:
			reg.ebx=v_get_addr(cur->first)==v_get_imme(cur->second);
			v_next_ins;
		case tins::c_cesb_rr:
			reg.ebx=v_get_reg(cur->first)==v_get_reg(cur->second);
			v_next_ins;
		case tins::c_cesb_ar:
			reg.ebx=v_get_addr(cur->first)==v_get_reg(cur->second);
			v_next_ins;
		case tins::c_cesb_ra:
			reg.ebx=v_get_reg(cur->first)==v_get_addr(cur->second);
			v_next_ins;
		case tins::c_cesb_aa:
			reg.ebx=v_get_addr(cur->first)==v_get_addr(cur->second);
			v_next_ins;

		case tins::c_cnesb_ri:
			reg.ebx=v_get_reg(cur->first)!=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_cnesb_ai:
			reg.ebx=v_get_addr(cur->first)!=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_cnesb_rr:
			reg.ebx=v_get_reg(cur->first)!=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_cnesb_ar:
			reg.ebx=v_get_addr(cur->first)!=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_cnesb_ra:
			reg.ebx=v_get_reg(cur->first)!=v_get_addr(cur->second);
			v_next_ins;
		case tins::c_cnesb_aa:
			reg.ebx=v_get_addr(cur->first)!=v_get_addr(cur->second);
			v_next_ins;
		
		case tins::c_cgsb_ri:
			reg.ebx=v_get_reg(cur->first)>v_get_imme(cur->second);
			v_next_ins;
		case tins::c_cgsb_ai:
			reg.ebx=v_get_addr(cur->first)>v_get_imme(cur->second);
			v_next_ins;
		case tins::c_cgsb_rr:
			reg.ebx=v_get_reg(cur->first)>v_get_reg(cur->second);
			v_next_ins;
		case tins::c_cgsb_ar:
			reg.ebx=v_get_addr(cur->first)>v_get_reg(cur->second);
			v_next_ins;
		case tins::c_cgsb_ra:
			reg.ebx=v_get_reg(cur->first)>v_get_addr(cur->second);
			v_next_ins;
		case tins::c_cgsb_aa:
			reg.ebx=v_get_addr(cur->first)>v_get_addr(cur->second);
			v_next_ins;

		case tins::c_cgesb_ri:
			reg.ebx=v_get_reg(cur->first)>=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_cgesb_ai:
			reg.ebx=v_get_addr(cur->first)>=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_cgesb_rr:
			reg.ebx=v_get_reg(cur->first)>=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_cgesb_ar:
			reg.ebx=v_get_addr(cur->first)>=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_cgesb_ra:
			reg.ebx=v_get_reg(cur->first)>=v_get_addr(cur->second);
			v_next_ins;
		case tins::c_cgesb_aa:
			reg.ebx=v_get_addr(cur->first)>=v_get_addr(cur->second);
			v_next_ins;

		case tins::c_clsb_ri:
			reg.ebx=v_get_reg(cur->first)<v_get_imme(cur->second);
			v_next_ins;
		case tins::c_clsb_ai:
			reg.ebx=v_get_addr(cur->first)<v_get_imme(cur->second);
			v_next_ins;
		case tins::c_clsb_rr:
			reg.ebx=v_get_reg(cur->first)<v_get_reg(cur->second);
			v_next_ins;
		case tins::c_clsb_ar:
			reg.ebx=v_get_addr(cur->first)<v_get_reg(cur->second);
			v_next_ins;
		case tins::c_clsb_ra:
			reg.ebx=v_get_reg(cur->first)<v_get_addr(cur->second);
			v_next_ins;
		case tins::c_clsb_aa:
			reg.ebx=v_get_addr(cur->first)<v_get_addr(cur->second);
			v_next_ins;

		case tins::c_clesb_ri:
			reg.ebx=v_get_reg(cur->first)<=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_clesb_ai:
			reg.ebx=v_get_addr(cur->first)<=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_clesb_rr:
			reg.ebx=v_get_reg(cur->first)<=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_clesb_ar:
			reg.ebx=v_get_addr(cur->first)<=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_clesb_ra:
			reg.ebx=v_get_reg(cur->first)<=v_get_addr(cur->second);
			v_next_ins;
		case tins::c_clesb_aa:
			reg.ebx=v_get_addr(cur->first)<=v_get_addr(cur->second);
			v_next_ins;
			
		case tins::c_band_ri:
			v_get_reg_u(cur->first)&=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_band_ai:
			v_get_addr_u(cur->first)&=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_band_rr:
			v_get_reg_u(cur->first)&=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_band_ar:
			v_get_addr_u(cur->first)&=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_band_ra:
			v_get_reg_u(cur->first)&=v_get_addr_u(cur->second);
			v_next_ins;
		case tins::c_band_aa:
			v_get_addr_u(cur->first)&=v_get_addr_u(cur->second);
			v_next_ins;	

		case tins::c_bor_ri:
			v_get_reg_u(cur->first)|=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_bor_ai:
			v_get_addr_u(cur->first)|=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_bor_rr:
			v_get_reg_u(cur->first)|=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_bor_ar:
			v_get_addr_u(cur->first)|=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_bor_ra:
			v_get_reg_u(cur->first)|=v_get_addr_u(cur->second);
			v_next_ins;
		case tins::c_bor_aa:
			v_get_addr_u(cur->first)|=v_get_addr_u(cur->second);
			v_next_ins;	

		case tins::c_bnot_i:
			return false;
		case tins::c_bnot_r:
			v_get_reg(cur->first)=~v_get_reg(cur->first);
			v_next_ins;	
		case tins::c_bnot_a:
			v_get_addr(cur->first)=~v_get_addr(cur->first);
			v_next_ins;
		case tins::c_bnot_a+1:
		case tins::c_bnot_a+2:
		case tins::c_bnot_a+3:
			return false;

		case tins::c_bxor_ri:
			v_get_reg_u(cur->first)^=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_bxor_ai:
			v_get_addr_u(cur->first)^=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_bxor_rr:
			v_get_reg_u(cur->first)^=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_bxor_ar:
			v_get_addr_u(cur->first)^=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_bxor_ra:
			v_get_reg_u(cur->first)^=v_get_addr_u(cur->second);
			v_next_ins;
		case tins::c_bxor_aa:
			v_get_addr_u(cur->first)^=v_get_addr_u(cur->second);
			v_next_ins;	

		case tins::c_bshl_ri:
			v_get_reg_u(cur->first)<<=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_bshl_ai:
			v_get_addr_u(cur->first)<<=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_bshl_rr:
			v_get_reg_u(cur->first)<<=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_bshl_ar:
			v_get_addr_u(cur->first)<<=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_bshl_ra:
			v_get_reg_u(cur->first)<<=v_get_addr_u(cur->second);
			v_next_ins;
		case tins::c_bshl_aa:
			v_get_addr_u(cur->first)<<=v_get_addr_u(cur->second);
			v_next_ins;	

		case tins::c_bshr_ri:
			v_get_reg_u(cur->first)>>=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_bshr_ai:
			v_get_addr_u(cur->first)>>=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_bshr_rr:
			v_get_reg_u(cur->first)>>=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_bshr_ar:
			v_get_addr_u(cur->first)>>=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_bshr_ra:
			v_get_reg_u(cur->first)>>=v_get_addr_u(cur->second);
			v_next_ins;
		case tins::c_bshr_aa:
			v_get_addr_u(cur->first)>>=v_get_addr_u(cur->second);
			v_next_ins;	

		case tins::c_bsar_ri:
			v_get_reg(cur->first)>>=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_bsar_ai:
			v_get_addr(cur->first)>>=v_get_imme(cur->second);
			v_next_ins;
		case tins::c_bsar_rr:
			v_get_reg(cur->first)>>=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_bsar_ar:
			v_get_addr(cur->first)>>=v_get_reg(cur->second);
			v_next_ins;
		case tins::c_bsar_ra:
			v_get_reg(cur->first)>>=v_get_addr(cur->second);
			v_next_ins;
		case tins::c_bsar_aa:
			v_get_addr(cur->first)>>=v_get_addr(cur->second);
			v_next_ins;	

		case tins::c_udiv_ri:
			v_get_reg_u(cur->first)/=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_udiv_ai:
			v_get_addr_u(cur->first)/=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_udiv_rr:
			v_get_reg_u(cur->first)/=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_udiv_ar:
			v_get_addr_u(cur->first)/=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_udiv_ra:
			v_get_reg_u(cur->first)/=v_get_addr_u(cur->second);
			v_next_ins;
		case tins::c_udiv_aa:
			v_get_addr_u(cur->first)/=v_get_addr_u(cur->second);
			v_next_ins;

		case tins::c_umod_ri:
			v_get_reg_u(cur->first)%=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_umod_ai:
			v_get_addr_u(cur->first)%=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_umod_rr:
			v_get_reg_u(cur->first)%=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_umod_ar:
			v_get_addr_u(cur->first)%=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_umod_ra:
			v_get_reg_u(cur->first)%=v_get_addr_u(cur->second);
			v_next_ins;
		case tins::c_umod_aa:
			v_get_addr_u(cur->first)%=v_get_addr_u(cur->second);
			v_next_ins;		

		case tins::c_ucgsb_ri:
			reg.ebx=v_get_reg_u(cur->first)>v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_ucgsb_ai:
			reg.ebx=v_get_addr_u(cur->first)>v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_ucgsb_rr:
			reg.ebx=v_get_reg_u(cur->first)>v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_ucgsb_ar:
			reg.ebx=v_get_addr_u(cur->first)>v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_ucgsb_ra:
			reg.ebx=v_get_reg_u(cur->first)>v_get_addr_u(cur->second);
			v_next_ins;
		case tins::c_ucgsb_aa:
			reg.ebx=v_get_addr_u(cur->first)>v_get_addr_u(cur->second);
			v_next_ins;

		case tins::c_ucgesb_ri:
			reg.ebx=v_get_reg_u(cur->first)>=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_ucgesb_ai:
			reg.ebx=v_get_addr_u(cur->first)>=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_ucgesb_rr:
			reg.ebx=v_get_reg_u(cur->first)>=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_ucgesb_ar:
			reg.ebx=v_get_addr_u(cur->first)>=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_ucgesb_ra:
			reg.ebx=v_get_reg_u(cur->first)>=v_get_addr_u(cur->second);
			v_next_ins;
		case tins::c_ucgesb_aa:
			reg.ebx=v_get_addr_u(cur->first)>=v_get_addr_u(cur->second);
			v_next_ins;

		case tins::c_uclsb_ri:
			reg.ebx=v_get_reg_u(cur->first)<v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_uclsb_ai:
			reg.ebx=v_get_addr_u(cur->first)<v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_uclsb_rr:
			reg.ebx=v_get_reg_u(cur->first)<v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_uclsb_ar:
			reg.ebx=v_get_addr_u(cur->first)<v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_uclsb_ra:
			reg.ebx=v_get_reg_u(cur->first)<v_get_addr_u(cur->second);
			v_next_ins;
		case tins::c_uclsb_aa:
			reg.ebx=v_get_addr_u(cur->first)<v_get_addr_u(cur->second);
			v_next_ins;

		case tins::c_uclesb_ri:
			reg.ebx=v_get_reg_u(cur->first)<=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_uclesb_ai:
			reg.ebx=v_get_addr_u(cur->first)<=v_get_imme_u(cur->second);
			v_next_ins;
		case tins::c_uclesb_rr:
			reg.ebx=v_get_reg_u(cur->first)<=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_uclesb_ar:
			reg.ebx=v_get_addr_u(cur->first)<=v_get_reg_u(cur->second);
			v_next_ins;
		case tins::c_uclesb_ra:
			reg.ebx=v_get_reg_u(cur->first)<=v_get_addr_u(cur->second);
			v_next_ins;
		case tins::c_uclesb_aa:
			reg.ebx=v_get_addr_u(cur->first)<=v_get_addr_u(cur->second);
			v_next_ins;

		default:
			return false;
		}
#endif
		return true;
	}

	static rbool init(tsh& sh,rbuf<uchar>& stack,
		treg& reg,rbuf<tasm>& init_vasm)
	{
		ifn(asm_init(sh,init_vasm))
		{
			return false;
		}
		reg.esp=(uint)(stack.end());
		reg.eip=(uint)(init_vasm.begin());
		return true;
	}

	static rbool asm_init(tsh& sh,rbuf<tasm>& vasm)
	{
		vasm+=rf::vstr("sub","esp",",","4");
		vasm+=rf::vstr("call",rsoptr(c_mbk_l),rsoptr(c_addr),
			rsoptr(c_comma),"main",rsoptr(c_comma),"main()",
			rsoptr(c_mbk_r));
		vasm+=rf::vstr("add","esp",",","4");
		vasm+=rf::vstr("halt");
		return zbin::proc_vasm(sh,vasm);
	}
};
﻿
void main()
{
	printl sizeof(int*)
}
﻿/*
检查当前目录下文本文件的编码类型
*/

import rdir.h
import rfile.h

void main()
{
	v=rdir.get_file_bfs('./')
	for i=0;i<v.count;i++
	{
		if v[i].get_top==`/
			continue
		rfile file(v[i])
		rbuf<char> buf(3)
		ifn(file.read(3,buf.begin))
			break
		s=v[i]+' '
		if(buf[0]==0xff&&buf[1]==0xfe)
			s+='utf16'
		elif(buf[0]==0xef&&buf[1]==0xbb&&buf[2]==0xbf)
			s+='utf8'
		else
			s+='gbk'
		s.printl
	}
}﻿//1.h amd 3.45GHZ cost time 3600ms ,new version 2800ms 1.89 2609ms fix2 2516ms 2094ms
//36_2.rs cost time 5375ms (1.83 4985ms),new version 4438ms 1.89 4156ms 3375ms
void main()
{
	start=xf.tick
	for i=1;i<=10;i++
		rf.cmd("rush ..\\src\\example\\test\\1.rs")
	printl
	printl(xf.tick-start)
}﻿/*
统计当前目录下代码行数
如果使用utf16统计更准确
*/

import rdir.h
import rfile.h

int g_sum=0

void count_line(rstr name)
{
	s=rfile.read_all_n(name)
	sum=1
	for i=0;i<s.count;i++
		if s[i]==0xa
			sum++
	g_sum+=sum
	printl(name+': '+sum+' lines')
}

void main()
{
	path='../src'
#ifdef _RVM
	if rf.get_param.count==3
		path=rf.get_param.top
#endif
		
	v=rdir.get_file_bfs(path)
	for i=0;i<v.count;i++
		name=v[i]
		suffix=rdir.get_suffix(name)
		if suffix=='h'||suffix=='cpp'||suffix=='rs'
			count_line(name)
	printl('total: '+g_sum)
}﻿/*
分别以解释方式和编译方式运行example下所有例子，
并与标准答案进行对比，以此来检验编译器的正确性。
*/

import rdir.h
import rfile.h

int g_sta_ok
int g_total

void main()
{
	use_paral=rf.get_param.get_top=='-paral'
	g_sta_ok=1
	start=xf.tick
	g_total=0
	v=rdir.get_file_bfs('../src/example/test/')
	rbuf<rstr> vname
	for i=0;i<v.count;i++
		name=rdir.get_name(v[i])
		suffix=rdir.get_suffix(name)
		if suffix!='rs'
			continue
		a=name.sub(0,name.count-suffix.count-1)
		if is_ignore(a)
			continue
		vname.push(a)
	rbuf<int> vtime
	num=4
	
	time=xf.tick
	
	for i=0;i<vname.count;i++
		check_vm(vname[i])
	
	vtime.push(xf.tick-time)
	time=xf.tick
	
	for i=0;i<vname.count;i++
		check_jit(vname[i])
		
	vtime.push(xf.tick-time)
	time=xf.tick
	
	for i=0;i<vname.count;i++
		check_nasm(vname[i])
	
	vtime.push(xf.tick-time)
	time=xf.tick
	
	for i=0;i<vname.count;i++
		check_gpp(vname[i])
		
	vtime.push(xf.tick-time)

	printl
	for i=0;i<vtime.count;i++
		printl 'time'+i+': '+vtime[i]
	printl
	printl('total: '+g_total)
	printl('time: '+(xf.tick-start))
	printl('state: '+r_cond<rstr>(g_sta_ok,'ok','error'))
	xf.getch
}

bool is_ignore(rstr a)
{
	ifn a.sub(0,1).is_number
		return true
	if a=='36_8'
		return true
	return false
}

void check_vm(rstr a)
{
	rf.cmd('rush ../src/example/test/'+a+'.rs > ../src/example/answer/'+a+'_tmp.txt')
	check_vm('../src/example/answer/'+a+'_tmp.txt',
		'../src/example/answer/'+a+'.txt')
}

void check_jit(rstr a)
{
	rf.cmd('rush -jit ../src/example/test/'+a+'.rs > ../src/example/answer/'+a+'_tmp.txt')
	check_jit('../src/example/answer/'+a+'_tmp.txt','../src/example/answer/'+a+'.txt')
}

void check_nasm(rstr a)
{
	rf.cmd('rnasm \"../src/example/test/'+a+'.rs\" > \"../src/example/answer/'+a+'_tmp.txt\"')
	check_nasm('../src/example/answer/'+a+'_tmp.txt','../src/example/answer/'+a+'.txt')
}

void check_gpp(rstr a)
{
	if a=='17_1'
		return
	rf.cmd('gpp \"../src/example/test/'+a+'.rs\" > \"../src/example/answer/'+a+'_tmp.txt\"')
	check_gpp('../src/example/answer/'+a+'_tmp.txt','../src/example/answer/'+a+'.txt')
}

void check_vm(rstr a,rstr b)
{
	//不严谨，应该使用互斥体
	g_total++
	cont=rfile.read_all_n(a);
	if cont.count>0&&cont==rfile.read_all_n(b)
		print('ok ')
	else
		print('* * * error ')
		g_sta_ok=0
	printl('vm '+rdir.get_name(a)+' vs '+rdir.get_name(b))
	if rfile.remove(a)
		printl('* * * error ')
		g_sta_ok=0
}

void check_jit(rstr a,rstr b)
{
	g_total++
	cont=rfile.read_all_n(a);
	if cont.count>0&&cont==rfile.read_all_n(b)
		print('ok ')
	else
		print('* * * error ')
		g_sta_ok=0
	printl('jit '+rdir.get_name(a)+' vs '+rdir.get_name(b))
	if rfile.remove(a)
		printl('* * * error ')
		g_sta_ok=0
}

void check_nasm(rstr a,rstr b)
{
	g_total++
	cont=rfile.read_all_n(a)
	cont=cont.sub(cont.find('\x73\x0d\x0a')+3)//去掉golink打印的信息
	if cont.count>0&&cont==rfile.read_all_n(b)
		print('ok ')
	else
		print('* * * error ')
		g_sta_ok=0
	printl('nasm '+rdir.get_name(a)+' vs '+rdir.get_name(b))
	if rfile.remove(a)
		printl('* * * error ')
		g_sta_ok=0
}

void check_gpp(rstr a,rstr b)
{
	g_total++
	cont=rfile.read_all_n(a);
	if cont.count>0&&cont==rfile.read_all_n(b)
		print('ok ')
	else
		print('* * * error ')
		g_sta_ok=0
	printl('gpp '+rdir.get_name(a)+' vs '+rdir.get_name(b))
	if rfile.remove(a)
		printl('* * * error ')
		g_sta_ok=0
}
﻿/*
文件搜索工具
*/

import rfile.h
import rdir.h

void main()
{
	dir='../'
	arr=array<rstr>['cpp','h']
	str='s_ret'
	//todo utf16转换
	v=rdir.get_file_bfs(dir)
	for i=0;i<v.count;i++
		name=rdir.get_name(v[i])
		suffix=rdir.get_suffix(name)
		if(v[i].get_top()==`/)
			continue
		ifn arr.exist(suffix)
			continue
		s=rfile.read_all_n(v[i])
		if s.find(str)<s.count
			printl(v[i])
}﻿/*
编译生成exe并运行
*/

import rfile.h
import rdir.h

void main()
{
	v=rf.get_param
	if v.count<3
		printl('invaild param')
		return
	opt='-O2'
	if v.count>3
		opt=v[3]
	src=v[2]
	if src.get_left==r_char('\"')
		src=src.sub(1,src.count-1)
	if rf.cmd('rush -gpp '+src)
		printl('compile error')
		return
	src_name=rdir.get_real_name(src)
	//printl src_name
	//return
	if rf.cmd('..\\ext\\mingw\\bin\\build '+src_name+'.cpp '+
		src_name+'.exe '+opt)
		clear(src_name)
		printl('cpp error')
		return
	//printl('..\\ext\\mingw\\bin\\build '+src_name+'.cpp '+
	//	src_name+'.exe')
	
	ifn v.count>=5&&v[4]=='-build'
		rf.cmd(rdir.dir_std_rev(src_name+'.exe'))
	
	//clear(src_name)
	
	//rfile.remove(rcode.gbk_to_utf8(src_name)+'.exe')
	return
	cmd='..\\ext\\nasm\\GoLink.exe /console /mix /entry _main \"'
	cmd+=src_name+'.obj\" msvcrt.dll ws2_32.dll kernel32.dll user32.dll'
	if rf.cmd(cmd)
		clear(src_name)
		printl('link error')
		return
	clear(src_name)
	if v[3]=='-build'
		;
	elif v[3]=='-del'
		rf.cmd(rdir.dir_std_rev(src_name+'.exe'))
		while rfile.remove(rcode.gbk_to_utf8(src_name)+'.exe')
			xf.sleep(100)//很可能是由于golink没有关闭EXE导致无法删除
	elif v[3]=='-check'
		if rfile.remove(rcode.gbk_to_utf8(src_name)+'.exe')
			printl 'delete error'
}

void clear(rstr name)
{
	name=rcode.gbk_to_utf8(name)
	rfile.remove(name+'.exe')
	rfile.remove(name+'.cpp')
}﻿/*
检查代码每行是否超过92字符
rush ..\src\example\line_check.rs ../
*/

import rdir.h
import rfile.h

bool check_line(rstrw s)
{
	count=0
	for i=0;i<s.count;i++
		temp=s.sub(i,i+1).torstr.get(0)
		if rcode.is_utf8_3(temp)||rcode.is_utf8_2(temp)
			count+=2
		elif s[i]==r_char('	').toint
			count+=8
		else
			count++
	if count<=92
		return true
	printl 'count '+count
	printl(s.torstr)
	return false
}

bool check_s(rstrw s)
{
	rstrw temp
	for i=0;i<s.count;i++
		if s[i]==10&&s.get(i-1)!=13
			return false//temp+=13.toushort
		if s[i]==13&&s.get(i+1)!=10
			return false
		temp+=s[i]
	v=r_split_e<rstrw>(temp,'\r\n')
	for i=0;i<v.count;i++
		ifn check_line(v[i])
			printl('line '+(i+1))
			return false
	return true
}

bool check_file(rstr name)
{
	rfile file(name)
	rbuf<char> buf(3)
	ifn(file.read(3,buf.begin))
		return false
	ok=false
	if(buf[0]==0xff&&buf[1]==0xfe)
		s=rfile.read_all_n(name).sub(2)
		rstrw temp
		temp.set_size(s.count)
		xf.memcpy(temp.begin,s.begin,s.count)
		ok=check_s(temp)
	elif(buf[0]==0xef&&buf[1]==0xbb&&buf[2]==0xbf)
		s=rfile.read_all_n(name).sub(3)
		ok=check_s(rstrw(s))
	if ok
		return true
	printl(name)
	return false
}

void main()
{
	if rf.get_param.count<3
		return
	v=rdir.get_file_bfs(rf.get_param.top)
	for i=0;i<v.count;i++
		name=v[i]
		if name.sub(name.count-2)=='.h'
			ifn check_file(name)
				break
		elif name.sub(name.count-4)=='.cpp'
			ifn check_file(name)
				break
}﻿/*
编译生成exe并运行
*/

import rfile.h
import rdir.h

void main()
{
	v=rf.get_param
	if v.count!=4
		printl('invaild param')
		return
	src=v[2]
	if src.get_left==r_char('\"')
		src=src.sub(1,src.count-1)
	if rf.cmd('rush -nasm '+src)
		printl('compile error')
		return
	src_name=rdir.get_real_name(src)
	if rf.cmd('..\\ext\\nasm\\nasm.exe -f win32 '+src_name+'.asm -o '+
		src_name+'.obj')
		clear(src_name)
		printl('asm error')
		return
	cmd='..\\ext\\nasm\\GoLink.exe /console /mix /entry _main \"'
	cmd+=src_name+'.obj\" msvcrt.dll ws2_32.dll kernel32.dll user32.dll'
	if rf.cmd(cmd)
		clear(src_name)
		printl('link error')
		return
	clear(src_name)
	if v[3]=='-build'
		;
	elif v[3]=='-del'
		rf.cmd(rdir.dir_std_rev(src_name+'.exe'))
		while rfile.remove(rcode.gbk_to_utf8(src_name)+'.exe')
			xf.sleep(100)//很可能是由于golink没有关闭EXE导致无法删除
	elif v[3]=='-check'
		if rfile.remove(rcode.gbk_to_utf8(src_name)+'.exe')
			printl 'delete error'
}

void clear(rstr name)
{
	name=rcode.gbk_to_utf8(name)
	rfile.remove(name+'.asm')
	rfile.remove(name+'.obj')
}﻿import rfile.h

void main()
{
	rf.cmd("gpp_build ..\\src\\rush.cxx")
	rf.cmd("copy /B /Y ..\\src\\rush.exe rush_gpp.exe")
	rf.cmd("rush -nasm ../src/rush.cxx")
	rf.cmd("copy /B /Y ..\\src\\rush.asm rush_gpp.asm")
	rf.cmd("rush_gpp -nasm ../src/rush.cxx")
	if rfile.read_all_n("rush_gpp.asm")==rfile.read_all_n("..\\src\\rush.asm")
		printl "ok"
	else
		printl "error"
}
﻿import rfile.h

void main()
{
	rf.cmd("rnasm_build ..\\src\\rush.cxx")
	rf.cmd("copy /B /Y ..\\src\\rush.exe rush_nasm.exe")
	rf.cmd("rush -nasm ../src/rush.cxx")
	rf.cmd("copy /B /Y ..\\src\\rush.asm rush_nasm.asm")
	rf.cmd("rush_nasm -nasm ../src/rush.cxx")
	if rfile.read_all_n("rush_nasm.asm")==rfile.read_all_n("..\\src\\rush.asm")
		printl "ok"
	else
		printl "error"
}
﻿/*
sum前加上int8可以求出正确的和
如改成sum+=i+j可测试出C++的真实速度
*/

void main()
{
	start=xf.tick
	
	sum=0
	for i=0;i<=10000;i++
		for j=0;j<=10000;j++
			sum+=i
	printl sum
	
	printl xf.tick-start
}
﻿/*
rush ..\src\example\symbol.rs rp3Cchar3E2Erp3Cchar3E28rp3Cchar3E262Crp3Cchar3E29
*/

void main()
{
	s=rf.get_param.get(2)//xf.scanl
	result=''
	for i=0;i<s.count;i++
		if rstr.is_number(s[i])&&(rstr.is_number(s.get(i+1))||s.get(i+1)>=`A&&s.get(i+1)<=`F)
			temp=0
			if rstr.is_number(s.get(i+1))
				temp=s.get(i+1).toint-48
			else
				temp=s.get(i+1).toint-`A+10
			result+=((s[i].toint-48)*16+temp).tochar
			i++
		else
			result+=s[i]
	printl result
}
﻿import rdir.h
import rfile.h

void main()
{
	v=rdir.get_file_bfs('../src/')
	for i=0;i<v.count;i++
		name=rdir.get_name(v[i])
		suffix=rdir.get_suffix(name)
		ifn suffix=='rs'||suffix=='h'||suffix=='cpp'
			continue
		src=rfile.read_all_n(v[i])
		dst=rcode.to_utf8_txt(src)
		if src==dst
			continue
		printl v[i]
		rfile.write_all_n(v[i],dst)
}355
3628800
55
3628800
2
5
9
1
rp<char>
4
7
5
5
55
3628800
1
abc
98
3
5
20
100
6
123
234
12
7
25
6
789
123
1234
3
1.100000
3
1.100000
3
3
3
3
3
3
3
3
3
123
123
2
3
99
98
test
main
C
5
23
3
1
2
1
2
3
6
103
10
16
3
5
34
3
0
2
22222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222223
3
0
1
-1
3
uint
uint
uint
rstr
int
97
255
2int
int
0
4
1
1
c12
0000011111222223333344444000011112222000011112222000011112222000011112222000011112222000011112222000011112222000011112222000011112222000011112222func int
func char
2
2
2
2
5
3
3
4
4
2
3
2
3
3i>=10
1
0
3123
123
abc'123
97
97
97
100000000
100000000
10
10
10
0.500000
pass 1
pass 1
pass 1
pass 1
pass 1
pass 1
pass 1
pass 2
other
pass 2
pass 2
pass 2
pass 2
pass 2
other
other
default
default
default
default
default
123456789123456789123456789123456789a less than b
a less than b
0
1
2
3
4
5
6
7
8
9
2
3
3
4
2
2
2
4
constructor
constructor
3
func
func
3
2
1
3
2
4
3
2
4
protected code1
2
3
1
3

1
3
4
321
1343
fj242i
12

12
1343
321
fj242i

12
2
3
6
123
4
/*
read self
*/

import "rfile.h"

void main()
{
	rfile file("../src/example/test/36_7.rs")
	file.read_all.sub(3).print
	//auto close file in destructor
}
9or
true
true
1
1
0
1
0
0
33
3
0
4
0.500000
0.060000
0.666667
-0.100000
1
0
1984.000000
-2
0
0
0
1
0
1
1
1
0
3
27
0
6
0
1
ok
3
15
1
3
30018
-4
-2326
9702
-6815
1
3
-3
2
1234
1243
1324
1342
1423
1432
2134
2143
2314
2341
2413
2431
3124
3142
3214
3241
3412
3421
4123
4132
4213
4231
4312
4321
2
-1
1
1
3
4
1
9
10
2

1
2
3
4
9
10

10
9
4
3
2
1

1
2
3
4
9
10

35
120
720
35
1 2 3 4 5
3 6 9 12 15
45
45
45
true
2
3
2
3
2
3
2
3
3
1abc
123abc
123abc
-2
-2
-2
2
2
3
eax is not zero
cab132
123abc
﻿/*
下面是编译期计算示例，sum是一个宏，计算从0加到N
此程序仅支持jit模式运行
*/

import back/zmain.h

void main()
{
	printl sum(100)//输出5050
	printl sum(10)//输出55
}

macro void sum(rbuf<tword>& v,int index)
{
	result=0
	param=v.get(index+2).val.toint
	for i=0;i<=param;i++
		result+=i
	v[index].val=result
	for i=1;i<=3;i++
		v[index+i].val.clear
}
﻿/*
rush的macro具有和Lisp宏一样强大的表达能力
这种宏可以用写代码对代码进行变换，这就比C语言的宏强大得多
下面是变参宏示例
注意macro只能是全局的
此程序仅支持jit模式运行
*/

import back/zmain.h

void main()
{
	printl sum(98,56)
	printl sum(1,2,3,4)
	printl sum(43,534,65,645,54,2)
}

macro void sum(rbuf<tword>& v,int index)
{
	tsh sh
	left=index+1
	right=ybase.find_symm_sbk(sh,v,left)
	result=0
	for i=index+2;i<right;i+=2
		result+=v[i].val.toint
	for i=index;i<=right;i++
		v[i].val.clear
	v[index].val=result
}
﻿/*
可以发挥想象力定制奇特的宏，
比如宏可以引用整个函数的单词并进行替换，
也可以定制自己的控制结构
此程序仅支持jit模式运行
*/

import back/zmain.h

void main()
{
	5 times printl('hello');
	sum=0;
	10 times sum+=2;
	printl sum;
}

macro void times(rbuf<tword>& v,int index)
{
	count=v[index-1].val.toint
	for i=index;i<v.count;i++
		if v[i].val==';'
			break
	end=i
	for i=0;i<count;i++
		v[index].multi+=ybase.vword_to_vstr(v.sub(index+1,end+1))
	for i=index-1;i<=end;i++
		v[i].val.clear
}
﻿/*
最简单的程序，1+2=3
*/

void main():
	a=1
	b=2
	print(a+b)
	﻿/*
模板函数
*/

void main()
{
	printl func<+>(10)
	printl func<*>(10)
	
	printl func<+> 10
	printl func<*> 10
}

int func<T>(int a)
{
	if a<=1
		return 1
	return func<T>(a-1) T a
}﻿/*
模板函数作为类的成员
*/

void main()
{
	A a
	
	A.set<2>(a)
	a.m_a.printl
	
	A.set<5>(a)
	a.m_a.printl
	
	a.func
	a.m_a.printl
}

class A
{
	int m_a
	
	//V1.5模板函数定义的时候可以省略小括号
	void set<T>()
	{
		m_a=T
	}
	
	void func()
	{
		set<9>
	}
}﻿/*
rush的模板函数十分强大，
不仅支持模板函数作为类的成员，还支持模板动态生成
*/

void main()
{
	int* p=1p
	p.to<char*>.printl
	printl typeof(p.to<char*>)

	A a
	printl a.func<2>
	printl a.func<5>
}

class A
{
	int m_a=2

	int func<T>()
	{
		return m_a+T
	}
}﻿/*
宏
*/

void main()
{
	c=fadd(1,2)*fadd(1,2)
	printl c

	c=fadd2(1,2)*fadd2(1,2)
	printl c

	fpro(+=)
	fpro(*=)
}

mac fadd(a,b) a+b

mac fadd2(a,b)
{
	a+b
}

mac fpro(T)
{
	pro=1;
	for(i=2;i<=10;i++)
	{
		pro T i;
	}
	printl(pro);
}﻿/*
拆分宏
*/

void main()
{
	#printl(1,'abc',98)
	
	vector<int> v
	#v.push(1,99,2)
	v.count.printl
}﻿/*
拆分宏的另一种用法：
括号里如果是取地址符号加类名将展开为该类的所有函数成员的指针
*/

void main()
{
	#func(&B)
}

void func(void* p)
{
	printl int[p,10]
}

namespace B
{
	int fmul(int a)
	{
		return a*2
	}
	
	int fdiv(int a)
	{
		return a/2
	}
	
	int fsquare(int a)
	{
		return a*a
	}
}﻿
void main()
{
	printl(XC_SY_DEFAULT)	
	printl(test())
	printl(test2())
}

mac test() 123

mac test2()
{
	234
}

mac XC_SY_DEFAULT 
{
	(1+
	 2+
	 3)
}﻿
void main()
{
	B 1 2
	C 1 [2 *3]
	C 1 [2*3*4]
	D 1 [2 3]
	
	v=array<int>[7,8,9]
	v.join('').printl
	
	v=E(1,2,3)
	v.join('').printl
	
	v=E(1,2,3,4)
	v.join('').printl
}

mac$ B _word _word
{
	printl($0##$1)
}

mac$ C _word [ _mword ]
{
	printl($0+$1)
}

mac$ D _word [ _mword ]
{
	printl($0+$1=>0+$1=>1)
}

mac$ E ( _mword )
{
	array<int>[$0]
}﻿/*
对比宏和模板函数
注意宏是无格式的，因此花括号和分号不可省略
*/

void main()
{
	printl fb<int>(1,2)
	printl fb<double>(0.5,0.6)

	printl fa_int(1,2)
	printl fa_double(0.5,0.6)	
}

T fb<T>(T a,T b)
{
	return a+b;
}

fa int
fa double

define$ fa _word
{
	$0 fa_##$0($0 a,$0 b)
	{
		return a+b;
	}	
}﻿/*
函数指针不需要声明即可使用，
参数可以由编译器自动推断出类型
*/

void main()
{
	printl int[&fadd,1,2]
	
	p=&fadd
	printl int[p,1,2]

	printl int[&fadd(int,int),1,2]

	printl int[&main.fadd(int,int),1,2]
}

int fadd(int a,int b)
{
	return a+b
}﻿/*
闭包
暂不支持GPP模式
*/

void main()
{
	int a=2
	void[lambda(){print a}]
}﻿/*
匿名函数
*/

void main()
{
	p=lambda(int a,int b){
		printl a+b
	}
	
	void[p,1,2]
	
	p=lambda(int,int a,int b){
		return a+b
	}
	
	printl int[p,1,2]
}﻿/*
继承

*/

class A
{
	int m_a

	void fa()
	{
		m_a=1
	}
}

class B:A
{
	void fb()
	{
		m_a=2
	}
}

void main()
{
	B b
	b.fa
	printl b.m_a
	b.fb
	printl b.m_a
}﻿/*
多重继承
*/

class A
{
	int m_a

	void fa()
	{
		m_a=1
	}
}

class B
{
	void fb()
	{
		printl 2
	}
}

class C:A,B
{
	void fc()
	{
		printl m_a
	}
}

void main()
{
	C c
	c.fa
	c.fc
	c.fb
}﻿/*
可变参数
*/

void main()
{
	printl sum[1,2]
	printl sum[1,2,3]
	printl sum[1,99,3]
	printl sum[1,2,3,4]
	printl sum[1,sum[1,2,5],3,4]
}

#ifndef _RGPP
int sum(int count)
{
	//sub esp,sizeof(s_local)
	//push ebp
	//mov ebp,esp

	int* p=&count+1
	int ret=0
	for i=0;i<count;i++
		ret+=*p
		p++
	*p=ret

	mov ecx,4
	imul ecx,count
	add ecx,4
	pop ebp
	add esp,sizeof(s_local)
	mov eax,[esp]
	_reti(eax,ecx)

	//这里有编译器自动增加的语句
}
#else
int sum(int count)
{
	rstr temp=count//防止G++对整数进行优化（最高-O2），或者可以-O0，VC++没有此问题
	int* p=&count+1
	int ret=0
	for i=0;i<count;i++
		ret+=*p
		p++
	return ret
}
#endif﻿/*
类成员函数使用可变参数
*/

void main()
{
	A a
	a.push[1,99,3]
	a.m_arr.count.printl
	a.push[12,98]
	a.m_arr.count.printl
}

class A
{
	rbuf<int> m_arr

#ifndef _RGPP
	void push(int count)
	{
		//sub esp,sizeof(s_local)
		//push ebp
		//mov ebp,esp
		//变参函数的参数和局部变量需要手动析构，
		//这个例子使用的局部变量都是int，因此不需要析构

		int* p=&count+1
		for(i=0;i<count;i++)
		{
			m_arr.push(*p)
			p++
		}

		mov ecx,4
		imul ecx,count
		add ecx,8//注意成员函数多一个this引用
		pop ebp
		add esp,sizeof(s_local)
		mov eax,[esp]
		_reti(eax,ecx)

		//这里有编译器自动增加的语句
	}
#else
	void push(int count)
	{
		int* p=&count+1
		for(i=0;i<count;i++)
		{
			m_arr.push(*p)
			p++
		}
	}
#endif
}﻿/*
与上一个程序对应的C风格，
由此可以看到rush的一些特点：
*更彻底地类型推断，C++11需要使用关键字auto，rush可以省略auto
*函数定义和函数调用均可省略后面的小括号
*语句后面的分号也可以省略
*对于返回值为void的函数，可以省略void（标准C默认返回int）
*/

void main()
{
	int a=1;
	int b=2;
	print(a+b);
}﻿/*
rush的默认参数不仅可以访问到前面的参数，
还可以访问到类的成员变量
*/

int func(int a,int b=a)
{
	return a+b;
}

void main()
{
	printl func(2)
	printl func(1,2)
}﻿/*
rush是强类型语言，没有强制转换，
可以通过函数转换类型
*/

void main()
{
	a=2.touint
	printl typeof(a)

	a=2.to<uint>
	printl typeof(a)
	
	b=uint(2)
	printl typeof(b)
	
	c=2.torstr
	printl typeof(c)
	
	d="123".toint
	printl typeof(d)
	
	char ch=`a
	printl ch.toint

	char ch=-1
	printl ch.toint
}﻿/*
rush支持自动类型转换，
所以请小心定义拷贝构造函数
*/

void main()
{
	func(2)//整型2自动转换为无符号整型
}

void func(uint a)
{
	print a
}﻿/*
typeof后面可以跟表达式或者类型

typeof(1+2)
等价于
"int"

sizeof后面只能跟类型
*/

void main()
{
	printl typeof(1+2)
	
	A<int> a
	a.func
	
	printl sizeof(A<int>)
}

class A<T>
{
	void func()
	{
		printl typeof(T)
	}
}﻿/*
动态数组
*/

void main()
{
	vector<int> a
	a.push(1)
	printl a.size
	printl a.count
	
	a.sub(0,1).count.printl
	
	rstr b="abc12345ab"
	printl b.sub(2,5)
}﻿/*
二维数组
*/

import xlib/rs/rbufm.rs

void main()
{
	rbufm<int> arr(5,5)

	for i=0;i<5;i++
		for j=0;j<5;j++
			arr[i,j]=i
			arr[i,j].print
}﻿/*
使用多参数组定义三维数组
*/

import xlib/rs/rbufm.rs

void main()
{
	rbufm<int> arr(5,3,4)

	for i=0;i<5;i++
		for j=0;j<3;j++
			for k=0;k<4;k++
				arr[i,j,k]=j
				arr[i,j,k].print
}﻿/*
使用嵌套模板定义三维数组
*/

void main()
{
	rbuf<rbuf<rbuf<int>>> arr

	arr.alloc(5)
	for i=0;i<arr.count;i++
		arr[i].alloc(3)
		for j=0;j<arr[i].count;j++
			arr[i][j].alloc(4)

	for i=0;i<arr.count;i++
		for j=0;j<arr[i].count;j++
			for k=0;k<arr[i][j].count;k++
				arr[i][j][k]=j
				arr[i][j][k].print
}﻿/*
重载
*/

void func(int& a)
{
	printl 'func int'
}

void func(char& a)
{
	printl 'func char'
}

void main()
{
	func int()
	func char()
}﻿class A
{
	int* m_p
	
	A()
	{
		m_p=r_new<int>5	
	}
	
	A(A& a)
	{
		m_p=r_new<int>5
		for i=0;i<5;i++
			m_p[i]=a.m_p[i]
	}
	
	~A()
	{
		if m_p!=null
			r_delete<int>m_p
			m_p=null
	}
	
	void operator=(A& a)
	{
		this.~A
		this.A(a)
	}
}

void main()
{
	A a
	a.m_p[1]=2
	a.m_p[1].printl
	b=a
	b.m_p[1].printl
}
﻿/*
指针和引用
*/

void main()
{
	a=2
	
#ifndef _RGPP
	int& b
	lea b,[ebp+s_off a]
#else
	int b=a
#endif

	a.printl
	b.printl
	
	func(a)
	a.printl

	a=3
	p=&a
	a.printl
	p->printl

	a=4
	p=&a
	int** pp=&p
	printl *(*pp)

	rp<rp<rp<int>>> ppp=&pp
	printl *(*(*ppp))
}

void func(int& n)
{
	n=5
}﻿/*
全局变量定义的时候不能使用类型推断
*/


int g_a=2
rbuf<char> g_b(3)

void main()
{
	printl g_a
	b=g_b
	b.count.printl
}﻿/*
成员变量直接初始化
*/

class A
{
	int m_a=2
	int m_b(3)

	A()
	{
	}
}

void main()
{
	A a
	a.m_a.printl
	a.m_b.printl
}﻿/*
与上一个程序对应的Java（C#）风格
rush所有函数和类均默认为public，因此public完全可以不写
即使写private也是给人看的，编译器根本不管
*/

public class main
{
	public static void main()
	{
		int a=1;
		int b=2;
		print(a+b);
	}
}﻿
void main()
{
	for(int i=0;i<10;i++)
	{
	}
	if(i>=10)
		'i>=10'.printl
	
	vector<int> v
	v.push(2)
	v.count.printl

	vector<int> v
	v.count.printl
}
﻿
class A
{
	int* m_p
	
	A()
	{
		m_p=r_new<int>5	
	}
	
	~A()
	{
		if(m_p!=null)
			r_delete<int>m_p
			m_p=null
	}
}

void main()
{
	A a
	a.m_p[1]=3
	a.m_p[1].print
}
﻿
void main()
{
	printl '123'
	printl '123'.cstr

	s='abc\'123'
	printl s

	printl `a
	printl r_char("a").toint
	printl r_char('a').toint
	
	printl 1_0000_0000
	printl 100000000

	printl 0xa
	printl 0b1010
	printl 10

	printl 0.5
}
﻿
void main()
{
	test('1')
	test('2')
	test('3')
}

void test(rstr s)
{
	if s=='1':
		printl 'pass 1'
	elif s=='2':
		printl 'pass 2'
	else:
		printl 'other'

	if(s=='1')
	{
		printl 'pass 1'
	}
	else
	{
		printl 'other'
	}

	switch s
		case '1'
			printl 'pass 1'
		case '2'
			printl 'pass 2'
		default
			printl 'default'

	switch s:
		case '1'
		{
			printl 'pass 1'
		}
		case '2'
		{
			printl 'pass 2'
		}
		default
		{
			printl 'default'
		}

	switch(s)
	{
		case '1':
		{
			printl 'pass 1'
		}
		case '2':
		{
			printl 'pass 2'
		}
		default:
		{
			printl 'default'
		}
	}
	
	switch(s)
	{
	case '1':
	{
		printl 'pass 1'
	}
	case '2':
	{
		printl 'pass 2'
	}
	default:
	{
		printl 'default'
	}
	}
	
	switch(s)
	{
	case '1':
		printl 'pass 1'
	case '2':
		printl 'pass 2'
	default:
		printl 'default'
	}
}
﻿
void main()
{
	for i=1;i<10;i++
		print i

	i=1
	for i<10
		print i
		i++

	i=1
	for
		print i
		i++
		ifn i<10
			break
	
	i=1
	for
		print i
		i++
		until(i>=10)
}
﻿
void main()
{
	a=1
	b=2

	a<b
	jebxz G
		printl "a less than b"
	G:
	
	if(a<b)
		printl "a less than b"

	i=0
	H:
	i<10
	jebxz I 
		printl i
		i++
		jmp H
	I:
}
﻿/*
模板类
*/

class A<T>
{
	T m_a

	A<T>()
	{
	}
}

void main()
{
	A<int> a
	A<A<int>> b
	
	a.m_a=2
	a.m_a.printl
	b.m_a.m_a=3
	b.m_a.m_a.printl
}
﻿/*
模板类嵌套
*/

void main()
{
	A<A<int>> b
	b.m_b.m_c.m_b.m_c=3
	b.m_b.m_c.m_b.m_c.printl
	b.m_a.m_a=4
	b.m_a.m_a.printl
}

class B<T>
{
	T m_c
	T m_d
}

class A<T>
{
	T m_a
	B<T> m_b
}﻿/*
rush的命名空间实际上是一个类，
只是所有函数均没有this
*/

namespace MY
{
	//rush没有枚举变量，只有枚举常量
	enum
	{
		c_a=2
		c_b=4
	}

	void func()
	{
		printl c_a
	}
}

void main()
{
	MY.func
	MY::func
	printl MY.c_a
	printl MY::c_b
}﻿/*
rush一般不需要使用new，
推荐使用rbuf分配内存，
因为rbuf会在析构时自动释放内存
*/

void main()
{
	p=r_new<int>(5)
	p[2]=3
	p[2].printl
	r_delete<int>(p)
	
	rbuf<int> a(5)
	a[3]=2
	a[3].printl

	printl a.begin==a.m_p
}
﻿/*
双向链表
*/

import rlist.h

void main()
{
	rlist<int> a
	#a.push(3,2,4)
	b=a
	for p=a.begin;p!=a.end;p=a.next(p)
		p->printl
	for p=b.begin;p!=b.end;p=b.next(p)
		p->printl
}
﻿/*
红黑树
*/

import rset.h

void main()
{
	rset<int> s
	
	s.insert(3)
	s.insert(2)
	s.insert_c(2)
	s.insert(1)
	for p=s.begin;p!=s.end;p=s.next(p)
		p->printl
	s.erase 2
	for p=s.begin;p!=s.end;p=s.next(p)
		p->printl
		
	b=s
	printl
	for p=b.begin;p!=b.end;p=b.next(p)
		p->printl
}
﻿/*
哈希表
*/

import rhash.h

void main()
{
	rhash<int> a
	a['abc']=3
	a['121213']=4
	a['1']=1
	for i=1;i<=1000;i++
		a[i.torstr]=i
	a['121213'].printl
}
﻿/*
split、快排、二分
*/

import "ralgo.h"

void main()
{
	rbuf<rstr> v=r_split<rstr>('321;1343;fj242i;12',';')
	for i=0;i<v.count;i++
		v[i].printl
	printl
	
	r_qsort<rstr>(v)
	for i=0;i<v.count;i++
		v[i].printl
	printl
	
	v.get(r_find_b<rstr>(v,'12')).printl
	
	'1234'.find('34').printl
}
﻿/*
rstrw用于utf16处理，相当于STL的wstring
*/

import "rstrw.h"

void main()
{
	rstrw a='123'
	a.count.printl
	a.size.printl
	a.torstr.printl
}
﻿import rdic.h

void main()
{
	rdic<int> a
	a['abc']=3
	a['121213']=4
	a['1']=1
	for i=1;i<=1000;i++
		a[i.torstr]=i
	a['121213'].printl
}
﻿/*
read self
*/

import "rfile.h"

void main()
{
	rfile file("../src/example/test/36_7.rs")
	file.read_all.sub(3).print
	//auto close file in destructor
}
﻿/*
广度优先搜索遍历目录
*/

import rdir.h

void main()
{
	v=rdir.get_file_bfs('./')
	for i=0;i<v.count;i++
		v[i].printl
}﻿/*
rush不支持重载小括号，
但是可以重载中括号实现C++的函数对象（仿函数）
*/

void main()
{
	A<int,int> a=lambda(int,int n){return n*n}
	print a[3]
}

class A<T1,T2>
{
	void* m_func
	
	void =(void* p)
	{
		m_func=p
	}
	
	T1 [](T2 n)
	{
		return T1[m_func,n]
	}
}
﻿/*
与上一个程序对应的Lisp风格
*/

void main()
{
	int a
	int b
	[int,=,[a,1]]
	[int,=,[b,2]]
	[main,print,[[int,+,[a,b]]]]
}﻿
void main()
{
	int a
	int b
	[int,=,[a,1]]
	[int,=,[b,2]]
	
	[main,printl,[[int,+,[a,b]]]]
	main.printl(a+b)
	
	[main,printl,[[int,!,[a]]]]
	
	[main,func,[2]].printl
}

int func(int a)
{
	return a*2
}﻿
void main()
{
	test1
	test2
	test3
	test4
	test5
	test6
}

//浮点测试
void test1()
{
	printl 0.2+0.3
	printl 0.2*0.3
	printl 0.2/0.3
	printl 0.2-0.3
	printl 0.2<0.3
	printl 0.2>0.3
	a=99.2*20
	printl a
	printl(-2)
}

//逻辑运算测试
void test2()
{
	printl 0&&0
	printl 1&&0
	printl 0&&1
	printl 1&&1
	printl 0||0
	printl 1||0
	printl 0||1
	printl 1||1
}

//自动类型转换测试
void test3()
{
	uint a=1
	int c=5
	printl a+sizeof(int)!=c
}

//64位运算测试
void test4()
{
	int64 a=9
	int64 b=3
	printl a/b
	printl a*b
	printl a%b
	printl a-b
	printl a<b
	printl a>b
}

void test5()
{
	if (2)==2
		printl('ok',,,)
}

void test6()
{
	printl ORM[1,2]
	printl ORM[1,2,4,8]
	printl ORM[1]
}﻿/*
仅用位运算实现加减乘除，面试专用
*/

void main()
{
	fadd(1,2).printl
	fadd(19,29999).printl

	fsub(-1,3).printl
	fsub(19,2345).printl

	fmul(99,98).printl
	fmul(-29,235).printl

	fdiv(99,98).printl
	fdiv(9,3).printl
	fdiv(-9,3).printl
	fdiv(8,3).printl
}

int fadd(int x,int y)
{
	for
		a=AND(x,y)
		b=XOR(x,y)
		x=SHL(a,1)
		y=b
		ifn a
			break
	return b
}

int fneg(int x)
{
	return fadd(NOT(x),1)
}

int fsub(int x,int y)
{
	return fadd(x,fneg(y))
}

int fmul(int x,int y)
{
	m=1
	z=0
	if x<0
		x=fneg(x)
		y=fneg(y)
	for x>=m&&y
		if AND(x,m)
			z=fadd(y,z)
		y=SHL(y,1)
		m=SHL(m,1)
	return z
}

int fdiv(int x,int y)
{
	c=0
	sign=0
	if x<0
		x=fneg(x)
		sign=XOR(sign,1)
	if y<0
		y=fneg(y)
		sign=XOR(sign,1)
	if y
		for x>=y
			x=fsub(x,y)
			c=fadd(c,1)
	if sign
		c=fneg(c)
	return c
}﻿/*
全排列的非递归实现，支持去掉重复
*/

void main()
{
	rbuf<int> v
	#v.push(1,2,3,4)
	for
		v.join('').printl
		ifn next_permutation<int>(v)
			break
}

bool next_permutation<T>(rbuf<T>& v)
{
	if v.count<=1
		return false
	next=v.count-1
	for
		temp=next
		next--
		if v[next]<v[temp]
			mid=v.count-1
			for !(v[next]<v[mid])
				mid--
			r_swap<T>(v[next],v[mid])
			r_reverse<T>(v,temp)
			return true
		if next==0
			r_reverse<T>(v,0)
			return false
}﻿/*
KMP算法
*/

void main()
{
	printl(find('abc123','c1'))
	printl(find('abc123','c2'))
}

int find(rstr s,rstr p)
{
	next=get_next(p)
	i=0
	j=0
	for i<s.count&&j<p.count
		if j==-1||s[i]==p[j]
			i++
			j++
		else
			j=next[j]
	if j==p.count
		return i-j
	return -1
}

rbuf<int> get_next(rstr p)
{
	rbuf<int> next(p.count)
	next[0]=-1
	k=-1
	j=0
	for j<p.count-1
		if k==-1||p[j]==p[k]
			j++
			k++
			if p[j]!=p[k]
				next[j]=k
			else
				next[j]=next[k]
		else
			k=next[k]
	return next
}﻿/*
50行代码实现正则引擎，参考《代码之美》，可以轻松解决95％的正则问题

c 匹配任意的字母c 
.（句点） 匹配任意的单个字符 
^ 匹配输入字符串的开头 
$ 匹配输入字符串的结尾 
* 匹配前一个字符的零个或者多个出现
*/

void main()
{
	printl match('.*txt','2343txt')
	printl match('t.t','2343txt')
}

bool match(rstr reg,rstr text)
{
	if reg.get(0)==r_char('^')
		return match_here(reg.sub(1),text)
	for
		if match_here(reg,text)
			return true
		if text.empty
			return false
		text=text.sub(1)
}

bool match_here(rstr reg,rstr text)
{
	if reg.empty
		return true
	if reg.get(1)==r_char('*')
		return match_star(reg.get(0),reg.sub(2),text)
	if reg.get(0)==r_char('$')&&reg.sub(1).empty
		return text.empty
	if !text.empty&&(reg.get(0)==r_char('.')||reg.get(0)==text.get(0))
		return match_here(reg.sub(1),text.sub(1))
	return false
}

bool match_star(char c,rstr reg,rstr text)
{
	for
		if match_here(reg,text)
			return true
		ifn !text.empty&&(text.get(0)==c||c==r_char('.'))
			return false
		text=text.sub(1)
}﻿/*
栈排序与栈颠倒
*/

void main()
{
	rbuf<int> stack
	#stack.push(3,4,1,9,10,2)
	out(stack)
	func(stack)
	out(stack)
	reverse(stack)
	out(stack)
	sort(stack)
	out(stack)
}

void out(rbuf<int>& stack)
{
	for i=0;i<stack.count;i++
		printl(stack[i])
	printl
}

void sort(rbuf<int>& stack)
{
	if stack.empty
		return
	a=stack.pop
	if stack.empty
		stack.push(a)
		return
	sort(stack)
	b=stack.pop
	if a<b
		stack.push(a)
		sort(stack)
		stack.push(b)
	else
		stack.push(b)
		sort(stack)
		stack.push(a)
}

void func(rbuf<int>& stack)
{
	if stack.count<=1
		return
	a=stack.pop
	func(stack)
	b=stack.pop
	if a<b
		stack.push(a)
		func(stack)
		stack.push(b)
	else
		stack.push(b)
		stack.push(a)
}

void reverse(rbuf<int>& stack)
{
	if stack.count<=1
		return
	a=stack.pop
	reverse(stack)
	b=stack.pop
	reverse(stack)
	stack.push(a)
	reverse(stack)
	stack.push(b)
}﻿/*
组合遍历
*/

void main()
{
	n=7
	sum=0
	for i=0;i<n;i++
		for j=i+1;j<n;j++
			for k=j+1;k<n;k++
				sum++
	printl(sum)

	printl(A(3,6))
	printl(A(6,6))
	printl(C(3,7))
}

int A(int a,int b)
{
	temp=1
	for i=0;i<a;i++
		temp*=b-i
	return temp
}

int C(int a,int b)
{
	return A(a,b)/A(a,a)
} ﻿/*
递归求和
举例说明控制结构（if/for/while）如何省略小括号

sum1和sum2两个函数功能完全相同
sum2省略了语句后面的分号和if后面的小括号

如果函数调用的右边没有小括号，
则本行后面所有单词均作为函数的参数
即 
printl sum1(9) 
与
printl(sum1(9))
是一样的

rush里没有函数声明，直接调用即可
*/

void main()
{
	printl(sum1(9))
	printl sum2(9)
	printl sum1 9
}

int sum1(int a)
{
	if(a<=1) 
		return 1;
	return sum1(a-1)+a;
}

int sum2(int a)
{
	if a<=1  
		return 1
	return sum2(a-1)+a
}﻿/*
rush支持各种花括号风格，
也支持类似python的控制结构省略花括号，
注意表达式过长折行的时候不能省略括号
*/

void main()
{
	if(1||
		2)
		printl "true"
		
	if 1
		printl 2
		printl 3
		
	if 1 {
		printl 2
		printl 3
	}
	
	if(1) 
	{
		printl(2);
		printl(3);
	}
	
	if 1 {printl(2);}

	func(1,
		2)

	func(1,2
		)
}

void func(int a,
	int b)
{
	printl a+b
}﻿/*
常量作为对象使用，只是编译器提供的一个语法糖

1.print
会替换为
int(1).print

"123"+"abc"
会替换为
rstr("123")+rstr("abc")

和C++一样，
类名后面接小括号表示生成临时对象
rstr("123")
会生成一个临时的rstr对象
int(1)
会生成一个临时的int对象

*/

void main()
{
	1.print
	"abc".printl
	("123"+"abc").printl
	printl "123"+"abc"
}﻿/*
负号运算符和反向赋值运算符
修改rinf/optr.txt可以DIY运算符及其优先级
*/

void main()
{
	int a
	int b
	
	a=-2
	a.printl

	a=(-2)
	a.printl

	a=neg 2
	a.printl
	
	2=>a=>b
	a.printl
	b.printl
}
﻿/*
无缝内联汇编
*/

void main()
{
	//printl esp 
#ifndef _RGPP
	1+2
	mov eax,ebx
	printl eax
	
	if(eax)
		printl "eax is not zero"
	else
		printl "eax is zero"
#else
	printl 3
	printl "eax is not zero"
#endif
}
﻿/*
可以把rush当做伪代码写，
下面就是《算法导论》开篇的插入排序代码
（由于rush数组从下标0开始而算法导论从1开始，故稍微修改了下）
*/

define ← =

void insertion_sort(rstr& a):
	for j=1;j<a.count;j++
		key ← a[j]
		i ← j-1
		while i>=0 && a[i]>key
			a[i+1] ← a[i]
			i ← i-1
		a[i+1] ← key

void main():
	rstr a="cab132"
	printl a
	insertion_sort a
	printl a
	﻿#pragma once

#include "yfind.h"

//增加局部变量和成员变量构造及析构
struct yadd
{
	static void add_local_and_memb(const tsh& sh,tfunc& tfi)
	{
		tclass& tci=*tfi.ptci;
		//增加局部变量构造和析构
		//注意增加的这些语句type为空
		tsent temp=add_local_init(sh,tfi);
		if(!temp.empty())
		{
			tfi.vsent.push_front(temp);
		}
		temp=add_local_free(sh,tfi);
		if(!temp.empty())
		{
			tfi.vsent.push(temp);
		}
		ybase::part_vsent(tfi);
		if(tconf::c_auto_addinit)
		{
			if(tci.name==rskey(c_main)&&tfi.name==rskey(c_main))
			{
				add_member_struct(sh,tfi);	
				add_member_destruct(sh,tfi);//全局变量在main中构造和析构
			}
			elif(tfi.name==tci.name&&
				tfi.retval.type==rskey(c_void)&&
				!tfi.is_friend)
			{
				add_member_struct(sh,tfi);	
			}
			elif(yfind::is_destruct(sh,tfi))
			{
				add_member_destruct(sh,tfi);
			}
		}
	}

	static tsent add_local_free(const tsh& sh,tfunc& tfi)
	{
		tsent sent;
		sent.pos=tfi.pos;
		for(int i=0;i<tfi.param.count();i++)
		{
			add_destructor_func(sh,*tfi.ptci,tfi.param[i],sent.vword,false);
		}
		for(int i=0;i<tfi.local.count();i++)
		{
			ifn(is_temp_var(sh,tfi.local[i].name))
			{
				add_destructor_func(sh,*tfi.ptci,tfi.local[i],sent.vword,false);
			}
		}
		return r_move(sent);
	}

	static tsent add_local_init(const tsh& sh,tfunc& tfi)
	{
		tsent sent;
		sent.pos=tfi.pos;
		for(int i=0;i<tfi.local.count();i++)
		{
			if(!is_temp_var(sh,tfi.local[i].name)&&tfi.local[i].off!=-1)
			{
				add_structor_func(sh,tfi.local[i],sent.vword);
			}
		}
		return r_move(sent);
	}

	static void add_structor_func(const tsh& sh,const tdata& tdi,rbuf<tword>& v)
	{
		if(ybase::is_quote(tdi.type))
		{
			return;
		}
		if(tconf::c_op_empty_func&&yfind::is_empty_struct_type(sh,tdi.type))
		{
			return;
		}
		v+=rsoptr(c_mbk_l);
		v+=tdi.type;
		v+=rsoptr(c_comma);
		v+=tdi.type;
		v+=rsoptr(c_comma);
		v+=rsoptr(c_mbk_l);
		v+=tdi.name;
		v+=rsoptr(c_mbk_r);
		v+=rsoptr(c_mbk_r);
		v+=rsoptr(c_semi);
	}

	static void add_destructor_func(const tsh& sh,const tclass& tci,const tdata& tdi,
		rbuf<tword>& v,bool is_memb)
	{
		if(ybase::is_quote(tdi.type))
		{
			return;
		}
		if(tconf::c_op_empty_func&&yfind::is_empty_struct_type(sh,tdi.type))
		{
			return;
		}
		v+=rsoptr(c_mbk_l);
		v+=tdi.type;
		v+=rsoptr(c_comma);
		v+=rsoptr(c_destruct)+tdi.type;
		v+=rsoptr(c_comma);
		v+=rsoptr(c_mbk_l);
		if(is_memb)
		{
			v+=rsoptr(c_mbk_l);
			v+=rsoptr(c_dot);
			v+=rsoptr(c_comma);
			if(tci.name==rskey(c_main))
			{
				v+=rskey(c_pmain);
			}
			else
			{
				v+=rskey(c_this);
			}
			v+=rsoptr(c_comma);
			v+=tdi.name;
			v+=rsoptr(c_mbk_r);
		}
		else
		{
			v+=tdi.name;
		}
		v+=rsoptr(c_mbk_r);
		v+=rsoptr(c_mbk_r);
		v+=rsoptr(c_semi);
	}

	static void add_structor_func_m(const tsh& sh,const tclass& tci,const tdata& tdi,rbuf<tword>& v)
	{
		if(ybase::is_quote(tdi.type))
		{
			return;
		}
		if(tdi.param.empty()&&tconf::c_op_empty_func&&
			yfind::is_empty_struct_type(sh,tdi.type))
		{
			return;
		}
		v.push(tword(tdi.type));
		v.push(tword(rsoptr(c_dot)));
		v.push(tword(tdi.type));
		v.push(tword(rsoptr(c_sbk_l)));
		if(tci.name==rskey(c_main))
		{
			v+=tword(rskey(c_pmain));
		}
		else
		{
			v+=tword(rskey(c_this));
		}
		v+=tword(rsoptr(c_dot));
		v.push(tword(tdi.name));
		if(!tdi.param.empty())
		{
			v.push(tword(rsoptr(c_comma)));
			v+=tdi.param;
		}
		v.push(tword(rsoptr(c_sbk_r)));
		v.push(tword(rsoptr(c_semi)));
	}

	static void add_member_destruct(const tsh& sh,tfunc& tfi)
	{
		tclass& tci=*tfi.ptci;
		tsent sent;
		sent.pos=tfi.pos;
		sent.type=rskey(c_void);
		for(int i=tci.vdata.count()-1;i>=0;i--)
		{
			if(ybase::is_quote(tci.vdata[i].type))
			{
				continue;
			}
			tclass* ptci=yfind::class_search(sh,tci.vdata[i].type);
			if(null==ptci)
			{
				continue;
			}
			if(yfind::destruct_search(*ptci)==null)
			{
				continue;
			}
			add_destructor_func(sh,tci,tci.vdata[i],sent.vword,true);
		}
		if(!sent.vword.empty())
		{
			tfi.vsent.push_move(sent);
			ybase::part_vsent(tfi.vsent);
		}
	}

	static void add_member_struct(const tsh& sh,tfunc& tfi)
	{
		tclass& tci=*tfi.ptci;
		tsent sent;
		sent.type=rskey(c_void);
		for(int i=0;i<tci.vdata.count();i++)
		{
			if(ybase::is_quote(tci.vdata[i].type))
			{
				continue;
			}
			tclass* ptci=yfind::class_search(sh,tci.vdata[i].type);
			if(null==ptci)
			{
				continue;
			}
			if(yfind::emptystruct_search(*ptci)==null)
			{
				continue;
			}
			add_structor_func_m(sh,tci,tci.vdata[i],sent.vword);
		}
		if(sent.vword.empty())
		{
			return;
		}
		sent.pos=tfi.pos;
		tfi.vsent.push_front(r_move(sent));
		ybase::part_vsent(tfi.vsent);
	}

	static rbool is_temp_var(const tsh& sh,const rstr& name)
	{
		return name.sub(0,rskey(c_temp).count())==rskey(c_temp);
	}
};
﻿#pragma once

#include "yfind.h"

//自动增加类成员函数
struct yautof
{
	static rbool auto_add_func(const tsh& sh,tclass& tci)
	{
		if(!tconf::c_auto_addfunc)
		{
			return true;
		}
		if(ybase::is_basic_type(sh,tci.name)||
			tci.is_friend)
		{
			return true;
		}
		rbool added=false;
		tpos pos;
		pos.line=1;
		pos.file=null;
		if(!tci.vfunc.empty())
		{
			pos=tci.vfunc.begin()->pos;
		}
		if(yfind::destruct_search(tci)==null)
		{
			tfunc tfi;
			tfi.ptci=&tci;
			tfi.pos=pos;
			tfi.name=rsoptr(c_destruct)+tci.name;

			tfi.param.push(tdata(tci.name+rsoptr(c_addr),rskey(c_this)));
			tfi.retval=tdata(rskey(c_void),rstr());

			tfi.name_dec=tfi.get_dec();
			tci.vfunc.insert(tfi);
			added=true;
		}
		if(yfind::emptystruct_search(tci)==null)
		{
			tfunc tfi;
			tfi.ptci=&tci;
			tfi.pos=pos;

			tfi.name=tci.name;

			tfi.param.push(tdata(tci.name+rsoptr(c_addr),rskey(c_this)));
			tfi.retval=tdata(rskey(c_void),rstr());

			tfi.name_dec=tfi.get_dec();
			tci.vfunc.insert(tfi);
			added=true;
		}
		if(yfind::copystruct_search(tci)==null)
		{
			tfunc tfi;
			tfi.ptci=&tci;
			tfi.pos=pos;

			tfi.name=tci.name;

			tfi.param.push(tdata(tci.name+rsoptr(c_addr),rskey(c_this)));
			tfi.param.push(tdata(tci.name+rsoptr(c_addr),rskey(c_rvara)));
			tfi.retval=tdata(rskey(c_void),rstr());

			add_copy_sent(sh,tfi);
			tfi.name_dec=tfi.get_dec();
			tci.vfunc.insert(tfi);
			added=true;
		}
		if(add_copystruct_func(sh,tci))
		{
			added=true;
		}
		if(yfind::func_search(tci,rsoptr(c_equal),tci.name+rsoptr(c_addr),
			tci.name+rsoptr(c_addr))==null)
		{
			tfunc tfi;
			tfi.ptci=&tci;
			tfi.pos=pos;

			tfi.name=rsoptr(c_equal);

			tfi.param.push(tdata(tci.name+rsoptr(c_addr),rskey(c_this)));
			tfi.param.push(tdata(tci.name+rsoptr(c_addr),rskey(c_rvara)));
			tfi.retval=tdata(rskey(c_void),rstr());

			add_copy_sent(sh,tfi);
			tfi.name_dec=tfi.get_dec();
			tci.vfunc.insert(tfi);
			added=true;
		}
		if(yfind::func_search(tci,rsoptr(c_equal),
			tci.name+rsoptr(c_addr),tci.name)==null)
		{
			tfunc tfi=*yfind::func_search(
				tci,rsoptr(c_equal),tci.name+rsoptr(c_addr),
				tci.name+rsoptr(c_addr));
			tfi.ptci=&tci;
			tfi.param[1].type=tci.name;
			tfi.name_dec=tfi.get_dec();
			tci.vfunc.insert(tfi);
			added=true;
		}
		if(yfind::func_search(tci,rsoptr(c_addr))==null)
		{
			tfunc tfi;
			tfi.ptci=&tci;
			tfi.pos=pos;

			tfi.name=rsoptr(c_addr);

			tfi.param.push(tdata(tci.name+rsoptr(c_addr),rskey(c_this)));
			tfi.retval=tdata("rp<"+tci.name+">",rskey(c_s_ret));

			tword twi;
			twi.pos=tfi.pos;
			if(sh.m_mode==tsh::c_gpp)
			{
				//todo:
				tfi.is_final=true;
				ybase::push_twi(tfi.vword,twi,"return");
				ybase::push_twi(tfi.vword,twi,"&");
				ybase::push_twi(tfi.vword,twi,rskey(c_this));
				ybase::push_twi(tfi.vword,twi,";");
			}
			else
			{
				ybase::push_twi(tfi.vword,twi,rskey(c_mov));
				ybase::push_twi(tfi.vword,twi,rskey(c_s_ret));
				ybase::push_twi(tfi.vword,twi,rsoptr(c_comma));
				ybase::push_twi(tfi.vword,twi,rskey(c_this));
			}
			tfi.name_dec=tfi.get_dec();
			if(yfind::is_class(sh,tfi.retval.type))
			{
				tci.vfunc.insert(tfi);
			}
			added=true;
		}
		return true;
	}

	static rbool add_copystruct_func(const tsh& sh,tclass& tci)
	{
		rbuf<tfunc> temp;
		for(tfunc* p=tci.vfunc.begin();p!=tci.vfunc.end();p=tci.vfunc.next(p))
		{
			if(tci.name!=p->name)
			{
				continue;
			}
			if(p->param.count()<2)
			{
				continue;
			}
			int i;
			for(i=0;i<p->param.count();i++)
			{
				ifn(ybase::is_quote(p->param[i].type))
				{
					break;
				}
			}
			if(i<p->param.count())
			{
				continue;
			}
			tfunc* q;
			for(q=tci.vfunc.begin();q!=tci.vfunc.end();q=tci.vfunc.next(q))
			{
				if(q->name!=p->name||q->param.count()!=p->param.count())
				{
					continue;
				}
				ifn(ybase::is_quote(q->param.get(0).type))
				{
					continue;
				}
				int j;
				for(j=1;j<q->param.count();j++)
				{
					if(ybase::is_quote(q->param[j].type))
					{
						break;
					}
					if(ybase::get_tname(p->param[j].type)!=q->param[j].type)
					{
						break;
					}
				}
				if(j>=q->param.count())
				{
					break;
				}
			}
			if(q!=tci.vfunc.end())
			{
				continue;
			}
			tfunc tfi=*p;
			tfi.ptci=&tci;
			for(int i=1;i<tfi.param.count();i++)
			{
				tfi.param[i].type=ybase::get_tname(tfi.param[i].type);
			}
			tfi.name_dec=tfi.get_dec();
			temp.push(tfi);
		}
		for(int k=0;k<temp.count();k++)
		{
			tci.vfunc.insert(temp[k]);
		}
		return !temp.empty();
	}

	static void add_copy_sent(const tsh& sh,tfunc& tfi)
	{
		tclass& tci=*tfi.ptci;
		tword twi;
		twi.pos=tfi.pos;
		for(int i=0;i<tci.vdata.count();i++)
		{
			if(ybase::is_basic_type(sh,tci.vdata[i].type)||
				ybase::is_quote(tci.vdata[i].type))
			{
				continue;
			}
			ybase::push_twi(tfi.vword,twi,rskey(c_this));
			ybase::push_twi(tfi.vword,twi,rsoptr(c_dot));
			ybase::push_twi(tfi.vword,twi,tci.vdata[i].name);
			ybase::push_twi(tfi.vword,twi,rsoptr(c_equal));
			ybase::push_twi(tfi.vword,twi,rskey(c_rvara));
			ybase::push_twi(tfi.vword,twi,rsoptr(c_dot));
			ybase::push_twi(tfi.vword,twi,tci.vdata[i].name);
			ybase::push_twi(tfi.vword,twi,rsoptr(c_semi));
		}
	}
};
﻿#pragma once

#include "../rlib/rf.h"
#include "../rlib/rdir.h"
#include "../struct/tbase.h"

struct ybase
{
	static void print_vclass(const tsh& sh)
	{
		for(tclass* p=sh.m_class.begin();p!=sh.m_class.end();p=sh.m_class.next(p))
		{
			p->name.printl();
		}
	}

	static void print_vword(const rbuf<tword>& v)
	{
		rf::printl();
		for(int i=0;i<v.count();i++)
		{
			(v[i].val+" ").print();
		}
		rf::printl();
	}

	static void print_vstr(const rbuf<rstr>& v)
	{
		rf::printl();
		for(int i=0;i<v.count();i++)
		{
			(v[i]+" ").print();
		}
		rf::printl();
	}

	static void print_func_sent(const tfunc& tfi)
	{
		rf::printl();
		for(int i=0;i<tfi.vsent.count();i++)
		{
			//rf::print(tfi.vsent[i].type+" ");
			ifn(is_tag<tword>(tfi.vsent[i].vword))
			{
				rf::print("\t");
			}
			//rf::print(rstr(tfi.vsent[i].pos.line)+" ");
			rstr::join<rstr>(vword_to_vstr(tfi.vsent[i].vword)," ").printl();
		}
		rf::printl();
	}

	static void print_func_asm(const tfunc& tfi)
	{
		for(int i=0;i<tfi.vasm.count();i++)
		{
			rf::print(rstr(tfi.vasm[i].pos.line)+" ");
			rstr::join<rstr>(tfi.vasm[i].vstr," ").printl();
		}
		rf::printl();
	}

	static void print_func_dec(const tclass& tci)
	{
		for(tfunc* p=tci.vfunc.begin();p!=tci.vfunc.end();p=tci.vfunc.next(p))
		{
			get_func_declare(tci,*p).printl();
		}
	}

	static void error(rstr e=rstr())
	{
		rf::printl(e);
	}

	static void error(const tword& word,rstr e=rstr())
	{
		error(rstr("file: ")+get_file_name(word.pos.file)+
			rstr("\nline: ")+rstr(word.pos.line)+
			rstr("\nword: ")+word.val+rstr("\n")+e);
		error(get_src_str(word));
	}

	static void error(const tsent& sent,rstr e=rstr())
	{
		error(rstr("file: ")+get_file_name(sent.pos.file)+
			rstr("\nline: ")+rstr(sent.pos.line)+rstr("\n")+e);
		rstr::join<rstr>(vword_to_vstr(sent.vword)," ").printl();
		error(get_src_str(sent.vword.get_bottom()));
	}

	static void error(const tasm& oasm,rstr e=rstr())
	{
		error(rstr("file: ")+get_file_name(oasm.pos.file)+
			rstr("\nline: ")+rstr(oasm.pos.line)+rstr("\n")+e);
		oasm.vstr.print();
		rf::printl();
	}

	static void error(const tfunc& tfi,rstr e=rstr())
	{
		tclass* ptci=tfi.ptci;
		if(ptci==null)
		{
			return;
		}
		rf::printl(get_func_declare(*ptci,tfi));
		rf::printl(e);
	}

	static rstr vword_to_s(rbuf<tword>& v)
	{
		rstr s;
		for(int i=0;i<v.count();i++)
		{
			if(v.get(i-1).pos!=v[i].pos)
			{
				s+="\n";
			}
			s+=v[i].val+" ";
		}
		return s;
	}

	static rstr get_func_param_declare(const tfunc& tfi)
	{
		rstr s;
		for(int j=0;j<tfi.param.count();j++)
		{
			if(j!=0)
			{
				s+=",";
			}
			s+=tfi.param[j].type+" "+tfi.param[j].name;
		}
		return r_move(s);
	}

	static rstr get_func_declare(const tclass& tci,const tfunc& tfi)
	{
		rstr s;
		s+=tci.name+"."+tfi.name+"(";
		for(int j=0;j<tfi.param.count();j++)
		{
			if(j!=0)
			{
				s+=",";
			}
			s+=tfi.param[j].type;
		}
		s+=")";
		return r_move(s);
	}

	static rbuf<rstr> get_func_declare_lisp(const tsh& sh,const tclass& tci,const tfunc& tfi)
	{
		return get_func_declare_call(sh,tci,tfi).sub(1);
	}

	static rbuf<rstr> get_func_declare_call(const tsh& sh,const tclass& tci,const tfunc& tfi)
	{
		rbuf<rstr> ret;
		ret+=rskey(c_call);
		ret+=rsoptr(c_mbk_l);
		ret+=rsoptr(c_addr);
		ret+=rsoptr(c_comma);
		ret+=tci.name;
		ret+=rsoptr(c_comma);
		ret+=tfi.name_dec;
		ret+=rsoptr(c_mbk_r);
		return r_move(ret);
	}

	static void clear_word_val(rbuf<tword>& v,int begin,int end)
	{
		if(end>v.count())
		{
			end=v.count();
		}
		if(begin<0)
		{
			begin=0;
		}
		for(int i=begin;i<end;++i)
		{
			v[i].val.clear();
		}
	}

	static rstr get_main_name(const tsh& sh)
	{
		rstr name=sh.m_main_file;
		name=rdir::get_name(name);
		name=rdir::get_prev_dir(sh.m_main_file)+name.sub(
			0,name.count()-rdir::get_suffix(name).count()-1);
		return r_move(name);
	}

	static rstr get_ctype(const tsh& sh,const tword& word)
	{
		if(word.is_cint())
		{
			return rskey(c_int);
		}
		elif(word.is_cuint())
		{
			return rskey(c_uint);
		}
		elif(word.is_cdouble())
		{
			return rskey(c_double);
		}
		elif(word.is_cpoint())
		{
			return rstr("rp<void>");
		}
		elif(word.is_cstr())
		{
			return rstr("rp<char>");
		}
		else
		{
			return rstr();
		}
	}

	//获取类型名称，忽略引用
	static rstr get_tname(const rstr& s)
	{
		if(is_quote(s))
		{
			return s.sub(0,s.count()-1);
		}
		else
		{
			return s;
		}
	}

	static rstr get_ttype(rstr s)
	{
		if(is_point_quote(s))
		{
			return s;
		}
		return s+"&";
	}

	static rbool is_optr_func(const tsh& sh,const tfunc& tfi)
	{
		if(sh.m_optr.is_optr(tfi.name))
		{
			return true;
		}
		return tfi.name=="[]";
	}

	static rbool is_basic_type(const tsh& sh,const rstr& s)
	{
		return (s==rskey(c_rd8)||s==rskey(c_rd16)||
			s==rskey(c_rd32)||s==rskey(c_rd64)||
			s==rskey(c_rdp)||s==rskey(c_void));
	}

	static rbool is_point_quote(const rstr& s)
	{
		return is_quote(s)||is_point(s);
	}

	static rbool is_quote(const rstr& s)
	{
		return s.get_top()==r_char('&');
	}

	static rbool is_point(const rstr& s)
	{
		if(s.get_top()==r_char('*'))
		{
			return true;
		}
		return (s.count()>=5&&s[0]==r_char('r')&&s[1]==r_char('p')&&
			s[2]==r_char('<')&&s.get_top()==r_char('>'));
	}

	static void split_param(const tsh& sh,rbuf<tsent>& vsent,
		const rbuf<tword>& v,const tsent& src)
	{
		vsent.clear();
		rbuf<rbuf<tword> > vparam=comma_split<tword>(sh,v);
		for(int i=0;i<vparam.count();i++)
		{
			tsent sent;
			sent.pos=src.pos;
			sent.vword=r_move(vparam[i]);
			vsent.push_move(sent);
		}
	}

	static void split_param(const tsh& sh,rbuf<tsent>& vsent,const rbuf<tword>& v)
	{
		vsent.clear();
		rbuf<rbuf<tword> > vparam=comma_split<tword>(sh,v);
		for(int i=0;i<vparam.count();i++)
		{
			tsent sent;
			sent.vword=r_move(vparam[i]);
			vsent.push_move(sent);
		}
	}

	template<typename T>
	static rbuf<rbuf<T> > comma_split(const tsh& sh,rbuf<T> v)
	{
		rbuf<rbuf<T> > result;
		v.push_move(T(rsoptr(c_comma)));
		int count1=0;
		int count2=0;
		int start=0;
		for(int i=0;i<v.count();i++)
		{
			//大括号不可能出现在参数中
			if(v[i]==rsoptr(c_sbk_l))
			{
				count1++;
			}
			elif(v[i]==rsoptr(c_sbk_r))
			{
				count1--;
			}
			elif(v[i]==rsoptr(c_mbk_l))
			{
				count2++;
			}
			elif(v[i]==rsoptr(c_mbk_r))
			{
				count2--;
			}
			elif(count1==0&&count2==0&&
				v[i]==rsoptr(c_comma))
			{
				rbuf<T> item;
				for(int j=start;j<i;j++)
				{
					item.push_move(v[j]);
				}
				ifn(item.empty())
				{
					result.push_move(item);
				}
				start=i+1;
			}
		}
		return r_move(result);
	}

	//允许空元素
	static rbuf<rbuf<tword> > comma_split_e(const tsh& sh,rbuf<tword> v)
	{
		rbuf<rbuf<tword> > result;
		v.push(tword(rsoptr(c_comma)));
		int count1=0;
		int count2=0;
		int start=0;
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val==rsoptr(c_sbk_l))
			{
				count1++;
			}
			elif(v[i].val==rsoptr(c_sbk_r))
			{
				count1--;
			}
			elif(v[i].val==rsoptr(c_mbk_l))
			{
				count2++;
			}
			elif(v[i].val==rsoptr(c_mbk_r))
			{
				count2--;
			}
			elif(count1==0&&count2==0&&
				v[i].val==rsoptr(c_comma))
			{
				rbuf<tword> item;
				for(int j=start;j<i;j++)
				{
					item.push_move(v[j]);
				}
				result.push_move(item);
				start=i+1;
			}
		}
		return r_move(result);
	}

	//带尖括号的split
	static rbuf<tsent> comma_split_t(const tsh& sh,rbuf<tword> v)
	{
		rbuf<tsent> result;
		v.push(tword(rsoptr(c_comma)));
		int count1=0;
		int count2=0;
		int count3=0;
		int start=0;
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val==rsoptr(c_sbk_l))
			{
				count1++;
			}
			elif(v[i].val==rsoptr(c_sbk_r))
			{
				count1--;
			}
			elif(v[i].val==rsoptr(c_mbk_l))
			{
				count2++;
			}
			elif(v[i].val==rsoptr(c_mbk_r))
			{
				count2--;
			}
			elif(v[i].val==rsoptr(c_tbk_l))
			{
				count3++;
			}
			elif(v[i].val==rsoptr(c_tbk_r))
			{
				count3--;
			}
			elif(count1==0&&count2==0&&count3==0&&
				v[i].val==rsoptr(c_comma))
			{
				tsent item;
				for(int j=start;j<i;j++)
				{
					item.vword.push_move(v[j]);
				}
				ifn(item.vword.empty())
				{
					result.push_move(item);
				}
				start=i+1;
			}
		}
		return r_move(result);
	}

	static int find_symm_sbk(const tsh& sh,const rbuf<rstr>& v,int begin=0)
	{
		return find_symm_word_e<rstr>(v,rsoptr(c_sbk_l),
			rsoptr(c_sbk_r),begin);
	}

	static int find_symm_sbk(const tsh& sh,const rbuf<tword>& v,int begin=0)
	{
		return find_symm_word_e<tword>(v,rsoptr(c_sbk_l),
			rsoptr(c_sbk_r),begin);
	}

	static int find_symm_mbk(const tsh& sh,const rbuf<tword>& v,int begin=0)
	{
		return find_symm_word_e<tword>(v,rsoptr(c_mbk_l),
			rsoptr(c_mbk_r),begin);
	}

	static int find_symm_bbk(const tsh& sh,const rbuf<rstr>& v,int begin=0)
	{
		return find_symm_word_e<rstr>(v,rsoptr(c_bbk_l),
			rsoptr(c_bbk_r),begin);
	}

	static int find_symm_bbk(const tsh& sh,const rbuf<tword>& v,int begin=0)
	{
		return find_symm_word_e<tword>(v,rsoptr(c_bbk_l),
			rsoptr(c_bbk_r),begin);
	}

	static int find_symm_tbk(const tsh& sh,const rbuf<tword>& v,int begin=0)
	{
		return find_symm_word_e<tword>(v,rsoptr(c_tbk_l),
			rsoptr(c_tbk_r),begin);
	}

	//未找到返回结束位置，应该判断count<0，但那样会降低效率
	template<typename T>
	static int find_symm_word_e(const rbuf<T>& v,const rstr& left,const rstr& right,
		int begin=0)
	{
		int end=v.count();
		if(begin<0)
		{
			begin=0;
		}
		int count=0;
		int i;
		for(i=begin;i<end;i++)
		{
			if(left==v[i])
			{
				++count;
			}
			if(right==v[i])
			{
				--count;
			}
			if(0==count)
			{
				return i;
			}
		}
		return v.count();
	}

	static int find_symm_word_rev(const rbuf<tword>& v,const rstr& left,const rstr& right,
		int begin,int end)
	{
		if(end>=v.count())
		{
			end=v.count();
		}
		if(begin<0)
		{
			begin=0;
		}
		int count=0;
		int i;
		for(i=end-1;i>=begin;--i)
		{
			if(left==v[i].val)
			{
				--count;
			}
			if(right==v[i].val)
			{
				++count;
			}
			if(0==count)
			{
				return i;
			}
		}
		return v.count();
	}

	static rbuf<rstr> vword_to_vstr(const rbuf<tword>& v)
	{
		rbuf<rstr> ret(v.count());
		for(int i=0;i<v.count();i++)
		{
			ret[i]=v[i].val;
		}
		return r_move(ret);
	}

	static void push_twi(rbuf<tword>& v,tword& twi,const rstr& val)
	{
		twi.val=val;
		v.push(twi);
	}

	static rstr get_file_name(const tfile* p)
	{
		if(p==null)
		{
			return rstr();
		}
		return p->name.torstr();
	}

	static rstr get_src_str(const tword& word)
	{
		tpos pos=word.pos;//pos_src;
		if(pos.file==null)
		{
			return rstr();
		}
		rstr ret;
		ret+="\nsrc_file: "+pos.file->name.torstr();
		ret+="\nsrc_line: "+rstr(pos.line);
		ret+="\nsrc_cont: "+pos.file->line_list.get(pos.line);
		ret+="\n";
		return r_move(ret);
	}

	static rbool need_arrange(const rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].empty())
			{
				return true;
			}
			elif(v[i].is_multi())
			{
				return true;
			}
		}
		return false;
	}

	//返回是否需要重排
	static rbool arrange(rbuf<tword>& src)
	{
		if(!need_arrange(src))
		{
			return false;
		}
		rbuf<tword> wlist(src.count()*2);
		wlist.m_count=0;
		for(int i=0;i<src.count();i++)
		{
			if(src[i].empty())
			{
				continue;
			}
			elif(src[i].is_multi())
			{
				for(int j=0;j<src[i].multi.count();++j)
				{
					tword word;
					word.val=r_move(src[i].multi[j]);
					word.pos=src[i].pos;
					ifn(word.val.empty())
					{
						wlist.push_move(word);
					}
				}
			}
			else
			{
				wlist.push_move(src[i]);
			}
		}
		src=r_move(wlist);
		return true;
	}

	static rbool part_vsent(tfunc& tfi)
	{
		return part_vsent(tfi.vsent);
	}

	static rbool part_vsent(rbuf<tsent>& vsent)
	{
		ifn(need_part(vsent))
		{
			return false;
		}
		rbuf<tsent> result(vsent.count()*2);
		result.m_count=0;
		for(int i=0;i<vsent.count();++i)
		{
			rbuf<rbuf<tword> > v=r_split_a<tword>(
				vsent[i].vword,tword(rstr(";")));
			if(v.empty())
			{
				continue;
			}
			tsent sent;
			sent.pos=vsent[i].pos;
			for(int j=0;j<v.count();j++)
			{
				sent.vword=r_move(v[j]);
				ifn(sent.vword.empty())
				{
					result.push_move(sent);
				}
			}
		}
		vsent=r_move(result);
		return true;
	}

	static rbool need_part(const rbuf<tsent>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].vword.count()==0)
			{
				return true;
			}
			for(int j=0;j<v[i].vword.count();j++)
			{
				if(v[i].vword[j].val==rstr(";"))
				{
					return true;
				}
			}
		}
		return false;
	}

	static rstr get_rs_dir()
	{
		return rdir::get_prev_dir(rdir::get_exe_dir());
	}

	static void init_path(rbuf<rstr>& vpath)
	{
		vpath+=get_rs_dir()+"src/rlib/";
		vpath+=get_rs_dir()+"src/";
	}

	static void init_match(rbuf<top_node>& result)
	{
		tasm src;
		tasm dst;
		top_node item;

		item.src+=tasm(rf::vstr("sub","esp",",","4"));
		item.src+=tasm(rf::vstr("push","@n"));
		item.src+=tasm(rf::vstr("push","[","@@","+","@n","]"));
		item.src+=tasm(rf::vstr("call","[","&",",","int",",","<=(int,int)","]"));
		item.src+=tasm(rf::vstr("mov","ebx",",","[","esp","]"));
		item.src+=tasm(rf::vstr("add","esp",",","4"));

		item.dst+=tasm(rf::vstr("clesb","[","@1","+","@2","]",",","@0"));
		result+=item;

		item.clear();

		item.src+=tasm(rf::vstr("push","@n"));
		item.src+=tasm(rf::vstr("lea","esi",",","[","@@","+","@n","]"));
		item.src+=tasm(rf::vstr("push","esi"));
		item.src+=tasm(rf::vstr("call","[","&",",","int",",","=(int&,int)","]"));

		item.dst+=tasm(rf::vstr("mov","[","@1","+","@2","]",",","@0"));
		result+=item;

		item.clear();

		item.src+=tasm(rf::vstr("push","[","@@","+","@n","]"));
		item.src+=tasm(rf::vstr("lea","esi",",","[","@@","+","@n","]"));
		item.src+=tasm(rf::vstr("push","esi"));
		item.src+=tasm(rf::vstr("call","[","&",",","int",",","+=(int&,int)","]"));

		item.dst+=tasm(rf::vstr("add","[","@2","+","@3","]",",","[","@0","+","@1","]"));
		result+=item;

		item.clear();

		item.src+=tasm(rf::vstr("lea","esi",",","[","@@","+","@n","]"));
		item.src+=tasm(rf::vstr("push","esi"));
		item.src+=tasm(rf::vstr("call","[","&",",","int",",","++(int&)","]"));

		item.dst+=tasm(rf::vstr("add","[","@0","+","@1","]",",","1"));
		result+=item;

		item.clear();

		item.src+=tasm(rf::vstr("push","[","@@","+","@n","]" ));
		item.src+=tasm(rf::vstr("push","[","@@","+","@n","]" ));
		item.src+=tasm(rf::vstr("call","[","&",",","int",",","+(int,int)","]"));

		item.dst+=tasm(rf::vstr("mov","[","esp","]",",","[","@2","+","@3","]"));
		item.dst+=tasm(rf::vstr("add","[","esp","]",",","[","@0","+","@1","]"));
		result+=item;
	}

	static rstr del_quote(rstr s)
	{
		if(s.get_bottom()==r_char('\"'))
		{
			return s.sub(1,s.count()-1);
		}
		return r_move(s);
	}

	static rstr add_quote(const rstr& s)
	{
		return "\""+s+"\"";
	}

	static int get_word_tab(tword& word)
	{
		tpos pos=word.pos;//pos_src;
		if(pos.file==null)
		{
			rserror("pos file null");
			return -1;
		}
		if(pos.line>=pos.file->tab_list.count())
		{
			rserror("pos file null");
			return -1;
		}
		return pos.file->tab_list[pos.line];
	}

	static rbool is_bbk_prev(const tsh& sh,const rstr& s)
	{
		return (s==rsoptr(c_comma)||s==rsoptr(c_equal)||
			s==rsoptr(c_sbk_l)||s==rsoptr(c_mbk_l)||s==rsoptr(c_bbk_l));
	}

	static rbool is_jmp_ins(int type)
	{
		return type==tkey::c_jmp||type==tkey::c_jebxz||type==tkey::c_jebxnz;
	}

	template<typename T>
	static rbool is_tag(const rbuf<T>& v)
	{
		return v.count()==2&&v[1]==rstr(":");
	}
};
﻿#pragma once

#include "yfind.h"

//提取所有类
//m_file.vword->m_class.vword
struct yclass
{	
	static rbool process(tsh& sh)
	{
		basic_type_add(sh);
		for(tfile* p=sh.m_file.begin();p!=sh.m_file.end();p=sh.m_file.next(p))
		{
			if(!extract_class(sh,p->vword))
			{
				return false;
			}
		}
		main_add(sh);
		for(tfile* p=sh.m_file.begin();p!=sh.m_file.end();p=sh.m_file.next(p))
		{
			if(!proc_class_again(sh,p->vword))
			{
				return false;
			}
		}
		if(!inherit_proc_all(sh))
		{
			return false;
		}
		for(tfile* p=sh.m_file.begin();p!=sh.m_file.end();p=sh.m_file.next(p))
		{
			p->cont.m_buf.free();
			p->vword.free();
		}
		return true;
	}

	static void main_add(tsh& sh)
	{
		sh.m_main=yfind::class_search(sh,rskey(c_main));
		if(sh.m_main==null)
		{
			tclass item;
			item.name=rskey(c_main);
			sh.m_class.insert(item);
			sh.m_main=yfind::class_search(sh,rskey(c_main));	
		}
		sh.m_main->is_friend=true;
	}

	static rbool proc_class_again(tsh& sh,const rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			sh.m_main->vword.push(v[i]);
		}
		return true;
	}

	static rbool name_part(const tsh& sh,tclass& tci,rbuf<tword>& name_w)
	{
		rbuf<tword> father;
		int colonpos=r_find_a<tword>(name_w,tword(rsoptr(c_colon)));
		if(colonpos<name_w.count())
		{
			for(int i=colonpos+1;i<name_w.count();i++)
			{
				father.push(name_w[i]);
			}
			if(father.empty())
			{
				rserror(tci.vword.get(0),"empty father");
				return false;
			}
			name_w.erase(colonpos,name_w.count());
			tci.vfather=ybase::comma_split_t(sh,father);
		}
		int pos=r_find_a<tword>(name_w,tword(rsoptr(c_tbk_l)));
		if(pos<name_w.count())
		{
			rstr temp;
			for(int i=pos+1;i<name_w.count()-1;i++)
			{
				temp+=name_w[i].val;
			}
			rbuf<rstr> result=r_split<rstr>(temp,rsoptr(c_comma));
			if(result.empty())
			{
				rserror(tci.vword.get(0),"template >error");
				return false;
			}
			for(int i=0;i<result.count();i++)
			{
				ttl item;
				int epos=r_find<rstr>(result[i],rsoptr(c_equal));
				for(int j=0;j<epos;j++)
				{
					item.name+=result[i][j];
				}
				if(item.name.empty())
				{
					rserror(tci.vword.get(0),"empty template");
					return false;
				}
				for(int j=epos+1;j<result[i].count();j++)
				{
					item.val+=result[i][j];
				}
				tci.vtl.push(item);
			}
		}
		for(int i=0;i<pos;i++)
		{
			tci.name+=name_w[i].val;
		}
		if(tci.name.empty())
		{
			rserror(tci.vword.get(0),"empty class name");
			return false;
		}
		return true;
	}

	static rbool proc_cpp_tl(const tsh& sh,rbuf<tword>& v,int i,rbuf<tword>& name_w)
	{
		int right=i-1;
		if(v.get(right)!=rsoptr(c_tbk_r))
		{
			return true;
		}
		int left=ybase::find_symm_word_rev(v,rsoptr(c_tbk_l),rsoptr(c_tbk_r),0,i);
		if(left>=v.count())
		{
			return true;
		}
		if(v.get(left-1)!=rskey(c_template))
		{
			return true;
		}
		rbuf<rbuf<tword> > vparam;
		vparam=ybase::comma_split<tword>(sh,v.sub(left+1,right));
		if(vparam.empty())
		{
			return true;
		}
		
		for(int j=0;j<vparam.count();j++)
		{
			if(vparam[j].get(0)==rskey(c_typename))
			{
				vparam[j].pop_front();
			}
		}
		rbuf<tword> vtl;
		vtl+=rsoptr(c_tbk_l);
		for(int j=0;j<vparam.count();j++)
		{
			if(j!=0)
			{
				vtl+=rsoptr(c_comma);
			}
			vtl+=vparam[j];
		}
		vtl+=rsoptr(c_tbk_r);
		name_w.insert(1,vtl);
		for(int j=left-1;j<i;j++)
		{
			v[j].clear();
		}
		return true;
	}

	static rbool extract_class(tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val!=rskey(c_class))
			{
				continue;
			}
			if(v.get(i+2)==rsoptr(c_semi)&&v.get(i+1).is_name())
			{
				ybase::clear_word_val(v,i,i+3);
				continue;
			}
			int left=r_find_a<tword>(v,tword(rsoptr(c_bbk_l)),i+1);
			if(left>=v.count())
			{
				ybase::error(v.get(i),"miss {");
				return false;
			}
			tclass item;
			rbuf<tword> name_w;
			for(int j=i+1;j<left;j++)
			{
				name_w.push(v[j]);
			}
			if(name_w.empty())
			{
				rserror(v.get(i),"miss class name");
				return false;
			}
			proc_cpp_tl(sh,v,i,name_w);
			int right=ybase::find_symm_bbk(sh,v,left);
			if(right>=v.count())
			{
				rserror(v.get(i),"miss {");
				return false;
			}
			if(v.get(i-1).val==rskey(c_friend))
			{
				v[i-1].clear();
				item.is_friend=true;
			}
			for(int j=left+1;j<right;j++)
			{
				item.vword.push(v[j]);
			}
			for(int j=i;j<=right;j++)
			{
				v[j].clear();
			}
			ifn(class_add(sh,item,name_w))
			{
				return false;
			}
			i=right;
		}
		ybase::arrange(v);
		return true;
	}

	static rbool class_add(tsh& sh,tclass& tci,rbuf<tword>& name_w)
	{
		ifn(name_part(sh,tci,name_w))
		{
			return false;
		}
		if(yfind::is_class(sh,tci.name)||yfind::is_classtl(sh,tci.name))
		{
			rserror(name_w.get_bottom(),"type redefined");
			return false;
		}
		if(tci.vtl.empty())
		{
			sh.m_class.insert(tci);
		}
		else
		{
			sh.m_classtl.insert(tci);
		}
		return true;
	}

	static void insert_type(tsh& sh,const rstr& name,int size)
	{
		tclass item;
		item.name=name;
		item.size=size;
		if(!yfind::is_class(sh,item.name))
		{
			sh.m_class.insert(item);
		}
	}

	static void basic_type_add(tsh& sh)
	{
		insert_type(sh,rskey(c_void),0);
		insert_type(sh,rskey(c_rd8),1);
		insert_type(sh,rskey(c_rd16),2);
		insert_type(sh,rskey(c_rd32),4);
		insert_type(sh,rskey(c_rd64),8);
		insert_type(sh,rskey(c_rdp),sh.m_point_size);
	}

	static rbool inherit_proc_all(tsh& sh)
	{
		for(tclass* p=sh.m_class.begin();
			p!=sh.m_class.end();p=sh.m_class.next(p))
		{
			if(!inherit_proc(sh,*p))
			{
				return false;
			}
		}
		return true;
	}
	
	//模板继承模板如 A<T>:B<T>
	//模板继承非模板 A<T>:C,D
	//非模板继承非模板 E:C
	//模板实例暂时不能继承如 C:A<int>
	//如果定义同名函数会调用子类的函数，所以不要用覆盖和隐藏
	//后面自动生成构造、析构、拷贝构造、operator=不会继承，但用户定义的会继承
	static rbool inherit_proc(tsh& sh,tclass& tci,int level=0)
	{
		if(level>c_rs_deep)
		{
			rserror("inherit too deep");
			return false;
		}
		level++;
		if(tci.vfather.empty())
		{
			return true;
		}
		rbuf<tword> v;
		for(int i=0;i<tci.vfather.count();i++)
		{
			rstr cname=tci.vfather[i].vword.get(0).val;
			tclass* ptci=yfind::class_search(sh,cname);
			if(ptci==null)
			{
				ptci=yfind::classtl_search(sh,cname);
				if(ptci==null)
				{
					rserror("inherit can't find "+cname);
					return false;
				}
			}
			if(!inherit_proc(sh,*ptci,level))
			{
				return false;
			}
			v+=ptci->vword;
		}
		v+=tci.vword;
		tci.vword=r_move(v);
		return true;
	}
};
﻿#pragma once

#include "yfind.h"
#include "yconsteval.h"

//进行类模板替换，增加了一些新类
struct yclasstl
{
	static rbool process(tsh& sh)
	{
		rbuf<tclass*> vtmp;
		for(tclass* p=sh.m_class.begin();
			p!=sh.m_class.end();p=sh.m_class.next(p))
		{
			vtmp.push(p);
		}
		for(int i=0;i<vtmp.count();i++)
		{
			ifn(type_replace(sh,vtmp[i]->vword,0))
			{
				return false;
			}
		}
		vtmp.clear();
		for(tclass* p=sh.m_class.begin();
			p!=sh.m_class.end();p=sh.m_class.next(p))
		{
			vtmp.push(p);
		}
		for(int i=0;i<vtmp.count();i++)
		{
			ifn(add_point_declare(sh,*vtmp[i]))
			{
				return false;
			}
		}
		return true;
	}

	static rbool add_point_declare(tsh& sh,tclass& tci)
	{
		if(ybase::is_basic_type(sh,tci.name)||tci.is_friend||ybase::is_point(tci.name))
		{
			return true;
		}
		rbuf<tword> temp;
		temp+=rskey(c_rp);
		temp+=rsoptr(c_tbk_l);
		temp+=tci.name;
		temp+=rsoptr(c_tbk_r);
		if(!type_replace(sh,temp))
		{
			return false;
		}
		return true;
	}

	static rbool type_replace(tsh& sh,rbuf<tword>& v,int level=0)
	{
		if(level>c_rs_deep)
		{
			rserror("type level overflow");
			return false;
		}
		level++;
		rbool need=point_replace(sh,v);
		for(int i=1;i<v.count();i++)
		{
			if(v[i]!=rsoptr(c_tbk_l))
			{
				continue;
			}
			tclass* pctl=yfind::classtl_search(sh,v[i-1].val);
			if(pctl==null)
			{
				continue;
			}
			int left=i;
			int right=ybase::find_symm_tbk(sh,v,left);
			if(right>=v.count())
			{
				rserror(v[i-1],"miss >");
				return false;
			}
			rbuf<rbuf<tword> > vparam=ybase::comma_split<tword>(
				sh,v.sub(left+1,right));
			if(vparam.count()!=pctl->vtl.count())
			{
				rserror(v[i-1],"template not match");
				return false;
			}
			ifn(is_type(sh,vparam))
			{
				continue;
			}
			for(int j=left;j<=right;j++)
			{
				v[left-1].val+=v[j].val;
				v[j].val.clear();
			}
			i=right;
			if(yfind::is_class(sh,v[left-1].val))
			{
				continue;
			}
			tclass item=*pctl;
			item.name=v[left-1].val;
			item.vtl.clear();
			vtl_replace(item.vword,pctl->vtl,vparam);
			sh.m_class.insert(item);
			tclass* ptci=yfind::class_search(sh,item.name);
			if(ptci==null)
			{
				rserror(v.get(i),"can't find class "+item.name);
				return false;
			}
			ifn(type_replace(sh,ptci->vword,level))
			{
				return false;
			}
		}
		ybase::arrange(v);
		need=point_replace(sh,v);
		if(need)
		{
			if(!type_replace(sh,v,level))
			{
				return false;
			}
		}
		combine_quote(sh,v);
		ifn(yconsteval::op_const_exp(sh,v,false))
		{
			return false;
		}
		return true;
	}
	
	//类模板只能替换类型，否则与函数模板冲突
	static rbool is_type(const tsh& sh,const rbuf<rbuf<tword> >& vparam)
	{
		for(int i=0;i<vparam.count();i++)
		{
			ifn(is_type(sh,vparam[i]))
			{
				return false;
			}
		}
		return true;
	}

	static rbool is_type(const tsh& sh,const rbuf<tword>& v)
	{
		if(v.count()==1)
		{
			return yfind::is_class_t(sh,v[0].val);
		}
		if(v.count()<4)
		{
			return false;
		}
		if(v[1]!=rsoptr(c_tbk_l))
		{
			return false;
		}
		ifn(yfind::is_classtl(sh,v[0].val))
		{
			return false;
		}
		return is_type(sh,v.sub(2,v.count()-1));
		//v.count()==1&&v[0].val.is_number();//todo:
	}

	static void vtl_replace(rbuf<tword>& result,rbuf<ttl>& vtl,
		rbuf<rbuf<tword> >& vparam)
	{
		for(int j=0;j<vparam.count();j++)
		{
			str_replace(result,vtl[j].name,ybase::vword_to_vstr(vparam[j]));
		}
		ybase::arrange(result);
	}

	static void str_replace(rbuf<tword>& v,const rstr& src,const rbuf<rstr>& vstr)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val==src)
			{
				v[i].val.clear();
				v[i].multi=vstr;
			}
		}
	}

	//返回是否需要重排
	static rbool point_replace(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v.get(i+1).val!=rsoptr(c_mul)||
				!yfind::is_class(sh,v[i].val))
			{
				continue;
			}
			if(v.get(i+2).val==rsoptr(c_mul))
			{
				if(v.get(i+3)==rsoptr(c_sbk_l))
				{
					continue;
				}
				rbuf<tword> vword;
				tword word;
				word.pos=v[i].pos;
				ybase::push_twi(vword,word,rskey(c_rp));
				ybase::push_twi(vword,word,rsoptr(c_tbk_l));
				ybase::push_twi(vword,word,rskey(c_rp));
				ybase::push_twi(vword,word,rsoptr(c_tbk_l));
				ybase::push_twi(vword,word,v[i].val);
				ybase::push_twi(vword,word,rsoptr(c_tbk_r));
				ybase::push_twi(vword,word,rsoptr(c_tbk_r));
				v[i].multi=ybase::vword_to_vstr(vword);
				v[i].val.clear();
				v[i+1].val.clear();
				v[i+2].val.clear();
			}
			else
			{
				if(v.get(i+2)==rsoptr(c_sbk_l))
				{
					continue;
				}
				rbuf<tword> vword;
				tword word;
				word.pos=v[i].pos;
				ybase::push_twi(vword,word,rskey(c_rp));
				ybase::push_twi(vword,word,rsoptr(c_tbk_l));
				ybase::push_twi(vword,word,v[i].val);
				ybase::push_twi(vword,word,rsoptr(c_tbk_r));

				v[i].multi=ybase::vword_to_vstr(vword);
				v[i].val.clear();
				v[i+1].val.clear();
			}
		}
		return ybase::arrange(v);
	}

	static void combine_quote(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v.get(i+1).val==rsoptr(c_addr)&&
				yfind::is_class(sh,v[i].val))
			{
				for(int j=i+1;j<v.count();j++)
				{
					if(v[j].val!=rsoptr(c_addr))
					{
						break;
					}
					v[i].val+=v[j].val;
					v[j].clear();
				}
			}
			elif((v[i].val==rsoptr(c_dot)||v[i]==rsoptr(c_arrow_r))&&
				v.get(i+1).val==rsoptr(c_destruct)&&
				yfind::is_class(sh,v.get(i+2).val))
			{
				v[i+1].val+=v[i+2].val;
				v[i+2].clear();
			}
		}
		ybase::arrange(v);
	}
};
﻿#pragma once

#include "ybase.h"

//常量表达式优化
struct yconsteval
{
	static rbool op_const_exp(const tsh& sh,rbuf<tword>& v,rbool clear_sbk)
	{
		if(!tconf::c_op_const_eval)
		{
			return true;
		}
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val!=rsoptr(c_sbk_l))
			{
				continue;
			}
			int right=ybase::find_symm_sbk(sh,v,i);
			if(right>=v.count())
			{
				continue;
			}
			int pos=i+1;
			if(pos+1>=right)
			{
				continue;
			}
			ifn(is_const_str(sh,v,pos,right))
			{
				continue;
			}
			int dst;
			ifn(eval(sh,
				ybase::vword_to_vstr(v.sub(pos,right)),dst))
			{
				rserror(v[i],"const_eval");
				return false;
			}
			v[pos].val=rstr((uint)dst);
			ybase::clear_word_val(v,pos+1,right);
			if(clear_sbk)
			{
				v[i].val.clear();
				v[right].val.clear();
			}
		}
		ybase::arrange(v);
		return true;
	}

	static rbool eval(const tsh& sh,rbuf<rstr> src,int& dst,int level=0)
	{
		if(level>c_rs_deep)
		{
			rserror("const eval level overflow");
			return false;
		}
		level++;
		rbuf<rstr> soptr;
		rbuf<int> sopnd;
		soptr+=rsoptr(c_sharp_sharp);
		src+=rsoptr(c_sharp_sharp);
		for(int i=0;i<src.count();i++)
		{
			if(src[i]==rsoptr(c_sharp_sharp)&&
				soptr.get_top()==rsoptr(c_sharp_sharp))
			{
				break;
			}
			if(src[i].is_number())
			{
				int outopnd=src[i].toint();
				sopnd.push(outopnd);
			}
			elif(src[i]==rsoptr(c_sbk_l))
			{
				int right=ybase::find_symm_sbk(sh,src,i);
				if(right>=src.count())
				{
					rserror("const eval miss )");
					return false;
				}
				int outopnd;
				ifn(eval(sh,src.sub(i+1,right),outopnd,level))
				{
					return false;
				}
				sopnd.push(outopnd);
				i=right;
			}
			elif(sh.m_optr.is_optr(src[i]))
			{
				if(soptr.empty())
				{
					rserror("const eval miss soptr");
					return false;
				}
				rstr cur=src[i];
				if(!sh.m_optr.precede(soptr.top(),cur))
				{
					soptr.push(cur);
					continue;
				}
				rstr theta=soptr.pop();
				if(sopnd.empty())
				{
					rserror("const eval miss sopnd");
					return false;
				}
				int second=sopnd.pop();
				if(sopnd.empty())
				{
					if(theta==rsoptr(c_plus))
					{
					}
					elif(theta==rsoptr(c_minus))
					{
						second=-second;
					}
					else
					{
						rserror("const eval miss sopnd");
						return false;
					}
					sopnd.push(second);
					i--;
					continue;
				}
				int first=sopnd.pop();
				int outopnd;
				if(!calc(sh,first,second,theta,outopnd))
				{
					rserror("const eval calc error");
					return false;
				}
				sopnd.push(outopnd);
				i--;
			}
		}
		if(sopnd.count()!=1)
		{
			return false;
		}
		dst=sopnd[0];
		return true;
	}

	static rbool calc(const tsh& sh,int first,int second,const rstr& theta,int& outopnd)
	{
		if(theta==rsoptr(c_plus))
		{
			outopnd=first+second;
		}
		elif(theta==rsoptr(c_minus))
		{
			outopnd=first-second;
		}
		elif(theta==rsoptr(c_mul))
		{
			outopnd=first*second;
		}
		elif(theta==rsoptr(c_divide))
		{
			if(second==0)
			{
				return false;
			}
			outopnd=first/second;
		}
		else
		{
			return false;
		}
		return true;
	}

	static rbool is_const_str(const tsh& sh,const rstr& s)
	{
		return (s.is_number()||s==rsoptr(c_sbk_l)||s==rsoptr(c_sbk_r)||
			s==rsoptr(c_plus)||s==rsoptr(c_minus)||s==rsoptr(c_mul)||
			s==rsoptr(c_divide));
	}

	static rbool is_const_str(const tsh& sh,const rbuf<tword>& v,int begin,int end)
	{
		for(int i=begin;i<end;i++)
		{
			if(!is_const_str(sh,v[i].val))
			{
				return false;
			}
		}
		return true;
	}
};
﻿#pragma once

#include "ybase.h"

//替换控制结构并生成语句表，包括return
//tfunc.vword->vsent
struct ycontrol
{
	static rbool proc_func(const tsh& sh,tfunc& tfi)
	{
		if(!replace_switch(sh,tfi.vword))
		{
			return false;
		}
		ifn(replace_ifn(sh,tfi.vword))
		{
			return false;
		}
		ifn(add_semi(sh,tfi.vword))
		{
			return false;
		}
		ifn(replace_for(sh,tfi.vword,tfi.id))
		{
			return false;
		}
		ifn(add_else(sh,tfi.vword))
		{
			return false;
		}
		ifn(replace_elif(sh,tfi.vword))
		{
			return false;
		}
		ifn(replace_if(sh,tfi.vword,tfi.id))
		{
			return false;
		}
		if(!del_bbk(sh,tfi.vword))
		{
			return false;
		}
		tfi.vword+=rstr("_func_end");
		tfi.vword+=rsoptr(c_colon);
		tfi.vword+=rsoptr(c_semi);
		ifn(replace_return(sh,tfi.vword,tfi))
		{
			return false;
		}
		rbuf<rbuf<tword> > vsent=r_split_a<tword>(
			tfi.vword,tword(rsoptr(c_semi)));
		for(int i=0;i<vsent.count();i++)
		{
			tsent sent;
			sent.vword=vsent[i];
			tfi.vsent+=sent;
		}
		return true;
	}

	static rbool del_bbk(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val!=rsoptr(c_bbk_l))
			{
				continue;
			}
			int left=i;
			int right=ybase::find_symm_bbk(sh,v,left);
			if(right>=v.count())
			{
				rserror(v.get(i),"miss }");
				return false;
			}
			v[left].val.clear();
			v[right].val.clear();
		}
		ybase::arrange(v);
		return true;
	}

	static rbool add_semi(const tsh& sh,rbuf<tword>& v)
	{
		rbuf<tword> result;
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val==rsoptr(c_bbk_l)||v[i].val==rsoptr(c_bbk_r))
			{
				result+=v[i];
				continue;
			}
			if(v[i]==rskey(c_if)||v[i]==rskey(c_else)||
				v[i]==rskey(c_for)||v[i]==rskey(c_switch)||
				v[i]==rskey(c_case))
			{
				int end=v.find(rsoptr(c_bbk_l),i+1);
				if(end>=v.count())
				{
					return false;
				}
				result+=v.sub(i,end+1);
				i=end;
				continue;
			}
			int end=yformat::get_sent_end(sh,v,i,true);
			if(end>=v.count())
			{
				return false;
			}
			result+=v.sub(i,end+1);
			if(v[end]!=rsoptr(c_semi))
			{
				tword item;
				item.pos=v[end].pos;
				item.val=rsoptr(c_semi);
				result+=item;
			}
			i=end;
		}
		v=result;
		return true;
	}

	static rbool replace_ifn(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val!=rskey(c_ifn))
			{
				continue;
			}
			int pos=v.find(rsoptr(c_bbk_l),i+1);
			if(pos>=v.count())
			{
				rserror(v[i]);
				return false;
			}
			rbuf<tword> vcond=v.sub(i+1,pos);
			ybase::clear_word_val(v,i,pos);
			v[i].multi.push("if");
			v[i].multi.push("!");
			v[i].multi.push("(");
			v[i].multi+=ybase::vword_to_vstr(vcond);
			v[i].multi.push(")");
			i=pos;
		}
		ybase::arrange(v);
		return true;
	}

	//switch中不需要break
	static rbool replace_switch(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val!=rskey(c_switch))
			{
				continue;
			}
			int pos=v.find(rsoptr(c_bbk_l),i+1);
			if(pos>=v.count())
			{
				rserror(v[i]);
				return false;
			}
			rbuf<tword> vcond=v.sub(i+1,pos);
			ybase::clear_word_val(v,i,pos);
			pos++;
			rbool first=true;
			int left;
			int right;
			while(pos<v.count())
			{
				if(v[pos]!=rskey(c_case)&&v[pos]!=rskey(c_else))
				{
					break;
				}
				left=v.find(rsoptr(c_bbk_l),pos);
				if(left>=v.count())
				{
					rserror(v[pos]);
					return false;
				}
				right=ybase::find_symm_bbk(sh,v,left);
				if(right>=v.count())
				{
					rserror(v[pos]);
					return false;
				}
				rbuf<tword> val;
				if(v[left-1]==rsoptr(c_colon))
				{
					val=v.sub(pos+1,left-1);
				}
				else
				{
					val=v.sub(pos+1,left);
				}
				if(v[pos]==rskey(c_case))
				{
					if(first)
					{
						v[pos].multi.push(rskey(c_if));
						first=false;
					}
					else
					{
						v[pos].multi.push(rskey(c_else));
						v[pos].multi.push(rskey(c_if));
					}
					v[pos].multi+=ybase::vword_to_vstr(val);
					v[pos].multi.push(rsoptr(c_equal_equal));
					v[pos].multi.push(rsoptr(c_sbk_l));
					v[pos].multi+=ybase::vword_to_vstr(vcond);
					v[pos].multi.push(rsoptr(c_sbk_r));
				}
				else
				{
					v[pos].multi.push(rskey(c_else));
				}
				ybase::clear_word_val(v,pos,left);
				pos=right+1;
			}
		}
		ybase::arrange(v);
		return true;
	}

	static rbool replace_return(const tsh& sh,rbuf<tword>& v,const tfunc& tfi)
	{
		rbuf<tword> result;
		for(int i=0;i<v.count();i++)
		{
			if(v[i]!=rskey(c_return))
			{
				result.push(v[i]);
				continue;
			}
			int pos=v.find(rsoptr(c_semi),i);
			if(pos>=v.count())
			{
				return false;
			}
			rbuf<tword> sent=v.sub(i+1,pos);
			ifn(sent.empty())
			{
				if(ybase::is_quote(tfi.retval.type))
				{
					//todo: 应放在后端处理
					if(sh.m_mode==tsh::c_gpp)
					{
						result+=sent;
						result+=rsoptr(c_semi);
					}
					else
					{
						result+=rsoptr(c_addr);
						result+=rsoptr(c_sbk_l);
						result+=sent;
						result+=rsoptr(c_sbk_r);
						result+=rsoptr(c_semi);

						result+=rskey(c_mov);
						result+=rsoptr(c_mbk_l);
						result+=rskey(c_ebp);
						result+=rsoptr(c_plus);
						result+=rskey(c_s_off);
						result+=tfi.retval.name;
						result+=rsoptr(c_mbk_r);
						result+=rsoptr(c_comma);
						result+=rskey(c_ebx);
						result+=rsoptr(c_semi);
					}
				}
				else
				{
					result+=tfi.retval.name;
					result+=rsoptr(c_sbk_l);
					result+=rsoptr(c_sbk_l);
					result+=sent;
					result+=rsoptr(c_sbk_r);
					result+=rsoptr(c_sbk_r);
					result+=rsoptr(c_semi);
				}
			}
			result+=rskey(c_jmp);
			result+=rstr("_func_end");
			result+=rsoptr(c_semi);
			i=pos;
		}
		v=result;
		return true;
	}

	static rbool replace_for(const tsh& sh,rbuf<tword>& v,int& id)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i]!=rskey(c_for))
			{
				continue;
			}
			int left=v.find(rsoptr(c_bbk_l),i);
			if(left>=v.count())
			{
				return false;
			}
			int right=ybase::find_symm_bbk(sh,v,left);
			if(right>=v.count())
			{
				return false;
			}
			rbuf<rbuf<tword> > vcond;
			if(v.get(i+1)==rsoptr(c_sbk_l)&&v.get(left-1)==rsoptr(c_sbk_r))
			{
				vcond=r_split_e_a<tword>(
					v.sub(i+2,left-1),tword(rsoptr(c_semi)));
			}
			else
			{
				vcond=r_split_e_a<tword>(
					v.sub(i+1,left),tword(rsoptr(c_semi)));
			}
			if(vcond.empty())
			{
				vcond+=rbuf<tword>(1,tword(rstr("1")));//todo:
			}
			if(vcond.count()==1)
			{
				vcond.push(rbuf<tword>());
				vcond.push_front(rbuf<tword>());
			}
			if(vcond.count()!=3)
			{
				return false;
			}
			int cur_id=id;
			id++;
			rbuf<tword> center=v.sub(left+1,right);
			ifn(replace_break_continue(sh,center,cur_id))
			{
				return false;
			}
			rbuf<tword> result;
			result+=v.sub(0,i);
			result+=vcond[0];
			result+=rsoptr(c_semi);
			result+=rstr("_for_judge_")+cur_id;
			result+=rsoptr(c_colon);
			result+=rsoptr(c_semi);
			result+=vcond[1];
			result+=rsoptr(c_semi);
			result+=rstr("jebxz");
			result+=rstr("_for_end_")+cur_id;
			result+=rsoptr(c_semi);
			ifn(replace_for(sh,center,id))
			{
				return false;
			}
			result+=center;
			result+=rstr("_for_add_")+cur_id;
			result+=rsoptr(c_colon);
			result+=rsoptr(c_semi);
			result+=vcond[2];
			result+=rsoptr(c_semi);
			result+=rstr("jmp");
			result+=rstr("_for_judge_")+cur_id;
			result+=rsoptr(c_semi);
			result+=rstr("_for_end_")+cur_id;
			result+=rsoptr(c_colon);
			result+=rsoptr(c_semi);
			center=v.sub(right+1);
			ifn(replace_for(sh,center,id))
			{
				return false;
			}
			result+=center;
			v=result;
			return true;
		}
		return true;
	}

	static rbool replace_break_continue(const tsh& sh,rbuf<tword>& v,int cur_id)
	{
		rbuf<tword> result;
		for(int i=0;i<v.count();i++)
		{
			if(v[i]==rskey(c_for))
			{
				int left=v.find(rsoptr(c_bbk_l),i);
				if(left>=v.count())
				{
					return false;
				}
				int right=ybase::find_symm_bbk(sh,v,left);
				if(right>=v.count())
				{
					return false;
				}
				result+=v.sub(i,right+1);
				i=right;
			}
			elif(v[i]==rskey(c_break))
			{
				result+=rstr("jmp");
				result+=rstr("_for_end_")+cur_id;
			}
			elif(v[i]==rskey(c_continue))
			{
				result+=rstr("jmp");
				result+=rstr("_for_add_")+cur_id;
			}
			else
			{
				result+=v[i];
			}
		}
		v=result;
		return true;
	}

	static rbool add_else(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i]!=rskey(c_if))
			{
				continue;
			}
			int left=v.find(rsoptr(c_bbk_l),i);
			if(left>=v.count())
			{
				return false;
			}
			int right=ybase::find_symm_bbk(sh,v,left);
			if(right>=v.count())
			{
				return false;
			}
			if(v.get(right+1)==rskey(c_else))
			{
				continue;
			}
			rbuf<tword> result;
			result+=v.sub(0,left+1);
			rbuf<tword> temp=v.sub(left+1,right);
			ifn(add_else(sh,temp))
			{
				return false;
			}
			result+=temp;
			result+=rsoptr(c_bbk_r);
			result+=rskey(c_else);
			result+=rsoptr(c_bbk_l);
			result+=rsoptr(c_bbk_r);
			temp=v.sub(right+1);
			ifn(add_else(sh,temp))
			{
				return false;
			}
			result+=temp;
			v=result;
			return true;
		}
		return true;
	}

	static rbool replace_elif(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i]!=rskey(c_if))
			{
				continue;
			}
			int left=v.find(rsoptr(c_bbk_l),i);
			if(left>=v.count())
			{
				return false;
			}
			int right=ybase::find_symm_bbk(sh,v,left);
			if(right>=v.count())
			{
				return false;
			}
			if(v.get(right+1)!=rskey(c_else)||
				v.get(right+2)!=rskey(c_if))
			{
				continue;
			}
			rbuf<tword> result;
			result+=v.sub(0,left+1);
			rbuf<tword> temp=v.sub(left+1,right);
			ifn(replace_elif(sh,temp))
			{
				return false;
			}
			result+=temp;
			int first=v.find(rsoptr(c_bbk_l),right+2);
			if(first>=v.count())
			{
				return false;
			}
			int second=ybase::find_symm_bbk(sh,v,first);
			if(second>=v.count())
			{
				return false;
			}
			while(v.get(second+1)==rskey(c_else))
			{
				if(v.get(second+2)==rsoptr(c_bbk_l))
				{
					first=second+2;
					second=ybase::find_symm_bbk(sh,v,first);
					break;
				}
				first=v.find(rsoptr(c_bbk_l),second+2);
				second=ybase::find_symm_bbk(sh,v,first);
			}
			result+=rsoptr(c_bbk_r);
			result+=rskey(c_else);
			result+=rsoptr(c_bbk_l);
			temp=v.sub(right+2,second+1);
			ifn(replace_elif(sh,temp))
			{
				return false;
			}
			result+=temp;
			result+=rsoptr(c_bbk_r);
			temp=v.sub(second+1);
			ifn(replace_elif(sh,temp))
			{
				return false;
			}
			result+=temp;
			v=result;
			return true;
		}
		return true;
	}

	static rbool replace_if(const tsh& sh,rbuf<tword>& v,int& id)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i]!=rskey(c_if))
			{
				continue;
			}
			int left=v.find(rsoptr(c_bbk_l),i);
			if(left>=v.count())
			{
				return false;
			}
			int right=ybase::find_symm_bbk(sh,v,left);
			if(right>=v.count())
			{
				return false;
			}
			if(v.get(right+1)!=rskey(c_else))
			{
				continue;
			}
			rbuf<tword> result;
			int cur_id=id;
			id++;
			result+=v.sub(0,i);
			result+=v.sub(i+1,left);
			result+=rsoptr(c_semi);
			result+=rstr("jebxz");
			result+=rstr("_else_start_")+cur_id;
			result+=rsoptr(c_semi);
			rbuf<tword> temp=v.sub(left+1,right);
			ifn(replace_if(sh,temp,id))
			{
				return false;
			}
			result+=temp;
			result+=rstr("jmp");
			result+=rstr("_else_end_")+cur_id;
			result+=rsoptr(c_semi);
			result+=rstr("_else_start_")+cur_id;
			result+=rsoptr(c_colon);
			result+=rsoptr(c_semi);
			left=right+2;
			right=ybase::find_symm_bbk(sh,v,left);
			temp=v.sub(left+1,right);
			ifn(replace_if(sh,temp,id))
			{
				return false;
			}
			result+=temp;
			result+=rstr("_else_end_")+cur_id;
			result+=rsoptr(c_colon);
			result+=rsoptr(c_semi);
			temp=v.sub(right+1);
			ifn(replace_if(sh,temp,id))
			{
				return false;
			}
			result+=temp;
			v=result;
			return true;
		}
		return true;
	}
};
﻿#pragma once

#include "ymatch.h"
#include "yfunctl.h"

//表达式标准化类，返回表达式的类型
struct yexp
{
	//处理函数名调用
	static rbool p_func_call(tsh& sh,const tsent& src,tsent& outopnd,
		tfunc& tfi,int level,int& i,tenv env)
	{
		tclass* ptci=tfi.ptci;
		rstr fname=src.vword[i].val;
		tfunc* ptfi=yfind::func_search(*ptci,fname);
		if(ptfi==null)
		{
			ptci=sh.m_main;
			if(!p_call(sh,src,null,outopnd,tfi,level,i,ptci,env))
			{
				return false;
			}
			return true;
		}
		//函数重载不能友元和非友元共存，友元标志很重要。
		if(ptfi->is_friend)
		{
			if(!p_call(sh,src,null,outopnd,tfi,level,i,ptci,env))
			{
				return false;
			}
		}
		else
		{
			tsent first;
			first.type=ptci->name+rsoptr(c_addr);
			first.vword+=rskey(c_this);
			if(!p_call(sh,src,&first,outopnd,tfi,level,i,ptci,env))
			{
				return false;
			}
		}
		return true;
	}

	//处理[]函数指针直接调用
	static rbool p_point_call(tsh& sh,const tsent& src,tsent& outopnd,
		tfunc& tfi,int level,int& i,tenv env)
	{
		int left=i+1;
		int right=ybase::find_symm_mbk(sh,src.vword,left);
		if(right>=src.vword.count())
		{
			rserror(src,"call miss ]");
			return false;
		}
		outopnd.type=src.vword[i].val;
		outopnd.vword+=rsoptr(c_mbk_l);
		outopnd.vword+=rskey(c_pcall);
		outopnd.vword+=rsoptr(c_comma);
		outopnd.vword+=outopnd.type;
		outopnd.vword+=rsoptr(c_comma);
		outopnd.vword+=rsoptr(c_mbk_l);
		
		rbuf<tsent> vsent;
		ybase::split_param(sh,vsent,src.vword.sub(left+1,right),src);
		if(vsent.empty())
		{
			rserror(src,"call miss func");
			return false;
		}
		for(int j=0;j<vsent.count();j++)
		{
			if(j>=2)
			{
				outopnd.vword+=rsoptr(c_comma);
			}
			if(!p_exp(sh,vsent[j],tfi,level,env))
			{
				return false;
			}
			if(j>=1)
			{
				outopnd.vword+=vsent[j].type;
			}
		}
		outopnd.vword+=rsoptr(c_mbk_r);
		outopnd.vword+=rsoptr(c_comma);
		outopnd.vword+=vsent[0].vword;
		outopnd.vword+=rsoptr(c_comma);

		outopnd.vword+=rsoptr(c_mbk_l);
		for(int j=1;j<vsent.count();j++)
		{
			if(j!=1)
			{
				outopnd.vword+=rsoptr(c_comma);
			}
			outopnd.vword+=r_move(vsent[j].vword);
		}
		outopnd.vword+=rsoptr(c_mbk_r);

		outopnd.vword+=rsoptr(c_mbk_r);
		i=right;
		return true;
	}

	static rbool p_temp_var(tsh& sh,const tsent& src,tsent& outopnd,
		tfunc& tfi,int level,int& i,tenv env)
	{
		int left=i+1;
		int right=ybase::find_symm_sbk(sh,src.vword,left);
		if(right>=src.vword.count())
		{
			rserror(src,"class name miss (");
			return false;
		}
		rbuf<tsent> vsent;
		ybase::split_param(sh,vsent,src.vword.sub(left+1,right),src);
		if(!vsent.empty())
		{
			for(int j=0;j<vsent.count();j++)
			{
				if(!p_exp(sh,vsent[j],tfi,level,env))
				{
					return false;
				}
			}
		}
		outopnd.type=src.vword.get(i).val;
		outopnd.vword+=rsoptr(c_mbk_l);
		outopnd.vword+=rskey(c_btemp);
		outopnd.vword+=rsoptr(c_comma);
		outopnd.vword+=outopnd.type;
		outopnd.vword+=rsoptr(c_comma);
		outopnd.vword+=rsoptr(c_mbk_l);
		for(int j=0;j<vsent.count();j++)
		{
			if(j!=0)
			{
				outopnd.vword+=rsoptr(c_comma);
			}
			outopnd.vword+=r_move(vsent[j].vword);
		}
		outopnd.vword+=rsoptr(c_mbk_r);
		outopnd.vword+=rsoptr(c_mbk_r);
		i=right;
		return true;
	}
	
	//处理类名直接调用
	static rbool p_class_call(tsh& sh,const tsent& src,tsent& outopnd,
		tfunc& tfi,int level,int& i,tenv env)
	{
		if(src.vword.get(i+1).val!=rsoptr(c_dot))
		{
			rserror(src,"class name miss .");
			return false;
		}
		rstr cname=src.vword[i].val;
		tclass* ptci=yfind::class_search(sh,cname);
		if(ptci==null)
		{
			rserror(src,"can't find class name");
			return false;
		}
		i+=2;
		return p_call(sh,src,null,outopnd,tfi,level,i,ptci,env);
	}

	static rbool p_mbk(tsh& sh,const tsent& first,const tsent& second,
		tsent& outopnd,tfunc& tfi,int level,tenv env)
	{
		rbuf<tsent> vsent;
		ybase::split_param(sh,vsent,second.vword,first);
		for(int j=0;j<vsent.count();j++)
		{
			if(!p_exp(sh,vsent[j],tfi,level,env))
			{
				return false;
			}
		}
		vsent.push_front(first);
		tclass* ptci=yfind::class_search_t(sh,first.type);
		if(ptci==null)
		{
			rserror(first,"can't find func mbk");
			return false;
		}
		tfunc* ptfi=ymatch::find_replace(sh,*ptci,"[]",vsent);
		if(null==ptfi)
		{
			rserror(first,"can't find func mbk");
			return false;
		}
		set_func(sh,outopnd,vsent,ptfi);
		return true;
	}

	static rbool p_lisp(tsh& sh,const tsent& src,tsent& outopnd,
		tfunc& tfi,int level,tenv env)
	{
		if(src.vword.get_bottom().val!=rsoptr(c_mbk_l)&&
			src.vword.get_top().val!=rsoptr(c_mbk_r))
		{
			rserror(src,"lisp exp miss");
			return false;
		}
		outopnd.vword.clear();
		outopnd.pos=src.pos;
		tclass* ptci=null;
		tfunc* ptfi=null;
		rstr cname=src.vword.get(1).val;
		rbuf<rbuf<tword> > vlisp;
		get_vlisp(sh,src.vword,vlisp);
		rstr fname=rstr::join<rstr>(ybase::vword_to_vstr(vlisp.get(1)),"");
		ptci=yfind::class_search(sh,cname);
		if(ptci!=null)
		{
			if(vlisp.count()!=3)
			{
				rserror(src,"lisp exp miss");
				return false;
			}
			ptfi=yfind::func_search_dec(*ptci,fname);
			rbuf<tsent> vsent;
			tsent sent;
			sent.pos=src.pos;

			rbuf<rbuf<tword> > vparam;
			get_vlisp(sh,vlisp[2],vparam);
			for(int j=0;j<vparam.count();j++)
			{
				sent.vword=vparam[j];
				if(!p_exp(sh,sent,tfi,level,env))
				{
					return false;
				}
				vsent.push(sent);
			}

			if(ptfi==null)
			{
				ptfi=ymatch::find_replace(sh,*ptci,fname,vsent);
				if(ptfi==null)
				{
					rserror(src,"lisp exp miss");
					return false;
				}
			}
			set_func(sh,outopnd,vsent,ptfi);
			return true;
		}
		if(cname==rskey(c_pcall)||cname==rskey(c_btemp))
		{
			outopnd.vword=src.vword;
			outopnd.type=fname;
			return true;
		}
		if(cname==rsoptr(c_dot))
		{
			tsent sent;
			if(vlisp.count()!=3)
			{
				rserror(src,"lisp exp miss");
				return false;
			}
			sent.vword=vlisp[1];
			sent.pos=src.pos;
			ifn(p_exp(sh,sent,tfi,level,env))
			{
				return false;
			}
			ptci=yfind::class_search_t(sh,sent.type);
			if(ptci==null)
			{
				rserror(src,"lisp exp miss");
				return false;
			}
			tdata* ptdi=yfind::data_member_search(
				*ptci,vlisp[2].get(0).val);
			if(ptdi==null)
			{
				rserror(src,"lisp exp miss");
				return false;
			}
			outopnd.vword=src.vword;
			outopnd.type=ptdi->type;
			return true;
		}
		if(cname==rsoptr(c_addr))
		{
			outopnd.vword=src.vword;
			outopnd.type="rp<void>";
			return true;
		}
		rserror(src,"lisp exp miss");
		return false;
	}

	static void get_vsent(const rbuf<rbuf<tword> >& vlisp,rbuf<tsent>& vsent,
		const tsent& src)
	{
		vsent.clear();
		for(int i=0;i<vlisp.count();i++)
		{
			tsent sent;
			sent.pos=src.pos;
			sent.vword=vlisp[i];
			vsent.push_move(sent);
		}
	}

	static void get_vlisp(const tsh& sh,rbuf<tword> v,rbuf<rbuf<tword> >& vlisp)
	{
		vlisp=ybase::comma_split<tword>(sh,v.sub(1,v.count()-1));
	}
	
	//处理变参中括号调用,变参不能重载
	static rbool p_mbk_param(tsh& sh,const tsent& src,const tsent* pfirst,tsent& outopnd,
		tfunc& tfi,int level,int& i,const tclass* ptci,tenv env)
	{
		rstr cname=ptci->name;
		rstr fname=src.vword[i].val;
		int left=i+1;
		int right;
		right=ybase::find_symm_mbk(sh,src.vword,left);
		if(right>=src.vword.count())
		{
			rserror(src,"call miss )");
			return false;
		}
		tfunc* ptfi=yfind::func_search(*ptci,fname);
		if(null==ptfi)
		{
			rserror(src,"p_mbk_param can't find call");
			return false;
		}
		rbuf<tsent> vsent;
		ybase::split_param(sh,vsent,src.vword.sub(left+1,right),src);
		for(int j=0;j<vsent.count();j++)
		{
			if(!p_exp(sh,vsent[j],tfi,level,env))
			{
				return false;
			}
		}
		tsent tmp;
		tmp.pos=src.pos;
		tmp.vword.push(tword(rstr(vsent.count())));
		tmp.type=rskey(c_int);
		vsent.push_front(tmp);
		//插入first还未处理引用的情况
		if(pfirst!=null)
		{
			vsent.push_front(*pfirst);//插入DOT前的对象
			if(!ybase::is_point(pfirst->type))
			{
				vsent[0].vword.push_front(tword(rsoptr(c_addr)));
				if(!p_exp(sh,vsent[0],tfi,level,env))
				{
					return false;
				}
			}
		}
		tmp.vword.clear();
		tmp.vword+=tword(rsoptr(c_mbk_l));
		tmp.vword+=tword(rsoptr(c_addr));
		tmp.vword+=rsoptr(c_comma);
		tmp.vword+=tword(ptci->name);
		tmp.vword+=rsoptr(c_comma);
		tmp.vword+=tword(ptfi->name_dec);
		tmp.vword+=tword(rsoptr(c_mbk_r));

		outopnd.type=ptfi->retval.type;
		outopnd.vword+=tword(rsoptr(c_mbk_l));
		outopnd.vword+=tword(rskey(c_pcall));
		outopnd.vword+=rsoptr(c_comma);
		outopnd.vword+=tword(outopnd.type);
		outopnd.vword+=rsoptr(c_comma);
		outopnd.vword+=tword(rsoptr(c_mbk_l));
		for(int j=0;j<vsent.count();j++)
		{
			if(j!=0)
			{
				outopnd.vword+=rsoptr(c_comma);
			}
			outopnd.vword+=vsent[j].type;
		}
		outopnd.vword+=tword(rsoptr(c_mbk_r));
		outopnd.vword+=rsoptr(c_comma);
		outopnd.vword+=tmp.vword;
		outopnd.vword+=rsoptr(c_comma);

		outopnd.vword+=tword(rsoptr(c_mbk_l));
		for(int j=0;j<vsent.count();j++)
		{
			if(j!=0)
			{
				outopnd.vword+=rsoptr(c_comma);
			}
			outopnd.vword+=r_move(vsent[j].vword);
		}
		outopnd.vword+=tword(rsoptr(c_mbk_r));

		outopnd.vword+=tword(rsoptr(c_mbk_r));
		i=right;
		return true;
	}
	
	//无括号call
	static rbool p_call_n(tsh& sh,const tsent& src,const tsent* pfirst,tsent& outopnd,
		tfunc& tfi,int level,int& i,const tclass* ptci,tenv env)
	{
		rstr cname=ptci->name;
		rstr fname=src.vword[i].val;
		tfunc* ptfi;
		int left=i;
		int right=left+1;
		if(i+1==src.vword.count()-1||
			yfind::is_end_part_optr(sh,src.vword.get(i+1).val))
		{
			ptfi=yfind::func_search_empty_param_m(
				*ptci,fname,pfirst==null);
			if(ptfi==null)
			{
				rserror(src,"p_call_n can't find call");
				return false;
			}
		}
		else
		{
			ptfi=yfind::func_search_multi_param_m(
				*ptci,fname,pfirst==null);
			if(ptfi==null)
			{
				ptfi=yfind::func_search_empty_param_m(
					*ptci,fname,pfirst==null);
			}
			else
			{
				right=src.vword.count()-1;
			}
			if(ptfi==null)
			{
				rserror(src,"p_call_n2 can't find call");
				return false;
			}
		}
		tsent param=src.sub(left+1,right);
		outopnd.vword.push(tword(cname));
		outopnd.vword.push(tword(rsoptr(c_dot)));
		outopnd.vword.push(tword(fname));
		outopnd.vword.push(tword(rsoptr(c_sbk_l)));
		if(pfirst!=null&&!ptfi->is_friend)
		{
			outopnd.vword+=pfirst->vword;
			if(!param.empty())
			{
				outopnd.vword.push(tword(rsoptr(c_comma)));
				outopnd.vword+=r_move(param.vword);
			}
		}
		else
		{
			if(!param.empty())
			{
				outopnd.vword+=r_move(param.vword);
			}
		}
		outopnd.vword.push(tword(rsoptr(c_sbk_r)));
		//无括号调用添加括号递归处理
		if(!p_exp(sh,outopnd,tfi,level,env))
		{
			return false;
		}
		i=right-1;
		return true;
	}

	static rbool p_ftl(tsh& sh,tsent src,const tsent* pfirst,tsent& outopnd,
		tfunc& tfi,int level,int& i,tclass* ptci,tenv env)
	{
		int left=i+1;
		if(src.vword.get(left)!=rsoptr(c_tbk_l))
		{
			rserror(src,"call miss <");
			return false;
		}
		int right=ybase::find_symm_tbk(sh,src.vword,left);
		if(right>=src.vword.count())
		{
			rserror(src,"call miss >");
			return false;
		}
		rbuf<tword> temp=src.vword.sub(i,right+1);
		if(!yfunctl::ftl_replace(sh,*tfi.ptci,temp,ptci))
		{
			return false;
		}
		src.vword[right]=temp.get_bottom();
		i=right;
		return p_call(sh,src,pfirst,outopnd,tfi,level,i,ptci,env);
	}

	static rbool set_vsent(const tsh& sh,tpos pos,rbuf<tsent>& vsent,
		tfunc& tfi,int level,tenv env)
	{
		tsent sent;
		tword word;
		word.pos=pos;
		sent.pos=pos;
		tdynamic item;
		item.key=tfi.sdynamic.count();
		for(int k=0;k<vsent.count();k++)
		{
			item.vparam+=ybase::vword_to_vstr(vsent[k].vword);
		}
		tfi.sdynamic.insert(item);

		vsent.clear();

		ybase::push_twi(sent.vword,word,rstr((uint)(&tfi.sdynamic.find(item)->vparam)));
		vsent.push(sent);

		sent.vword.clear();
		ybase::push_twi(sent.vword,word,rstr((uint)(&tfi)));
		vsent.push(sent);

		sent.vword.clear();
		ybase::push_twi(sent.vword,word,rstr("_EBP"));
		vsent.push(sent);

		return true;
	}

	static rbool p_call(tsh& sh,const tsent& src,const tsent* pfirst,tsent& outopnd,
		tfunc& tfi,int level,int& i,const tclass* ptci,tenv env)
	{
		rstr cname=ptci->name;
		rstr fname=src.vword[i].val;
		if(src.vword.get(i+1).val==rsoptr(c_mbk_l))
		{
			return p_mbk_param(sh,src,pfirst,outopnd,tfi,level,i,ptci,env);
		}
		if(pfirst!=null&&ybase::get_tname(pfirst->type)==rskey(c_var)&&
			null==yfind::func_search(*ptci,fname))
		{
			return false;
			//a.test  ->   a["test"]
		}
		if(src.vword.get(i+1).val!=rsoptr(c_sbk_l))
		{
			return p_call_n(sh,src,pfirst,outopnd,tfi,level,i,ptci,env);
		}
		int left=i+1;
		int right;
		right=ybase::find_symm_sbk(sh,src.vword,left);
		if(right>=src.vword.count())
		{
			rserror(src,"call miss )");
			return false;
		}
		rbuf<tsent> vsent;
		ybase::split_param(sh,vsent,src.vword.sub(left+1,right),src);
		for(int j=0;j<vsent.count();j++)
		{
			if(!p_exp(sh,vsent[j],tfi,level,env))
			{
				return false;
			}
		}
		tfunc* ptfi=yfind::func_search(*ptci,fname);
		if(ptfi!=null&&ptfi->is_dynamic)
		{
			ifn(set_vsent(sh,src.vword[i].pos,vsent,tfi,level,env))
			{
				return false;
			}
			if(pfirst!=null)
			{
				vsent.push_front(*pfirst);
			}
			set_func(sh,outopnd,vsent,ptfi);
			i=right;
			return true;
		}
		if(pfirst!=null)
		{
			vsent.push_front(*pfirst);//插入DOT前的对象
		}
		ptfi=ymatch::find_replace(sh,*ptci,fname,vsent);
		if(null==ptfi)
		{
			if(pfirst==null)
			{
				rserror(src,"p_call can't find call");
				return false;
			}
			vsent.pop_front();
			ptfi=ymatch::find_replace(sh,*ptci,fname,vsent);
			if(ptfi==null||!ptfi->is_friend)
			{
				rserror(src,"p_call can't find call");
				return false;
			}
		}
		set_func(sh,outopnd,vsent,ptfi);
		i=right;
		return true;
	}

	static rbool p_exp_all(tsh& sh,tfunc& tfi,tenv env)
	{
		for(int i=0;i<tfi.vsent.count();++i)
		{
			if(sh.m_key.is_asm_ins(tfi.vsent[i].vword.get_bottom().val))
			{
				continue;
			}
			if(ybase::is_tag<tword>(tfi.vsent[i].vword))
			{
				continue;
			}
			if(!yexp::p_exp(sh,tfi.vsent[i],tfi,0,env))
			{
				return false;
			}
		}
		return true;
	}

	static rbool p_exp(tsh& sh,rbuf<tword>& v,tfunc& tfi,
		int level,tenv env)
	{
		tsent sent;
		sent.vword=v;
		sent.pos.line=1;
		ifn(p_exp(sh,sent,tfi,level,env))
		{
			return false;
		}
		v=sent.vword;
		return true;
	}

	static rbool p_exp(tsh& sh,tsent& src,tfunc& tfi,
		int level,tenv env)
	{
		return p_exp(sh,src,src,tfi,level,env);
	}
	
	//表达式标准化，并设置dst.type
	static rbool p_exp(tsh& sh,tsent src,tsent& dst,tfunc& tfi,
		int level,tenv env)
	{
		tclass& tci=*tfi.ptci;
		if(level>c_rs_deep)
		{
			rserror(src,"expression too deep");
			return false;
		}
		level++;
		dst.clear();
		rbuf<rstr> soptr;
		rbuf<tsent> sopnd;
		soptr.push(rsoptr(c_sharp_sharp));
		src.vword.push(tword(rsoptr(c_sharp_sharp)));
		for(int i=0;i<src.vword.count();++i)
		{
			if(src.vword[i].val==rsoptr(c_sharp_sharp)&&
				soptr.get_top()==rsoptr(c_sharp_sharp))
			{
				break;
			}
			if(src.vword[i].is_const())
			{
				tsent outopnd;
				outopnd.pos=src.pos;
				outopnd.vword.push(src.vword[i]);
				outopnd.type=ybase::get_ctype(sh,src.vword[i]);
				sopnd.push_move(outopnd);
			}
			elif(sh.m_key.is_asm_reg(src.vword[i].val))
			{
				tsent outopnd;
				outopnd.pos=src.pos;
				outopnd.vword.push(src.vword[i]);
				outopnd.type=rskey(c_int);
				sopnd.push_move(outopnd);
			}
			elif(src.vword[i].val==rsoptr(c_sbk_l))
			{
				//todo 小括号重载有点复杂 
				int right=ybase::find_symm_sbk(sh,src.vword,i);
				if(right>=src.vword.count())
				{
					rserror(src,"miss )");
					return false;
				}
				tsent outopnd;
				outopnd.pos=src.pos;
				if(!p_exp(sh,src.sub(i+1,right),outopnd,tfi,level,env))
				{
					return false;
				}
				sopnd.push_move(outopnd);
				i=right;
			}
			elif(src.vword.get(i+1)==rsoptr(c_mbk_l)&&
				yfind::is_class_t(sh,src.vword[i].val))
			{
				//[]函数指针调用
				tsent outopnd;
				outopnd.pos=src.pos;
				if(!p_point_call(sh,src,outopnd,tfi,level,i,env))
				{
					return false;
				}
				sopnd.push_move(outopnd);
			}
			elif(src.vword[i].val==rsoptr(c_mbk_l))
			{
				int right=ybase::find_symm_mbk(sh,src.vword,i);
				if(right>=src.vword.count())
				{
					rserror(src,"miss ]");
					return false;
				}
				tsent outopnd;
				outopnd.pos=src.pos;
				if(sopnd.empty()||
					src.vword.get(i+1).val==rsoptr(c_addr)&&
					yfind::is_class(sh,src.vword.get(i+3).val))
				{
					if(!p_lisp(sh,src.sub(
						i,right+1),outopnd,tfi,level,env))
					{
						return false;
					}
				}
				else
				{
					if(!p_mbk(sh,sopnd.pop(),src.sub(i+1,right),
						outopnd,tfi,level,env))
					{
						return false;
					}
				}
				sopnd.push_move(outopnd);
				i=right;
			}
			elif(src.vword[i].val==rsoptr(c_dot))
			{
				if(sopnd.empty())
				{
					rserror(src,". miss opnd");
					return false;
				}
				i++;
				rstr name=src.vword.get(i).val;
				tsent first=sopnd.pop();
				tclass* ptci=yfind::class_search_t(sh,first.type);
				if(null==ptci)
				{
					rserror(src,". can't find class name");
					return false;
				}
				tsent outopnd;
				outopnd.pos=src.pos;
				//数据成员和函数成员不可以同名
				tdata* ptdi=yfind::data_member_search(*ptci,name);
				if(ptdi!=null)
				{
					outopnd.type=ptdi->type;
					outopnd.vword+=tword(rsoptr(c_mbk_l));
					outopnd.vword+=tword(rsoptr(c_dot));
					outopnd.vword+=rsoptr(c_comma);
					outopnd.vword+=first.vword;
					outopnd.vword+=rsoptr(c_comma);
					outopnd.vword+=tword(name);
					outopnd.vword+=tword(rsoptr(c_mbk_r));
					sopnd.push(outopnd);
					continue;
				}
				if(src.vword.get(i+1)==rsoptr(c_tbk_l)&&
					yfind::ftl_search(*ptci,name)!=null)
				{
					if(!p_ftl(sh,src,&first,
						outopnd,tfi,level,i,ptci,env))
					{
						return false;
					}
				}
				else
				{
					if(!p_call(sh,src,&first,
						outopnd,tfi,level,i,ptci,env))
					{
						return false;
					}
				}
				sopnd.push_move(outopnd);
			}
			elif(src.vword[i].val==rsoptr(c_arrow_r))
			{
				if(sopnd.empty())
				{
					rserror(src,". miss opnd");
					return false;
				}
				tsent first=sopnd.pop();
				first.vword.push_front(tword(rsoptr(c_mul)));
				if(!p_exp(sh,first,tfi,level,env))
				{
					return false;
				}
				sopnd.push_move(first);
				src.vword[i].val=rsoptr(c_dot);
				i--;
			}
			elif(sh.m_optr.is_optr(src.vword[i].val))
			{
				if(soptr.empty())
				{
					rserror(src,"exp miss optr");
					return false;
				}
				rstr cur=src.vword[i].val;
				if(!sh.m_optr.precede(soptr.top(),cur))
				{
					soptr.push(cur);
					continue;
				}
				rstr theta=soptr.pop();
				if(sopnd.empty())
				{
					rserror(src,"exp miss opnd");
					return false;
				}
				rbuf<tsent> vsent;
				vsent.push(sopnd.pop());
				tclass* ptci=yfind::class_search_t(sh,vsent[0].type);
				tfunc* ptfi;
				tsent outopnd;
				outopnd.pos=src.pos;
				if(ptci!=null)
				{
					ptfi=ymatch::find_replace(sh,
						*ptci,theta,vsent);
					if(ptfi!=null)
					{
						set_func(sh,outopnd,
							vsent,ptfi);
						sopnd.push_move(outopnd);
						i--;
						continue;
					}
				}
				if(sopnd.empty())
				{
					rserror(src,"exp miss opnd");
					return false;
				}
				vsent.push_front(sopnd.pop());
				ptci=yfind::class_search_t(sh,vsent[0].type);
				if(ptci!=null)
				{
					ptfi=ymatch::find_replace(sh,
						*ptci,theta,vsent);
					if(ptfi!=null)
					{
						set_func(sh,outopnd,
							vsent,ptfi);
						sopnd.push_move(outopnd);
						i--;
						continue;
					}
				}
				ptci=yfind::class_search_t(sh,vsent[1].type);
				if(ptci!=null)
				{
					ptfi=ymatch::find_replace(sh,
						*ptci,theta,vsent);
					if(ptfi!=null)
					{
						set_func(sh,outopnd,
							vsent,ptfi);
						sopnd.push_move(outopnd);
						i--;
						continue;
					}
				}
				rserror(src,"exp miss opnd 2");
				return false;
			}
			elif(yfind::is_class(sh,src.vword[i].val))
			{
				tsent outopnd;
				outopnd.pos=src.pos;
				if(src.vword.get(i+1).val==rsoptr(c_sbk_l))
				{
					//临时变量
					if(!p_temp_var(sh,src,outopnd,tfi,level,i,env))
					{
						return false;
					}
				}
				else
				{
					//类名直接调用
					if(!p_class_call(sh,src,outopnd,tfi,level,i,env))
					{
						return false;
					}
				}
				sopnd.push_move(outopnd);
			}
			else
			{
				rstr name=src.vword[i].val;
				tsent outopnd;
				outopnd.pos=src.pos;
				tdata* ptdi=yfind::local_search(tfi,name);
				if(ptdi!=null)
				{
					outopnd.vword+=src.vword[i];
					outopnd.type=ptdi->type;
					sopnd.push_move(outopnd);
					continue;
				}
				if(!tci.is_friend)
				{
					ptdi=yfind::data_member_search(tci,name);
					if(ptdi!=null)
					{
						//类成员变量增加this
						//如 m_a -> this.m_a 
						outopnd.vword+=tword(rsoptr(c_mbk_l));
						outopnd.vword+=tword(rsoptr(c_dot));
						outopnd.vword+=rsoptr(c_comma);
						outopnd.vword+=tword(rskey(c_this));
						outopnd.vword+=rsoptr(c_comma);
						outopnd.vword+=src.vword[i];
						outopnd.vword+=tword(rsoptr(c_mbk_r));
						outopnd.type=ptdi->type;
						sopnd.push_move(outopnd);
						continue;
					}
				}
				ptdi=yfind::data_member_search(*sh.m_main,name);
				if(ptdi!=null)
				{
					//全局变量
					outopnd.vword+=tword(rsoptr(c_mbk_l));
					outopnd.vword+=tword(rsoptr(c_dot));
					outopnd.vword+=rsoptr(c_comma);
					outopnd.vword+=tword(rskey(c_pmain));
					outopnd.vword+=rsoptr(c_comma);
					outopnd.vword+=src.vword[i];
					outopnd.vword+=tword(rsoptr(c_mbk_r));
					outopnd.type=ptdi->type;
					sopnd.push_move(outopnd);
					continue;
				}
				if(env.ptfi!=null)
				{
					ptdi=yfind::local_search(*env.ptfi,name);
					if(ptdi!=null)
					{
						//环境变量
						outopnd.vword+=tword(rsoptr(c_mbk_l));
						outopnd.vword+=tword(rsoptr(c_dot));
						outopnd.vword+=rsoptr(c_comma);
						outopnd.vword+=tword(rskey(c_penv));
						outopnd.vword+=rsoptr(c_comma);
						outopnd.vword+=src.vword[i];
						outopnd.vword+=tword(rsoptr(c_mbk_r));
						outopnd.type=ptdi->type;
						sopnd.push_move(outopnd);
						continue;
					}
				}
				if(!p_func_call(sh,src,outopnd,tfi,level,i,env))
				{
					return false;
				}
				sopnd.push_move(outopnd);
			}
		}
		if(sopnd.count()!=1)
		{
			ybase::print_vword(src.vword);
			rserror(src,"expression error");
			return false;
		}
		dst=r_move(sopnd[0]);
		if(dst.vword.empty()||dst.type.empty())
		{
			rserror(src,"expression error");
			return false;
		}
		return true;
	}

	static void set_func(const tsh& sh,tsent& outopnd,const rbuf<tsent>& vsent,const tfunc* ptfi)
	{
		const tclass* ptci=ptfi->ptci;
		outopnd.type=ptfi->retval.type;
		outopnd.vword+=tword(rsoptr(c_mbk_l));
		outopnd.vword+=tword(ptci->name);
		outopnd.vword+=rsoptr(c_comma);
		outopnd.vword+=tword(ptfi->name_dec);
		outopnd.vword+=rsoptr(c_comma);
		outopnd.vword+=tword(rsoptr(c_mbk_l));
		for(int i=0;i<vsent.count();i++)
		{
			if(i!=0)
			{
				outopnd.vword+=rsoptr(c_comma);
			}
			outopnd.vword+=r_move(vsent[i].vword);
		}
		outopnd.vword+=tword(rsoptr(c_mbk_r));
		outopnd.vword+=tword(rsoptr(c_mbk_r));
	}
};
﻿#pragma once

#include "ybase.h"

struct yfind
{
	//获取类型大小
	static int get_type_size(const tsh& sh,const rstr& s)
	{
		if(ybase::is_point_quote(s))
		{
			return sh.m_point_size;
		}
		tclass* ptci=class_search_t(sh,s);
		if(ptci!=null)
		{
			return ptci->size;
		}
		return 0;
	}

	static int get_func_local_size(const tfunc& tfi)
	{
		int ret=0;
		for(int i=0;i<tfi.local.count();++i)
		{
			ret+=get_ceil_space(tfi.local[i]);
		}
		return ret;
	}

	static int get_func_param_size(const tfunc& tfi)
	{
		int ret=0;
		for(int i=0;i<tfi.param.count();++i)
		{
			ret+=get_ceil_space(tfi.param[i]);
		}
		return ret;
	}

	//不包括返回值
	static int get_func_stack_size(const tfunc& tfi)
	{
		return get_func_local_size(tfi)+get_func_param_size(tfi)+c_point_size*2;
	}

	//32位栈空间按4字节排列，64位栈空间按8字节排列，因为amd64没有32位push指令
	static int get_ceil_space(const tdata& tdi)
	{
		return r_ceil_div(tdi.size,c_point_size)*c_point_size;
	}

	static rbool is_type_mebx(const tsh& sh,const rstr& type)
	{
		//这里不用is_point_quote可略微提高效率
		return type==rskey(c_int)||ybase::is_point(type)||ybase::is_quote(type);
	}

	static rbool is_op_pass_type(const tsh& sh,const rstr& s)
	{
		return s==rskey(c_int)||s==rskey(c_uint)||ybase::is_point(s);
	}

	static rbool is_rstr_optr(const tsh& sh,const rstr& s)
	{
		return (s==rsoptr(c_plus)||s==rsoptr(c_equal_equal)||
			s==rsoptr(c_not_equal)||s==rsoptr(c_great_equal)||
			s==rsoptr(c_less_equal));
		//大于和小于最好不要加上，防止与尖括号作用冲突
	}

	static rbool is_end_part_optr(const tsh& sh,const rstr& s)
	{
		if(!sh.m_optr.is_optr(s))
		{
			return false;
		}
		return (s==rsoptr(c_dot)||s==rsoptr(c_sbk_r)||
			s==rsoptr(c_mbk_r)||s==rsoptr(c_plus));
		//还有很多这样的运算符，暂时不写
	}

	static rbool is_empty_struct_type(const tsh& sh,const rstr& s)
	{
		return (s==rskey(c_int)||s==rskey(c_char)||
			s==rskey(c_uint)||s==rskey(c_int64)||
			s==rskey(c_double)||s==rskey(c_rd32)||
			s=="float"||ybase::is_point_quote(s));
	}

	static rbool is_class(const tsh& sh,const rstr& s)
	{
		return class_search(sh,s)!=null;
	}

	static rbool is_class_t(const tsh& sh,const rstr& s)
	{
		return class_search_t(sh,s)!=null;
	}

	static rbool is_classtl(const tsh& sh,const rstr& s)
	{
		return classtl_search(sh,s)!=null;
	}

	static tclass* class_search_t(const tsh& sh,const rstr& name)
	{
		return class_search(sh,ybase::get_tname(name));
	}

	static tclass* class_search(const tsh& sh,const rstr& name)
	{
		tclass item;
		item.name=name;
		return sh.m_class.find(item);
	}

	static tclass* classtl_search(const tsh& sh,const rstr& name)
	{
		tclass item;
		item.name=name;
		return sh.m_classtl.find(item);
	}

	//先搜索友元空参，再搜索非友元空参
	static tfunc* func_search_empty_param_m(const tclass& tci,
		const rstr& fname,rbool is_friend)
	{
		//友元只能调用友元
		if(is_friend)
		{
			return func_search_empty_param_f(tci,fname);
		}
		tfunc* ptfi=func_search_empty_param_f(tci,fname);
		if(null==ptfi)
		{
			ptfi=func_search_empty_param_n(tci,fname);
		}
		return ptfi;
	}
	
	//先搜索友元多参，再搜索非友元多参
	static tfunc* func_search_multi_param_m(const tclass& tci,
		const rstr& fname,rbool is_friend)
	{
		if(is_friend)
		{
			return func_search_multi_param_f(tci,fname);
		}
		tfunc* ptfi=func_search_multi_param_f(tci,fname);
		if(null==ptfi)
		{
			ptfi=func_search_multi_param_n(tci,fname);
		}
		return ptfi;
	}
	
	//搜索非友元参数大于等于1个的函数（实际大于等于2）
	static tfunc* func_search_multi_param_n(const tclass& tci,const rstr& fname)
	{
		for(tfunc* p=tci.vfunc.begin();p!=tci.vfunc.end();p=tci.vfunc.next(p))
		{
			if(fname==p->name&&
				!p->is_friend&&
				p->param.count()>=2&&
				p->param[0].type==tci.name+rstr("&"))
			{
				return p;
			}
		}
		return null;
	}

	//搜索非友元空参函数（类成员空参函数）
	static tfunc* func_search_empty_param_n(const tclass& tci,const rstr& fname)
	{
		for(tfunc* p=tci.vfunc.begin();p!=tci.vfunc.end();p=tci.vfunc.next(p))
		{
			if(fname==p->name&&
				!p->is_friend&&
				p->param.count()==1&&
				p->param[0].type==tci.name+rstr("&"))
			{
				return p;
			}
		}
		return null;
	}

	//搜索友元参数大于等于1个的函数
	static tfunc* func_search_multi_param_f(const tclass& tci,const rstr& fname)
	{
		for(tfunc* p=tci.vfunc.begin();p!=tci.vfunc.end();p=tci.vfunc.next(p))
		{
			if(fname==p->name&&
				p->is_friend&&
				p->param.count()>=1)
			{
				return p;
			}
		}
		return null;
	}

	//搜索友元空参函数
	static tfunc* func_search_empty_param_f(const tclass& tci,const rstr& fname)
	{
		for(tfunc* p=tci.vfunc.begin();p!=tci.vfunc.end();p=tci.vfunc.next(p))
		{
			if(fname==p->name&&
				p->is_friend&&
				p->param.empty())
			{
				return p;
			}
		}
		return null;
	}

	//类型完全相同
	static tfunc* func_search_same(const tclass& tci,const rstr& fname,
			const rbuf<rstr>& vtype)
	{
		tfunc tfi;
		tfi.name=fname;
		for(int i=0;i<vtype.count();i++)
		{
			tfi.param.push(vtype[i]);
		}
		tfi.name_dec=tfi.get_dec();
		return tci.vfunc.find(tfi);
	}

	static tfunc* func_search_dec(const tclass& tci,const rstr& func_dec)
	{
		tfunc tfi;
		tfi.name_dec=func_dec;
		return tci.vfunc.find(tfi);
	}
	
	//根据函数名搜索函数
	static tfunc* func_search(const tclass& tci,const rstr& fname)
	{
		for(tfunc* p=tci.vfunc.begin();p!=tci.vfunc.end();p=tci.vfunc.next(p))
		{
			if(fname==p->name)
			{
				return p;
			}
		}
		return null;
	}

	static tfunc* func_search(const tclass& tci,const rstr& fname,
		const rstr& a,const rstr& b)
	{
		tfunc item;
		item.name=fname;
		item.param.push(a);
		item.param.push(b);
		item.name_dec=item.get_dec();
		return tci.vfunc.find(item);
	}

	static tfunc* func_search(const tclass& tci,const rstr& fname,const rstr& a)
	{
		tfunc item;
		item.name=fname;
		item.param.push(a);
		item.name_dec=item.get_dec();
		return tci.vfunc.find(item);
	}

	static tfunc* ftl_search(const tclass& tci,const rstr& name)
	{
		tfunc item;
		item.name=name;
		item.name_dec=item.get_dec();
		return tci.vfunctl.find(item);
	}

	static tfunc* destruct_search(const tclass& tci)
	{
		return func_search(tci,"~"+tci.name,tci.name+"&");
	}

	static rbool is_destruct(const tsh& sh,const tfunc& tfi)
	{
		tclass& tci=*tfi.ptci;
		return (rsoptr(c_destruct)+tci.name==tfi.name&&
				tfi.param.count()==1&&
				tfi.param[0].type==tci.name+rsoptr(c_addr)&&
				tfi.retval.type==rskey(c_void));
	}

	static tfunc* emptystruct_search(const tclass& tci)
	{
		return func_search(tci,tci.name,tci.name+"&");
	}

	static rbool is_emptystruct(const tsh& sh,const tfunc& tfi)
	{
		tclass& tci=*tfi.ptci;
		return (tci.name==tfi.name&&
				tfi.param.count()==1&&
				tfi.param[0].type==tci.name+rsoptr(c_addr)&&
				tfi.retval.type==rskey(c_void));
	}

	static tfunc* copystruct_search(const tclass& tci)
	{
		return func_search(tci,tci.name,tci.name+"&",tci.name+"&");
	}

	static tdata* data_member_search(const tclass& tci,const rstr& name)
	{
		for(int i=0;i<tci.vdata.count();i++)
		{
			if(name==tci.vdata[i].name)
			{
				return &tci.vdata[i];
			}
		}
		return null;
	}

	static tdata* local_search(const tfunc& tfi,const rstr& name)
	{
		for(int i=0;i<tfi.local.count();++i)
		{
			if(name==tfi.local[i].name)
			{
				return &tfi.local[i];
			}
		}
		for(int i=0;i<tfi.param.count();++i)
		{
			if(name==tfi.param[i].name)
			{
				return &tfi.param[i];
			}
		}
		if(tfi.retval.name==name)
		{
			return (tdata*)(&tfi.retval);
		}
		return null;
	}
};
﻿#pragma once

#include "ybase.h"

//有格式代码转无格式
struct yformat
{
	static rbool process(tsh& sh)
	{
		for(tfile* p=sh.m_file.begin();p!=sh.m_file.end();p=sh.m_file.next(p))
		{
			//先进行控制结构替换，因为case后面可能有冒号防止被识别为函数
			ifn(control_replace(sh,p->vword))
			{
				return false;
			}
			class_def_replace(sh,p->vword);
			func_def_replace(sh,p->vword);
		}
		return true;
	}

	static int get_sent_end(const tsh& sh,rbuf<tword>& v,int begin,rbool use_semi)
	{
		int count1=0;
		int count2=0;
		for(int i=begin;i<v.count();i++)
		{
			if(v[i].val==rsoptr(c_sbk_l))
			{
				count1++;
			}
			elif(v[i].val==rsoptr(c_sbk_r))
			{
				count1--;
			}
			elif(v[i].val==rsoptr(c_mbk_l))
			{
				count2++;
			}
			elif(v[i].val==rsoptr(c_mbk_r))
			{
				count2--;
			}
			if(count1==0&&count2==0)
			{
				if(v[i].val==rsoptr(c_bbk_l)||v[i].val==rsoptr(c_bbk_r))
				{
					return i-1;
				}
				if(use_semi&&v[i].val==rsoptr(c_semi))
				{
					return i;
				}
				if(v[i].pos!=v.get(i+1).pos)
				{
					return i;
				}
			}
		}
		return v.count()-1;
	}

	static rbool control_replace(tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			ifn(v[i].val==rskey(c_for)||v[i].val==rskey(c_if)||v[i].val==rskey(c_else)||
				v[i].val==rskey(c_ifn)||v[i].val==rskey(c_switch)||v[i].val==rskey(c_case))
			{
				continue;
			}
			int k=get_sent_end(sh,v,i,false);
			if(v.get(k+1).val==rsoptr(c_bbk_l))
			{
				continue;
			}
			if(v[k].val==rsoptr(c_colon))
			{
				v[k].val.clear();
			}
			v[k].multi+=v[k].val;
			v[k].multi+=rsoptr(c_bbk_l);
			v[k].val.clear();
			int j=get_low_end(v,k+1,i);
			v[j-1].multi+=v[j-1].val;
			v[j-1].multi+=rsoptr(c_bbk_r);
			v[j-1].val.clear();
			i=j-1;
		}
		if(ybase::arrange(v))
		{
			return control_replace(sh,v);
		}
		return true;
	}

	static void func_def_replace(tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			ifn(v[i].val==rsoptr(c_sbk_r)&&v.get(i+1).val==rsoptr(c_colon))
			{
				continue;
			}
			if(v.get(i+2).val==rsoptr(c_bbk_l))
			{
				v[i+1].val.clear();
				continue;
			}
			int j=get_low_end(v,i+2,i+1);
			v[i+1].val=rsoptr(c_bbk_l);
			v[j-1].multi+=v[j-1].val;
			v[j-1].multi+=rsoptr(c_bbk_r);
			v[j-1].val.clear();
			i=j-1;
		}
		if(ybase::arrange(v))
		{
			func_def_replace(sh,v);
		}
	}

	static void class_def_replace(tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val!=rskey(c_class))
			{
				continue;
			}
			for(int k=i+1;k<v.count();k++)
			{
				if(v[k].pos!=v[i].pos)
				{
					break;
				}
				if(v[k].val==rsoptr(c_bbk_l))
				{
					break;
				}
				if(v[k].val==rsoptr(c_colon)&&v[k].pos!=v.get(k+1).pos)
				{
					int j=get_low_end(v,k+1,i);
					v[k].val=rsoptr(c_bbk_l);
					v[j-1].multi+=v[j-1].val;
					v[j-1].multi+=rsoptr(c_bbk_r);
					v[j-1].val.clear();
					i=j-1;
					break;
				}
			}
		}
		if(ybase::arrange(v))
		{
			class_def_replace(sh,v);
		}
	}

	//获取低一层结尾语句的位置
	static int get_low_end(rbuf<tword>& v,int begin,int head)
	{
		for(int i=begin;i<v.count();i++)
		{
			if(ybase::get_word_tab(v[i])<=ybase::get_word_tab(v[head]))
			{
				return i;
			}
		}
		return v.count();
	}
};
﻿#pragma once

#include "ymemb.h"
#include "yclasstl.h"

//函数模板处理
struct yfunctl
{
	static rbool ftl_replace(tsh& sh,tclass& tci,rbuf<tword>& v,tclass* ptci)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val!=rsoptr(c_tbk_l))
			{
				continue;
			}
			int left=i;
			rstr name=v.get(left-1).val;
			tclass* cur_ptci=ptci;
			if(cur_ptci==null)
			{
				if(v.get(left-2).val==rsoptr(c_dot))
				{
					cur_ptci=yfind::class_search(sh,v.get(left-3).val);
					if(cur_ptci==null)
					{
						continue;
					}	
				}
				else
				{
					cur_ptci=&tci;
				}
			}
			tfunc* ptfi=yfind::ftl_search(*cur_ptci,name);
			if(ptfi==null)
			{
				cur_ptci=sh.m_main;
				ptfi=yfind::ftl_search(*cur_ptci,name);
			}
			if(null==ptfi)
			{
				continue;
			}
			int right=ybase::find_symm_tbk(sh,v,left);
			if(right>=v.count())
			{
				rserror(v[left-1],"func template miss >");
				return false;
			}
			rbuf<rbuf<tword> > vparam=ybase::comma_split<tword>(
				sh,v.sub(left+1,right));
			if(vparam.count()!=ptfi->vtl.count())
			{
				rserror(v[left-1],"func template not match");
				return false;
			}
			for(int j=left;j<=right;j++)
			{
				v[left-1].val+=v[j].val;
				v[j].val.clear();
			}
			//模板函数不可能重载，因此只要判断一下函数名是否相同即可
			if(yfind::func_search(*cur_ptci,v[left-1].val)!=null)
			{
				continue;
			}
			tfunc item=*ptfi;
			item.vtl.free();
			yclasstl::vtl_replace(item.vword,ptfi->vtl,vparam);
			if(!f_type_replace(sh,item.vword))
			{
				return false;
			}
			if(!combine_ftl_name(sh,item.vword,ptfi->name))
			{
				return false;
			}
			if(!ymemb::func_add(sh,*cur_ptci,item.vword,false))
			{
				return false;
			}
			i=right;
		}
		ybase::arrange(v);
		return true;
	}
	
	//处理函数模板中又出现新类型的情况
	static rbool f_type_replace(tsh& sh,rbuf<tword>& v)
	{
		int cur=sh.m_class.count();
		if(!yclasstl::type_replace(sh,v))
		{
			return false;
		}
		if(sh.m_class.count()>cur)
		{
			for(tclass* p=sh.m_class.begin();
				p!=sh.m_class.end();p=sh.m_class.next(p))
			{
				if(!f_proc_class(sh,*p))
				{
					return false;
				}
			}
		}
		return true;
	}
	
	static rbool f_proc_class(tsh& sh,tclass& tci)
	{
		ifn(ymemb::a_class(sh,tci))
		{
			return false;
		}
		ifn(ymemb::recursion_get_size(sh,tci))
		{
			return false;
		}
		ymemb::obtain_size_func(sh,tci);
		return true;
	}

	static rbool combine_ftl_name(const tsh& sh,rbuf<tword>& v,const rstr& name)
	{
		for(int i=1;i<v.count();i++)
		{
			if(v[i]!=rsoptr(c_tbk_l))
			{
				continue;
			}
			if(name!=v[i-1].val)
			{
				continue;
			}
			int left=i;
			int right=ybase::find_symm_tbk(sh,v,left);
			if(right>=v.count())
			{
				rserror(v[left-1],"miss >");
				return false;
			}
			for(int j=left;j<=right;j++)
			{
				v[left-1].val+=v[j].val;
				v[j].val.clear();
			}
			i=right;
		}
		ybase::arrange(v);
		return true;
	}
};
﻿#pragma once

#include "yfind.h"
#include "ymemb.h"

struct ylambda
{
	//闭包处理，todo:闭包暂时不能使用类型推断,不是线程安全
	static void lambda_pack(tsh& sh,const rbuf<tword>& vhead,
		const rbuf<tword>& vbody,const tfunc& tfi,tfunc& lambda)
	{
		tclass item;
		for(int i=0;i<vbody.count();i++)
		{
			ifn(vbody[i].is_name())
			{
				continue;
			}
			if(yfind::is_class_t(sh,vbody[i].val))
			{
				continue;
			}
			//todo 未判断重复
			tdata* ptdi=yfind::local_search(tfi,vbody[i].val);
			tdata tdi;
			if(null==ptdi)
			{
				int pos=vhead.find(vbody[i]);
				if(pos>=vhead.count()||pos==0)
				{
					continue;
				}
				ifn(yfind::is_class_t(sh,vhead[pos-1].val))
				{
					continue;
				}
				ptdi=&tdi;
				ptdi->type=vhead[pos-1].val;
			}
			else
			{
				tdi.type=ptdi->type;
				ptdi=&tdi;
			}
			ptdi->name=vbody[i].val;
			ptdi->count=1;
			ptdi->size=yfind::get_type_size(sh,ptdi->type);
			if(ptdi->size==0)
			{
				continue;
			}
			item.vdata.push(*ptdi);
		}
		if(item.vdata.empty())
		{
			return;
		}
		item.is_friend=true;
		item.name=lambda.name+"_C";
		for(int i=0;i<item.vdata.count();i++)
		{
			item.vdata[i].off=item.size;
			item.size+=item.vdata[i].size;
		}
		lambda.lambda_data.set_size(item.size);
		sh.m_class.insert_c(item);
	}

	static rbool lambda_replace(tsh& sh,tfunc& tfi)
	{
		tclass& tci=*tfi.ptci;
		rbuf<tword>& v=tfi.vword;
		for(int i=0;i<v.count();i++)
		{
			if(v[i]!=rskey(c_lambda))
			{
				continue;
			}
			if(v.get(i+1)!=rsoptr(c_sbk_l))
			{
				continue;
			}
			int right=ybase::find_symm_sbk(sh,v,i+1);
			if(right>=v.count())
			{
				continue;
			}
			int left=right+1;
			if(v.get(left)!=rsoptr(c_bbk_l))
			{
				continue;
			}
			right=ybase::find_symm_bbk(sh,v,left);
			if(right>=v.count())
			{
				continue;
			}
			v[i].val=rstr("_LAMBDA")+tci.vfunc.count();
			ifn(ymemb::func_add(sh,tci,v.sub(i,right+1),false))
			{
				return false;
			}
			tfunc* ptfi=yfind::func_search(tci,v[i].val);
			if(ptfi!=null)
			{
				lambda_pack(sh,v.sub(0,i),
					v.sub(left+1,right),tfi,*ptfi);
			}
			v[i].multi.push("(");
			v[i].multi.push("&");
			v[i].multi.push(tci.name);
			v[i].multi.push(".");
			v[i].multi.push(v[i].val);
			v[i].multi.push(")");
			ybase::clear_word_val(v,i,right+1);
			i=right;
		}
		ybase::arrange(v);
		return true;
	}

	static rstr lambda_get(const rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val.sub(0,7)=="_LAMBDA")
			{
				return v[i].val;
			}
		}
		return rstr();
	}

	static void lambda_push_type(const rstr& name,tfunc& tfi)
	{
		tdata item;
		item.name=name+"_C_P";
		item.type=name+"_C&";
		item.size=4;
		tfi.local.push(item);
	}

	static void lambda_proc(const tsh& sh,tfunc& tfi)
	{
		tclass& tci=*tfi.ptci;
		rbuf<tsent>& v=tfi.vsent;
		for(int i=0;i<v.count();i++)
		{
			rstr name=lambda_get(v[i].vword);
			if(name.empty())
			{
				continue;
			}
			tfunc* ptfi=yfind::func_search(tci,name);
			if(ptfi==null||ptfi->lambda_data.empty())
			{
				continue;
			}
			tclass* ptci=yfind::class_search(sh,name+"_C");
			if(ptci==null||ptci->vdata.empty())
			{
				continue;
			}
			rstr data_name=name+"_C_P";
			lambda_push_type(name,tfi);
			tword word;
			word.pos=v[i].vword.get_bottom().pos;
			rbuf<tword> vtemp;
			ybase::push_twi(vtemp,word,"mov");
			ybase::push_twi(vtemp,word,data_name);
			ybase::push_twi(vtemp,word,",");
			if(sh.m_mode==tsh::c_vm||sh.m_mode==tsh::c_jit)
			{
				ybase::push_twi(vtemp,word,
					rstr((uint)(ptfi->lambda_data.begin())));
			}
			else
			{
				ybase::push_twi(vtemp,word,ptfi->name+"_C_P_A");
			}
			ybase::push_twi(vtemp,word,";");
			for(int j=0;j<ptci->vdata.count();j++)
			{
				ybase::push_twi(vtemp,word,data_name);
				ybase::push_twi(vtemp,word,".");
				ybase::push_twi(vtemp,word,ptci->vdata[j].name);
				ybase::push_twi(vtemp,word,"=");
				ybase::push_twi(vtemp,word,ptci->vdata[j].name);
				ybase::push_twi(vtemp,word,";");
			}
			vtemp+=v[i].vword;
			v[i].vword=r_move(vtemp);
		}
		ybase::part_vsent(v);
	}

	static void lambda_add_init_asm(const tsh& sh,tfunc& tfi)
	{
		if(tfi.lambda_data.empty())
		{
			return;
		}
		tsent sent;
		sent.pos=tfi.pos;
		sent.vword.push(tword(rstr("mov")));//tword没有设置pos
		sent.vword.push(tword(tfi.name+"_C_P"));
		sent.vword.push(tword(rstr(",")));
		if(sh.m_mode==tsh::c_vm||sh.m_mode==tsh::c_jit)
		{
			sent.vword.push(tword(rstr((uint)(tfi.lambda_data.begin()))));
		}
		else
		{
			sent.vword.push(tword(tfi.name+"_C_P_A"));
		}
		tfi.vsent.push_front(r_move(sent));
	}

	static void lambda_var_replace(const tsh& sh,tfunc& tfi)
	{
		if(tfi.lambda_data.empty())
		{
			return;
		}
		tclass* ptci=yfind::class_search(sh,tfi.name+"_C");
		if(ptci==null)
		{
			return;
		}
		lambda_push_type(tfi.name,tfi);
		rstr data_name=tfi.name+"_C_P";
		for(int i=0;i<tfi.vword.count();i++)
		{
			if(yfind::data_member_search(*ptci,tfi.vword[i].val)!=null)
			{
				tfi.vword[i].multi.push(data_name);
				tfi.vword[i].multi.push(".");
				tfi.vword[i].multi.push(tfi.vword[i].val);
				tfi.vword[i].val.clear();
			}
		}
		ybase::arrange(tfi.vword);
	}

	static rbool function_replace(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val!=rskey(c_js_func))
			{
				continue;
			}
			if(v.get(i+1).val!=rsoptr(c_sbk_l))
			{
				rserror(v[i],"miss (");
				return false;
			}
			v[i].multi+=rskey(c_lambda);
			v[i].multi+=rsoptr(c_sbk_l);
			v[i].multi+="var";
			v[i].multi+=",";
			v[i].multi+="var&";
			v[i].multi+="this";
			if(v.get(i+2).val!=rsoptr(c_sbk_r))
			{
				v[i].multi+=",";
			}
			v[i].val.clear();
			v[i+1].val.clear();
		}
		ybase::arrange(v);
		return true;
	}
};
﻿#pragma once

#include "yexp.h"

//惰性求值（短路求值）
struct ylazy
{
	static rbool is_and_or_name(const rstr& s)
	{
		return s=="&&(int,int)"||s=="||(int,int)";
	}

	static rbool exist_and_or(rbuf<tsent>& vsent)
	{
		for(int i=0;i<vsent.count();i++)
		{
			for(int j=0;j<vsent[i].vword.count();j++)
			{
				if(is_and_or_name(vsent[i].vword[j].val))
				{
					return true;
				}
			}
		}
		return false;
	}

	static rbool part_and_or_one(tsh& sh,tfunc& tfi,
		int& tid,rbuf<tsent>& vsent,tsent& sent,tenv env)
	{
		rbuf<tword>& v=sent.vword;
		if(sh.m_key.is_asm_ins(v.get_bottom().val))
		{
			vsent.push(sent);
			return true;
		}
		for(int i=0;i<v.count();i++)
		{
			//[int,&&(int,int),[1,2]]
			ifn(is_and_or_name(v[i].val))
			{
				continue;
			}
			if(i==3)
			{
				continue;
			}
			tclass* ptci=yfind::class_search(sh,v.get(i-2).val);
			if(null==ptci)
			{
				continue;
			}
			int left=i-3;
			if(v.get(left).val!=rsoptr(c_mbk_l))
			{
				continue;
			}
			int right=ybase::find_symm_mbk(sh,v,left);
			if(right>=v.count())
			{
				return false;
			}
			tdata tdi;
			tdi.type=ptci->name;
			tdi.name=rskey(c_ltemp)+rstr(tid);
			tid++;
			tfi.local.push(tdi);

			tsent temp;
			temp.type=rskey(c_int);
			temp.vword=v.sub(left,right+1);
			temp.pos=sent.pos;
			vsent+=temp;

			temp.type=rskey(c_void);
			temp.vword.clear();
			temp.vword+=tdi.name;
			temp.vword+=rsoptr(c_equal);
			temp.vword+=rskey(c_ebx);
			ifn(yexp::p_exp(sh,temp,tfi,0,env))
			{
				return false;
			}
			vsent+=temp;

			ybase::clear_word_val(v,left,right+1);
			v[left].val=tdi.name;
			ybase::arrange(v);
			ifn(yexp::p_exp(sh,sent,tfi,0,env))
			{
				return false;
			}
			vsent+=sent;

			return true;
		}
		vsent.push(sent);
		return true;
	}

	static rbool part_and_or(tsh& sh,tfunc& tfi,int& tid,tenv env)
	{
		rbuf<tsent> v;
		for(int i=0;i<tfi.vsent.count();i++)
		{
			ifn(part_and_or_one(sh,tfi,tid,v,tfi.vsent[i],env))
			{
				return false;
			}
		}
		tfi.vsent=r_move(v);
		return true;
	}

	static rbool extact_and_or(tsh& sh,tfunc& tfi,int& tid,tenv env)
	{
		ifn(exist_and_or(tfi.vsent))
		{
			return true;
		}
		for(int i=0;i<c_rs_deep;i++)
		{
			int cur=tfi.vsent.count();
			ifn(part_and_or(sh,tfi,tid,env))
			{
				rserror(tfi.vsent[i],"replace_and_or");
				return false;
			}
			if(cur==tfi.vsent.count())
			{
				return true;
			}
		}
		return false;
	}

	static rbool replace_and_or(tsh& sh,tfunc& tfi)
	{
		for(int i=0;i<tfi.vsent.count();i++)
		{
			ifn(replace_and_one(sh,tfi.vsent[i].vword,tfi.id))
			{
				return false;
			}
			ifn(replace_or_one(sh,tfi.vsent[i].vword,tfi.id))
			{
				return false;
			}
		}
		ybase::part_vsent(tfi.vsent);
		return true;
	}

	static rbool replace_and_one(tsh& sh,rbuf<tword>& v,int& id)
	{
		if(v.get(3)!=rstr("&&(int,int)"))
		{
			return true;
		}
		if(v.get_left()!=rsoptr(c_mbk_l))
		{
			return false;
		}
		if(v.get_right()!=rsoptr(c_mbk_r))
		{
			return false;
		}
		rbuf<rbuf<tword> > param=ybase::comma_split<tword>(sh,v.sub(6,v.count()-2));
		if(param.count()!=2)
		{
			return false;
		}
		rbuf<tword> result;
		result+=param[0];
		result+=rsoptr(c_semi);
		result+=rskey(c_jebxz);
		result+=rstr("_and_false_")+id;
		result+=rsoptr(c_semi);
		result+=param[1];
		result+=rsoptr(c_semi);
		result+=rstr("cnesb");
		result+=rstr("ebx");
		result+=rstr(",");
		result+=rstr("0");
		result+=rsoptr(c_semi);
		result+=rskey(c_jmp);
		result+=rstr("_and_end_")+(id+1);
		result+=rsoptr(c_semi);
		result+=rstr("_and_false_")+id;
		result+=rstr(":");
		result+=rsoptr(c_semi);
		result+=rstr("mov");
		result+=rstr("ebx");
		result+=rstr(",");
		result+=rstr("0");
		result+=rsoptr(c_semi);
		result+=rstr("_and_end_")+(id+1);
		result+=rstr(":");
		result+=rsoptr(c_semi);
		id+=2;
		v=r_move(result);
		return true;
	}

	static rbool replace_or_one(tsh& sh,rbuf<tword>& v,int& id)
	{
		if(v.get(3)!=rstr("||(int,int)"))
		{
			return true;
		}
		if(v.get_left()!=rsoptr(c_mbk_l))
		{
			return false;
		}
		if(v.get_right()!=rsoptr(c_mbk_r))
		{
			return false;
		}
		rbuf<rbuf<tword> > param=ybase::comma_split<tword>(sh,v.sub(6,v.count()-2));
		if(param.count()!=2)
		{
			return false;
		}
		rbuf<tword> result;
		result+=param[0];
		result+=rsoptr(c_semi);
		result+=rskey(c_jebxnz);
		result+=rstr("_or_true_")+id;
		result+=rsoptr(c_semi);
		result+=param[1];
		result+=rsoptr(c_semi);
		result+=rstr("cnesb");
		result+=rstr("ebx");
		result+=rstr(",");
		result+=rstr("0");
		result+=rsoptr(c_semi);
		result+=rskey(c_jmp);
		result+=rstr("_or_end_")+(id+1);
		result+=rsoptr(c_semi);
		result+=rstr("_or_true_")+id;
		result+=rstr(":");
		result+=rsoptr(c_semi);
		result+=rstr("mov");
		result+=rstr("ebx");
		result+=rstr(",");
		result+=rstr("1");
		result+=rsoptr(c_semi);
		result+=rstr("_or_end_")+(id+1);
		result+=rstr(":");
		result+=rsoptr(c_semi);
		id+=2;
		v=r_move(result);
		return true;
	}
};
﻿#pragma once

#include "yfind.h"
#include "ysuper.h"

//宏替换类
struct ymac
{
	static rbool func_mac_replace(const tsh& sh,rbuf<tsent>& vsent)
	{
		for(int i=0;i<vsent.count();++i)
		{
			ifn(func_mac_replace(sh,vsent[i].vword))
			{
				rserror(vsent[i],"func mac error");
				return false;
			}
		}
		ybase::part_vsent(vsent);
		return true;
	}

	static rbool func_mac_replace(const tsh& sh,rbuf<tword>& v)
	{
		if(v.get(0)!=rsoptr(c_sharp))
		{
			return true;
		}
		int right=v.find_last(tword(rsoptr(c_sbk_r)));
		if(right>=v.count())
		{
			return false;
		}
		int left=ybase::find_symm_word_rev(v,rsoptr(c_sbk_l),rsoptr(c_sbk_r),
			0,right+1);
		if(left>=v.count())
		{
			return false;
		}
		rbuf<rbuf<tword> > temp;
		temp=ybase::comma_split_e(sh,v.sub(left+1,right));
		rbuf<tword> head=v.sub(1,left+1);
		rbuf<tword> result;
		if(temp.count()==1&&yfind::is_class(sh,temp[0].get_top().val))
		{
			tclass* ptci=yfind::class_search(sh,temp[0].get_top().val);
			if(ptci==null)
			{
				return false;
			}
			if(temp[0].count()==1)
			{
				for(int i=0;i<ptci->vdata.count();i++)
				{
					result+=head;
					result+=ptci->vdata[i].name;
					result+=tword(rsoptr(c_sbk_r));
					result+=tword(rsoptr(c_semi));
					//todo 单词没有行号
				}
			}
			else
			{
				for(tfunc* p=ptci->vfunc.begin();p!=ptci->vfunc.end();
					p=ptci->vfunc.next(p))
				{
					result+=head;
					result+=tword(rsoptr(c_addr));
					result+=ptci->name;
					result+=tword(rsoptr(c_dot));
					result+=p->name;
					result+=tword(rsoptr(c_sbk_l));
					for(int j=0;j<p->param.count();j++)
					{
						if(j!=0)
						{
							result+=tword(rsoptr(c_comma));
						}
						result+=p->param[j].type;
					}
					result+=tword(rsoptr(c_sbk_r));
					result+=tword(rsoptr(c_sbk_r));
					result+=tword(rsoptr(c_semi));
				}
			}
		}
		else
		{
			for(int i=0;i<temp.count();i++)
			{
				result+=head;
				result+=temp[i];
				result+=tword(rsoptr(c_sbk_r));
				result+=tword(rsoptr(c_semi));
			}
		}
		if(result.empty())
		{
			return false;
		}
		v=r_move(result);
		return true;
	}

	static rbool replace(const tsh& sh,const tclass& tci,rbuf<tword>& v)
	{
		for(int i=0;i<c_rs_deep;i++)
		{
			ifn(replace_v(sh,tci,v))
			{
				return false;
			}
			ifn(ybase::arrange(v))
			{
				return true;
			}
		}
		return false;
	}

	static rbool replace_v(const tsh& sh,const tclass& tci,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			const tclass* ptci=&tci;
			int right=i;
			tmac item;
			item.name=v[i].val;
			if(ptci->vmac.exist(item))
			{
				ifn(i>1&&v.get(i-1).val==rsoptr(c_dot))
				{
					if(!replace_param(sh,v,i,
						*ptci->vmac.find(item),right))
					{
						return false;
					}
					i=right;
					continue;
				}
			}
			ptci=sh.m_main;
			if(ptci->vmac.exist(item))
			{
				ifn(i>1&&v.get(i-1).val==rsoptr(c_dot))
				{
					if(!replace_param(sh,v,i,
						*ptci->vmac.find(item),right))
					{
						return false;
					}
					i=right;
					continue;
				}
			}
			if(i==0||v[i].val!=rsoptr(c_dot)||i==v.count()-1)
			{
				continue;
			}
			if(i>=2&&v[i-2].val==rsoptr(c_dot))
			{
				continue;
			}
			ptci=yfind::class_search(sh,v[i-1].val);
			if(null==ptci)
			{
				continue;
			}
			i++;
			item.name=v.get(i).val;
			if(ptci->vmac.exist(item))
			{
				if(!replace_param(sh,v,i,*ptci->vmac.find(item),right))
				{
					return false;
				}
				v[i-1].clear();
				v[i-2].clear();
				i=right;
			}
		}
		return true;
	}

	static rbool replace_param(const tsh& sh,rbuf<tword>& v,int& i,
		tmac& mitem,int& right)
	{
		if(mitem.is_super)
		{
			return ysuper::replace_item(sh,v,right,mitem);
		}
		else
		{
			return replace_param_common(sh,v,i,mitem,right);
		}
	}

	static rbool replace_param_common(const tsh& sh,rbuf<tword>& v,int& i,
		tmac& mitem,int& right)
	{
		int left=i+1;
		rbuf<rbuf<rstr> > param;
		if(v.get(left).val==rsoptr(c_sbk_l))
		{
			right=ybase::find_symm_sbk(sh,v,left);
			if(right>=v.count())
			{
				rserror(v.get(i),"miss )");
				return false;
			}
			rbuf<rbuf<tword> > temp;
			temp=ybase::comma_split<tword>(sh,v.sub(left+1,right));
			for(int j=0;j<temp.count();j++)
			{
				param.push(ybase::vword_to_vstr(temp[j]));
			}
			if(!replace_w(v[i],param,mitem))
			{
				rserror(v.get(i));
				return false;
			}
			ybase::clear_word_val(v,left,right+1);
		}
		else
		{
			if(!replace_w(v[i],param,mitem))
			{
				rserror(v.get(i));
				return false;
			}
		}
		return true;
	}

	static rbool replace_w(tword& word,rbuf<rbuf<rstr> >& param,tmac& mitem)
	{
		if(param.count()!=mitem.param.count())
		{
			return false;
		}
		word.val.clear();
		if(param.empty())
		{
			word.multi=mitem.vstr;
			return true;
		}
		for(int i=0;i<mitem.vstr.count();i++)
		{
			int j;
			for(j=0;j<mitem.param.count();j++)
			{
				if(mitem.param[j]==mitem.vstr[i])
				{
					word.multi+=param[j];
					break;
				}
			}
			if(j>=mitem.param.count())
			{
				word.multi.push(mitem.vstr[i]);
			}
		}
		return true;
	}
};
﻿#pragma once

#include "yfind.h"

struct ymatch
{
	//可构造转换传递
	static rbool is_construct_pass(const tsh& sh,const tsent& src,const rstr& dst)
	{
		tclass* ptci=yfind::class_search_t(sh,dst);
		if(ptci==null)
		{
			return false;
		}
		tfunc* ptfi=yfind::func_search(*ptci,ybase::get_tname(dst),
			ybase::get_tname(dst)+rsoptr(c_addr),
			ybase::get_tname(src.type)+rsoptr(c_addr));
		if(ptfi!=null)
		{
			return true;
		}
		return null!=yfind::func_search(*ptci,ybase::get_tname(dst),
			ybase::get_tname(dst)+rsoptr(c_addr),ybase::get_tname(src.type));
	}

	//可直接传递，返回对象可传递引用
	static rbool is_direct_pass(const tsh& sh,const tsent& src,const rstr& dst)
	{
		if(ybase::is_point(src.type)&&ybase::is_point(dst))
		{
			return true;
		}
		if(dst==rskey(c_rd32)&&yfind::get_type_size(sh,src.type)==4)
		{
			return true;
		}
		return ybase::get_tname(src.type)==ybase::get_tname(dst);
	}

	//是否直接传递或构造转换传递
	static rbool is_direct_construct_pass_m(const tsh& sh,const rbuf<tsent>& vsent,
		const rbuf<tdata>& vparam)
	{
		if(vsent.count()!=vparam.count())
		{
			return false;
		}
		for(int i=0;i<vsent.count();i++)
		{
			if(!is_direct_pass(sh,vsent[i],vparam[i].type)&&
				!is_construct_pass(sh,vsent[i],vparam[i].type))
			{
				return false;
			}
		}
		return true;
	}

	//查找直接传递或构造转换传递
	static tfunc* find_direct_construct_pass(const tsh& sh,const tclass& tci,const rstr& fname,
		const rbuf<tsent>& vsent)
	{
		for(tfunc* p=tci.vfunc.begin();p!=tci.vfunc.end();p=tci.vfunc.next(p))
		{
			if(fname!=p->name)
			{
				continue;
			}
			if(is_direct_construct_pass_m(sh,vsent,p->param))
			{
				return p;
			}
		}
		return null;
	}

	//可完全传递，临时对象可传递引用，常量和返回对象不可传递引用
	static rbool is_full_pass(const tsh& sh,const tsent& src,const rstr& dst)
	{
		if(!is_direct_pass(sh,src,dst))
		{
			return false;
		}
		if(src.vword.count()==1&&
			(src.vword[0].is_const()||
			sh.m_key.is_asm_reg(src.vword[0].val))&&
			ybase::is_quote(dst))
		{
			return false;
		}
		if(src.vword.count()==7&&
			ybase::is_quote(dst)&&
			src.vword[1].val==rsoptr(c_addr)&&
			src.vword[0].val==rsoptr(c_mbk_l))
		{
			return false;
		}
		if(is_temp_var(sh,src))
		{
			return true;
		}
		return !ybase::is_quote(dst)||!is_ret_obj(sh,src.vword);
	}

	static rbool is_full_pass_m(const tsh& sh,const rbuf<tsent>& vsent,const rbuf<tdata>& vparam)
	{
		if(vsent.count()!=vparam.count())
		{
			return false;
		}
		for(int i=0;i<vsent.count();i++)
		{
			if(!is_full_pass(sh,vsent[i],vparam[i].type))
			{
				return false;
			}
		}
		return true;
	}

	static tfunc* find_full_pass(const tsh& sh,const tclass& tci,const rstr& fname,
		const rbuf<tsent>& vsent)
	{
		for(tfunc* p=tci.vfunc.begin();p!=tci.vfunc.end();p=tci.vfunc.next(p))
		{
			if(fname!=p->name)
			{
				continue;
			}
			if(is_full_pass_m(sh,vsent,p->param))
			{
				return p;
			}
		}
		return null;
	}

	static rbool is_temp_var(const tsh& sh,const tsent& sent)
	{
		return (!ybase::is_quote(sent.type)&&
			sent.vword.count()>=3&&sent.type==sent.vword[2].val&&
			sent.vword[1].val==rskey(c_btemp));
	}

	//重载的友元属性和返回值类型必须相同
	static rbool is_ret_obj(const tsh& sh,const rbuf<tword>& v)
	{
		if(v.count()<3)
		{
			return false;
		}
		int start=0;
		while(start+2<v.count()&&
			v[start+1].val==rsoptr(c_dot)&&
			v[start].val==rsoptr(c_mbk_l))
		{
			start+=3;
		}
		if(v[start].val==rsoptr(c_mbk_l))
		{
			start++;
		}
		if(start+2>=v.count())
		{
			return false;
		}
		if(v[start].val==rskey(c_pcall))
		{
			return !ybase::is_quote(v[start+2].val);
		}
		tclass* ptci=yfind::class_search(sh,v[start].val);
		if(ptci==null)
		{
			return false;
		}
		tfunc* ptfi=yfind::func_search_dec(*ptci,v[start+2].val);
		if(ptfi==null)
		{
			return false;
		}
		return !ybase::is_quote(ptfi->retval.type);
	}

	static void insert_type(const tsh& sh,tsent& sent,const rstr& type)
	{
		rbuf<tword> result;
		result+=rsoptr(c_mbk_l);
		result+=rskey(c_btemp);
		result+=rsoptr(c_comma);
		result+=type;
		result+=rsoptr(c_comma);
		result+=rsoptr(c_mbk_l);
		result+=sent.vword;
		result+=rsoptr(c_mbk_r);
		result+=rsoptr(c_mbk_r);
		sent.vword=r_move(result);
		sent.type=type;
	}

	//先完全传递，找不到再尝试替换单词
	static tfunc* find_replace(const tsh& sh,const tclass& tci,const rstr& fname,
		rbuf<tsent>& vsent)
	{
		tfunc* ptfi=find_full_pass(sh,tci,fname,vsent);
		if(ptfi!=null)
		{
			return ptfi;
		}
		//可能找到多个，只取第一个
		ptfi=find_direct_construct_pass(sh,tci,fname,vsent);
		if(ptfi==null)
		{
			return null;
		}
		for(int i=0;i<vsent.count();i++)
		{
			//这里也可以用 if is_direct_construct_pass
			ifn(is_full_pass(sh,vsent[i],ptfi->param[i].type))
			{
				insert_type(sh,vsent[i],
					ybase::get_tname(ptfi->param[i].type));
			}
		}
		return ptfi;
	}
};
﻿#pragma once

#include "yautof.h"
#include "ysuper.h"

//提取类内部的成员，函数默认参数处理
//zclass::vword->vdata,vfunc,vmac
struct ymemb
{
	static rbool process(tsh& sh)
	{
		for(tclass* p=sh.m_class.begin();
			p!=sh.m_class.end();p=sh.m_class.next(p))
		{
			ifn(a_class(sh,*p))
			{
				return false;
			}
		}
		for(tclass* p=sh.m_class.begin();
			p!=sh.m_class.end();p=sh.m_class.next(p))
		{
			ifn(recursion_get_size(sh,*p))
			{
				return false;
			}
			if(p->name==rskey(c_main))
			{
				sh.m_main_data.set_size(p->size);
			}
		}
		//简便起见，重复获取参数大小也没关系
		for(tclass* p=sh.m_class.begin();
			p!=sh.m_class.end();p=sh.m_class.next(p))
		{
			obtain_size_func(sh,*p);
		}
		return true;
	}

	//解析一个类
	static rbool a_class(tsh& sh,tclass& tci)
	{
		if(tci.vword.empty())
		{
			return true;
		}
		ifn(analyse(sh,tci))
		{
			return false;
		}
		ifn(yautof::auto_add_func(sh,tci))
		{
			return false;
		}
		tci.vword.free();
		return true;
	}

	static rbool recursion_get_size(tsh& sh,tclass& tci,int level=0)
	{
		if(level>c_rs_deep)
		{
			rserror(rstr("level overflow ")+tci.name);
			return false;
		}
		level++;
		if(tci.size>0||tci.size==0&&tci.vdata.empty())
		{
			return true;
		}	
		int size=0;
		for(int i=0;i<tci.vdata.count();i++)
		{
			if(ybase::is_point_quote(tci.vdata[i].type))
			{
				tci.vdata[i].off=size;
				tci.vdata[i].size=c_point_size;
				size+=tci.vdata[i].size*tci.vdata[i].count;
			}
			else
			{
				tclass* ptci=yfind::class_search(sh,tci.vdata[i].type);
				if(null==ptci)
				{
					rserror(rstr("can't find ")+tci.vdata[i].type);
					return false;
				}
				if(!recursion_get_size(sh,*ptci,level))
				{
					return false;
				}
				tci.vdata[i].off=size;
				tci.vdata[i].size=ptci->size;
				size+=tci.vdata[i].size*tci.vdata[i].count;
			}
		}
		tci.size=size;
		return true;
	}

	static rbool analyse(tsh& sh,tclass& tci)
	{
		rbuf<tword>& v=tci.vword;
		int i;
		for(i=0;i<v.count();i++)
		{
			if(v[i].val==rskey(c_enum))
			{
				int left=i+1;
				if(v.get(left).val!=rsoptr(c_bbk_l))
				{
					rserror(v.get(i),"miss {");
					return false;
				}
				int right=ybase::find_symm_bbk(sh,v,left);
				if(right>=v.count())
				{
					rserror(v.get(i),"miss }");
					return false;
				}
				ifn(enum_add(sh,tci,v.sub(left+1,right)))
				{
					return false;
				}
				i=right;
			}
			elif(v[i].val==rskey(c_mac))
			{
				int right;
				if(!mac_add(sh,tci,v,i,right))
				{
					return false;
				}
				i=right;
			}
			elif(v[i].val==rskey(c_template))
			{
				int left=v.find(rsoptr(c_bbk_l),i+1);
				if(left>=v.count())
				{
					rserror(v.get(i));
					return false;
				}
				int right=ybase::find_symm_bbk(sh,v,left);
				if(right>=v.count())
				{
					rserror(v.get(i),"miss }");
					return false;
				}
				if(!func_add(sh,tci,v.sub(i,right+1)))
				{
					return false;
				}
				i=right;
			}
			else
			{
				for(int j=i;j<v.count();j++)
				{
					if(v[j].val==rsoptr(c_semi))
					{
						if(!data_add(sh,tci,v.sub(i,j)))
						{
							return false;
						}
						i=j;
						break;
					}
					if(v[j].val==rsoptr(c_sbk_l))
					{
						j=ybase::find_symm_sbk(sh,v,j);
						if(j>=v.count())
						{
							rserror(v.get(i));
							return false;
						}
						if(v.get(j+1).val==rsoptr(c_bbk_l))
						{
							int right=ybase::find_symm_bbk(sh,v,j+1);
							if(right>=v.count())
							{
								rserror(v.get(i));
								return false;
							}
							if(!func_add(sh,tci,v.sub(i,right+1)))
							{
								return false;
							}
							i=right;
							break;
						}
					}
					if(v[j].pos!=v.get(j+1).pos)
					{
						if(!data_add(sh,tci,v.sub(i,j+1)))
						{
							return false;
						}
						i=j;
						break;
					}
				}
			}
		}
		return true;
	}

	static rbool enum_add(const tsh& sh,tclass& tci,const rbuf<tword>& v)
	{
		uint enum_val=0;
		for(int j=0;j<v.count();j++)
		{
			if(v[j].val==rsoptr(c_comma)||v[j].val==rsoptr(c_semi))
			{
				continue;
			}
			tmac eitem;
			eitem.name=v[j].val;
			if(v.get(j+1).val==rsoptr(c_equal))
			{
				if(v.get(j+2)==rsoptr(c_sbk_l))
				{
					enum_val=v.get(j+3).val.touint();
					eitem.vstr.push(rstr(enum_val));
					enum_val++;
					j+=4;
				}
				else
				{
					enum_val=v.get(j+2).val.touint();
					eitem.vstr.push(rstr(enum_val));
					enum_val++;
					j+=2;
				}
			}
			else
			{
				eitem.vstr.push(rstr(enum_val));
				enum_val++;
			}
			if(tci.vmac.exist(eitem))
			{
				rserror(v.get_bottom(),"enum redefined");
				return false;
			}
			tci.vmac.insert(eitem);
		}
		return true;
	}

	static rbool mac_add(const tsh& sh,tclass& tci,const rbuf<tword>& v,int i,int& right)
	{
		if(v.get(i+1).val=="$")
		{
			ifn(ysuper::add_super_mac(sh,v,i,tci.vmac))
			{
				return false;
			}
			right=i;
			return true;
		}
		tmac mitem;
		int left=i+2;
		mitem.name=v.get(left-1).val;
		if(mitem.name.empty())
		{
			rserror(v.get(i),"mac miss name");
			return false;
		}
		if(v.get(left).val==rsoptr(c_sbk_l))
		{
			right=ybase::find_symm_sbk(sh,v,left);
			if(right>=v.count())
			{
				rserror(v.get(i),"miss )");
				return false;
			}
			rbuf<rbuf<rstr> > temp=r_split_a<rstr>(
				ybase::vword_to_vstr(v.sub(left+1,right)),
				rsoptr(c_comma));
			for(int j=0;j<temp.count();j++)
			{
				mitem.param.push(temp[j].get(0));
			}
			right++;
			left=right;
		}
		right=left;
		if(v.get(left).val==rsoptr(c_bbk_l))
		{
			right=ybase::find_symm_bbk(sh,v,left);
			if(right>=v.count())
			{
				rserror(v.get(i),"miss }");
				return false;
			}
			for(int j=left+1;j<right;j++)
			{
				mitem.vstr.push(v[j].val);
			}
		}
		else
		{
			for(;right<v.count()&&v[right].pos==v[i].pos;right++)
			{
				;
			}
			right--;
			if(right>=v.count())
			{
				rserror(v.get(i),"miss mac");
				return false;
			}
			if(mitem.param.empty())
			{
				for(int j=left;j<=right;j++)
				{
					mitem.vstr.push(v[j].val);
				}
			}
			else
			{
				for(int j=left;j<=right;j++)
				{
					if(mitem.param.exist(v[j].val))
					{
						mitem.vstr.push(v[j].val);
					}
					else
					{
						mitem.vstr.push(v[j].val);
					}
				}
			}
		}
		if(tci.vmac.exist(mitem))
		{
			rserror(v.get_bottom(),"mac redefined");
			return false;
		}
		tci.vmac.insert(mitem);
		return true;
	}

	static rbool a_data_define(const tsh& sh,tdata& item,const rbuf<tword>& vword)
	{
		int pos=vword.find(tword(rsoptr(c_equal)));
		if(pos<vword.count())
		{
			for(int i=pos+1;i<vword.count();i++)
			{
				item.param.push(vword[i]);
			}
		}
		else
		{
			pos=vword.find(tword(rsoptr(c_sbk_l)));
			if(pos<vword.count())
			{
				for(int i=pos+1;i<vword.count()-1;i++)
				{
					item.param.push(vword[i]);
				}
			}
		}
		//process func template
		if(vword.get(1).val==rsoptr(c_tbk_l))
		{
			int end=ybase::find_symm_tbk(sh,vword,1);
			if(end>=vword.count())
			{
				rserror(vword.get(0),"miss >");
				return false;
			}
			for(int i=0;i<end;i++)
			{
				item.type+=vword[i].val;
			}
			int pointpos=end+1;
			for(;pointpos<pos;++pointpos)
			{
				if(vword[pointpos].val!=rsoptr(c_addr)&&
					vword[pointpos].val!=rsoptr(c_mul))
				{
					break;
				}
				item.type+=vword[pointpos].val;
			}
			item.name=vword.get(pointpos).val;
		}
		else
		{
			item.type=vword.get(0).val;
			if(yfind::is_class_t(sh,item.type))
			{
				item.name=vword.get(1).val;
			}
			else
			{
				//item.type="var&";
				//item.name=vword.get(0).val;
				rserror(vword.get(0),"miss data type or name");
				return false;
			}
		}
		if(item.type.empty()||item.name.empty())
		{
			rserror(vword.get(0),"miss data type or name");
			return false;
		}
		item.count=1;
		if(vword.get(2)==rsoptr(c_mbk_l))
		{
			if(vword.get(4)!=rsoptr(c_mbk_r))
			{
				rserror(vword.get(0),"data array error");
				return false;
			}
			//保存数组个数
			item.count=vword.get(3).val.toint();
		}
		return true;
	}

	static rbool lambda_a_func_define(const tsh& sh,tfunc& item,const rbuf<tword>& v)
	{
		if(v.get(1)!=rsoptr(c_sbk_l))
		{
			rserror(v.get(0),"miss (");
			return false;
		}
		item.name=v.get(0).val;
		int right=ybase::find_symm_sbk(sh,v,1);
		if(right>=v.count())
		{
			rserror(v.get(0),"miss )");
			return false;
		}
		rbuf<tword> param=v.sub(2,right);
		rbuf<rbuf<tword> > list=ybase::comma_split<tword>(sh,param);
		int i=0;
		//如果第一个参数只有类型，则表明是返回值
		if(!list.empty()&&list[0].count()==1&&
			yfind::is_class_t(sh,list[0].get_bottom().val))
		{
			item.retval.type=list[0].get_bottom().val;
			i++;
		}
		else
		{
			item.retval.type=rskey(c_void);
		}
		item.retval.name=rskey(c_s_ret);
		for(;i<list.count();i++)
		{
			if(list[i].empty())
			{
				continue;
			}
			tdata ditem;
			ifn(a_data_define(sh,ditem,list[i]))
			{
				return false;
			}
			item.param.push(ditem);
		}
		return true;
	}

	static rbool a_func_define(const tsh& sh,tfunc& item,const rbuf<tword>& v,
		rbool lambda=false)
	{
		item.name.clear();
		if(v.get_bottom().val.sub(0,7)=="_LAMBDA")
		{
			return lambda_a_func_define(sh,item,v);
		}
		int start=0;
		for(;start<v.count();start++)
		{
			if(v[start].val==rskey(c_friend))
			{
				item.is_friend=true;
			}
			elif(v[start].val==rskey(c_cfunc))
			{
				item.is_cfunc=true;
			}
			elif(v[start].val=="macro")
			{
				item.is_macro=true;
				item.is_cfunc=true;
			}
			elif(v[start].val==rskey(c_dynamic))
			{
				item.is_dynamic=true;
			}
			elif(v[start].val=="final")
			{
				item.is_final=true;
			}
			else
			{
				break;
			}
		}
		if(lambda)
		{
			if(yfind::is_class_t(sh,v.get(start).val))
			{
				item.retval.type=v.get(start).val;
				start++;
			}
			else
			{
				item.retval.type=rskey(c_void);
			}
		}
		else
		{
			if(yfind::is_class_t(sh,v.get(start).val)
				&&v.get(start+1).val!=rsoptr(c_sbk_l)
				&&!v.get(start+1).val.empty())
			{
				item.retval.type=v.get(start).val;
				start++;
			}
			else
			{
				item.retval.type=rskey(c_void);
			}
		}
		if(item.retval.type.empty())
		{
			rserror(v.get(0),"miss ret type");
			return false;
		}
		item.retval.name=rskey(c_s_ret);
		if(v.get(start).val==rsoptr(c_destruct))
		{
			item.name+=v.get(start).val;
			start++;
			item.name+=v.get(start).val;
			start++;
		}
		elif(lambda&&(
			v.get(start)==rsoptr(c_bbk_l)||
			v.get(start)==rsoptr(c_sbk_l)))
		{
			item.name+="_SELF";
		}
		elif(sh.m_optr.is_optr(v.get(start).val))
		{
			item.name=v.get(start).val;
			if(v.get(start).val==rsoptr(c_mbk_l))
			{
				start++;
				item.name+=v.get(start).val;
			}
			start++;
		}
		else
		{
			item.name+=v.get(start).val;
			start++;
		}
		if(item.name.empty())
		{
			rserror(v.get(0),"miss func name");
			return false;
		}
		rbuf<rbuf<tword> > list;
		int right;
		if(v.get(start).val==rsoptr(c_sbk_l))
		{
			right=ybase::find_symm_sbk(sh,v,start);
			if(right>=v.count())
			{
				rserror(v.get(0),"miss )");
				return false;
			}
			list=ybase::comma_split<tword>(sh,v.sub(start+1,right));
		}
		else
		{
			list=ybase::comma_split<tword>(sh,v.sub(start));
		}
		for(int i=0;i<list.count();i++)
		{
			if(list[i].empty())
			{
				continue;
			}
			tdata ditem;
			ifn(a_data_define(sh,ditem,list[i]))
			{
				return false;
			}
			item.param.push(ditem);
		}
		return true;
	}

	static rbool data_add(const tsh& sh,tclass& tci,const rbuf<tword>& v)
	{
		if(v.empty())
		{
			return true;
		}
		tdata item;
		if(!a_data_define(sh,item,v))
		{
			return false;
		}
		if(tci.vdata.exist(item))
		{
			rserror(v.get_bottom(),"data member redefined");
			return false;
		}
		tci.vdata.push(item);
		return true;
	}

	static rbool combine_tl_name(const tsh& sh,rbuf<tword>& v)
	{
		v=v.sub(2);
		int sbk_left=v.count();
		if(v.get_top()!=rsoptr(c_sbk_r))
		{
			return false;
		}
		sbk_left=ybase::find_symm_word_rev(v,
			rsoptr(c_sbk_l),rsoptr(c_sbk_r),
			0,v.count());
		if(sbk_left>=v.count())
		{
			return false;
		}
		int tbk_right=sbk_left-1;
		int tbk_left=ybase::find_symm_word_rev(v,
			rsoptr(c_tbk_l),rsoptr(c_tbk_r),
			0,sbk_left);
		if(tbk_left>=v.count())
		{
			return false;
		}
		ifn(v.get(tbk_left-1).is_name())
		{
			return false;
		}
		v[tbk_left-1].val+=rstr::join<rstr>(
			ybase::vword_to_vstr(v.sub(tbk_left,tbk_right+1)),
			rstr());
		ybase::clear_word_val(v,tbk_left,tbk_right+1);
		ybase::arrange(v);
		return true;
	}

	static rbool have_move(const tsh& sh,const rbuf<tword>& v)
	{
		int sbk_left=v.count();
		if(v.get_top()!=rsoptr(c_sbk_r))
		{
			return false;
		}
		sbk_left=ybase::find_symm_word_rev(v,
			rsoptr(c_sbk_l),rsoptr(c_sbk_r),
			0,v.count());
		if(sbk_left>=v.count())
		{
			return false;
		}
		for(int i=sbk_left;i<v.count();i++)
		{
			if(v[i]==rsoptr(c_and)&&yfind::is_class(sh,v.get(i-1).val))
			{
				return true;
			}
		}
		return false;
	}
	
	static rbool func_add(tsh& sh,tclass& tci,const rbuf<tword>& v,
		rbool check_tl=true)
	{
		tfunc item;
		int left=v.find(tword(rsoptr(c_bbk_l)));
		if(left>=v.count())
		{
			rserror(v.get_bottom(),"miss {");
			return false;
		}
		int right=v.count()-1;
		item.pos=v[left].pos;
		item.ptci=&tci;//反射
		rbuf<tword> vhead=v.sub(0,left);
		if(have_move(sh,vhead))
		{
			return true;
		}
		if(check_tl)
		{
			if(v.get_left()==rskey(c_template)&&
				v.get(1)==rsoptr(c_less_great))
			{
				ifn(combine_tl_name(sh,vhead))
				{
					rserror(v.get_bottom(),"combine_tl_name");
					return false;
				}
			}
			else
			{
				func_tl_part(sh,item,vhead);
			}
		}
		if(item.vtl.empty())
		{
			if(!a_func_define(sh,item,vhead))
			{
				return false;
			}
			if(item.name.sub(0,7)!="_LAMBDA")
			{
				add_this_func(sh,item);
			}
			obtain_size_func(sh,item);
			item.name_dec=item.get_dec();
			if(tci.vfunc.exist(item))
			{
				if(check_tl)
				{
					rserror(v.get_bottom(),"func redefined");
					return false;
				}
				return true;
			}
			item.vword=v.sub(left+1,right);
			tci.vfunc.insert(item);
			if(item.is_macro)
			{
				sh.m_macro[item.name]=tci.vfunc.find(item);
			}
			if(!default_param_proc(sh,*tci.vfunc.find(item)))
			{
				return false;
			}
		}
		else
		{
			item.name_dec=item.get_dec();
			if(tci.vfunctl.exist(item))
			{
				rserror(v.get_bottom(),"functl redefined");
				return false;
			}
			item.vword=vhead+v.sub(left,right+1);
			tci.vfunctl.insert(item);
		}
		return true;
	}

	static void obtain_size_func(const tsh& sh,tclass& tci)
	{
		for(tfunc* p=tci.vfunc.begin();p!=tci.vfunc.end();p=tci.vfunc.next(p))
		{
			obtain_size_func(sh,*p);
		}
	}

	static void obtain_size_func(const tsh& sh,tfunc& tfi)
	{
		tfi.retval.size=yfind::get_type_size(sh,tfi.retval.type);
		for(int i=0;i<tfi.param.count();i++)
		{
			tfi.param[i].size=yfind::get_type_size(sh,tfi.param[i].type);
		}
	}

	static void cpp_tl_replace(const tsh& sh,rbuf<tword>& v)
	{
		int sbk_left=v.count();
		if(v.get_top()!=rsoptr(c_tbk_r))
		{
			if(v.get_top()!=rsoptr(c_sbk_r))
			{
				return;
			}
			sbk_left=ybase::find_symm_word_rev(v,
				rsoptr(c_sbk_l),rsoptr(c_sbk_r),
				0,v.count());
			if(sbk_left>=v.count())
			{
				return;
			}
		}
		int tbk_left=1;
		int tbk_right=ybase::find_symm_tbk(sh,v,tbk_left);
		if(tbk_right>=v.count())
		{
			return;
		}
		v[sbk_left].multi+=ybase::vword_to_vstr(v.sub(tbk_left,tbk_right+1));
		v[sbk_left].multi+=rsoptr(c_sbk_l);
		v[sbk_left].val.clear();
		ybase::clear_word_val(v,0,tbk_right+1);
		ybase::arrange(v);
	}

	static void func_tl_part(const tsh& sh,tfunc& item,rbuf<tword>& v)
	{
		if(v.get_left()==rskey(c_template))
		{
			cpp_tl_replace(sh,v);
		}
		int left=v.count();
		if(v.get_top()!=rsoptr(c_tbk_r))
		{
			if(v.get_top()!=rsoptr(c_sbk_r))
			{
				return;
			}
			left=ybase::find_symm_word_rev(v,
				rsoptr(c_sbk_l),rsoptr(c_sbk_r),
				0,v.count());
			if(left>=v.count())
			{
				return;
			}
		}
		if(v.get(left-1)!=rsoptr(c_tbk_r))
		{
			return;
		}
		rbuf<tword> temp=v.sub(0,left);
		left=ybase::find_symm_word_rev(temp,
			rsoptr(c_tbk_l),rsoptr(c_tbk_r),
			0,temp.count());
		if(left>=temp.count())
		{
			return;
		}
		item.name=temp.get(left-1).val;
		if(item.name.empty())
		{
			return;
		}
		rbuf<rstr> vsrc=ybase::vword_to_vstr(
			temp.sub(left+1,temp.count()-1));
		rbuf<rbuf<rstr> > vdst=r_split_a<rstr>(vsrc,rsoptr(c_comma));
		if(vdst.empty())
		{
			return;
		}
		for(int i=0;i<vdst.count();i++)
		{
			ttl tli;
			tli.name=vdst[i].get_right();
			item.vtl.push(tli);
		}
	}

	static void add_this_func(const tsh& sh,tfunc& tfi)
	{
		if(tfi.ptci->is_friend)
		{
			tfi.is_friend=true;
		}
		if(!tfi.is_friend)
		{
			tdata tdi;
			tdi.name=rskey(c_this);
			tdi.type=tfi.ptci->name+rsoptr(c_addr);
			tfi.param.push_front(tdi);
		}
	}

	static rbool default_param_proc(const tsh& sh,tfunc& tfi)
	{
		int i;
		for(i=0;i<tfi.param.count();i++)
		{
			if(!tfi.param[i].param.empty())
			{
				break;
			}
		}
		if(i>=tfi.param.count())
		{
			return true;
		}
		for(int j=i;j<tfi.param.count();j++)
		{
			if(tfi.param[j].param.empty())
			{
				rserror(tfi.vword.get_bottom(),"default param error");
				return false;
			}
		}
		for(;i<tfi.param.count();i++)
		{
			tfunc ftemp=tfi;
			ftemp.param.erase(i,ftemp.param.count());
			rbuf<tword> vtemp;
			tword twi;
			twi.pos=tfi.pos;
			for(int j=i;j<tfi.param.count();j++)
			{
				twi.val=tfi.param[j].type;
				vtemp.push(twi);
				twi.val=tfi.param[j].name;
				vtemp.push(twi);
				twi.val=rsoptr(c_sbk_l);
				vtemp.push(twi);
				for(int k=0;k<tfi.param[j].param.count();k++)
				{
					twi.val=tfi.param[j].param[k].val;
					vtemp.push(twi);
				}
				twi.val=rsoptr(c_sbk_r);
				vtemp.push(twi);
				twi.val=rsoptr(c_semi);
				vtemp.push(twi);
			}
			vtemp+=r_move(ftemp.vword);
			ftemp.vword=r_move(vtemp);
			for(int j=0;j<ftemp.param.count();j++)
			{
				ftemp.param[j].param.free();
			}
			ftemp.name_dec=ftemp.get_dec();
			if(tfi.ptci->vfunc.exist(ftemp))
			{
				rserror(tfi.vword.get_bottom(),"func redefined");
				return false;
			}
			tfi.ptci->vfunc.insert(ftemp);
		}
		for(i=0;i<tfi.param.count();i++)
		{
			tfi.param[i].param.free();
		}
		return true;
	}
};
﻿#pragma once

#include "../rlib/rfile.h"
#include "yword.h"
#include "ysuper.h"

//预处理、获取所有文件
//词表->m_file.vword
struct ypre
{
	static rbool process(tsh& sh)
	{
		ifn(auto_import(sh))
		{
			rserror("");
			return false;
		}
		if(sh.m_main_cont!=null)
		{
			tfile item;
			item.name=sh.m_main_file;
			item.cont=sh.m_main_cont;
			sh.m_file.insert(item);
		}
		else
		{
			if(!read_file(sh,sh.m_main_file))
			{
				rserror("can't read main file "+
					sh.m_main_file.torstr());
				return false;
			}
		}
		if(!obtain_all_file(sh))
		{
			return false;
		}
		for(tfile* p=sh.m_file.begin();p!=sh.m_file.end();p=sh.m_file.next(p))
		{
			if(!obtain_def(sh,sh.m_vdefine,p->vword))
			{
				return false;
			}
		}
		for(tfile* p=sh.m_file.begin();p!=sh.m_file.end();p=sh.m_file.next(p))
		{
			if(!ifdef_replace(sh,sh.m_vdefine,p->vword))
			{
				return false;
			}
		}
		for(tfile* p=sh.m_file.begin();p!=sh.m_file.end();p=sh.m_file.next(p))
		{
			ifn(def_replace(sh,sh.m_vdefine,p->vword))
			{
				return false;
			}
		}
		return true;
	}

	static rbool auto_import(tsh& sh)
	{
		ifn(tconf::c_auto_import)
		{
			return true;
		}
		return read_file(sh,ybase::get_rs_dir()+"src/xlib/xf.h");
	}

	static rbool read_file(tsh& sh,const rstr& name)
	{
		if(name.empty())
		{
			return false;
		}
		ifn(rfile::exist(name))
		{
			return false;
		}
		tfile item;
		item.name=name;
		if(sh.m_file.exist(item))
		{
			return true;
		}
		item.cont=rfile::read_all_n(name);
		if(item.cont.empty())
		{
			return false;
		}
		item.cont=rcode::to_utf8_txt(item.cont).sub(3);
		sh.m_file.insert(item);
		return true;
	}

	static rbool str_analyse(const tsh& sh,rstr& src,rbuf<tword>& dst,const tfile* pfile)
	{
		if(!yword::analyse(sh,src,dst,pfile))
		{
			return false;
		}
		const_replace(dst);
		combine_double(dst);
		combine_float(dst);
		key_replace(sh,dst);
		if(pfile!=null&&rdir::get_suffix_w(pfile->name)!=rstr("rs"))
		{
			extern_replace(sh,dst);
			this_replace(sh,dst);
		}
		return true;
	}

	static rbool obtain_all_file(tsh& sh)
	{
		rbuf<tfile*>  v;
		for(tfile* p=sh.m_file.begin();
			p!=sh.m_file.end();p=sh.m_file.next(p))
		{
			v.push(p);
		}
		for(int i=0;i<v.count();i++)
		{
			ifn(proc_file(sh,v[i]))
			{
				return false;
			}
		}
		return true;
	}

	static rbool proc_file(tsh& sh,tfile* p)
	{
		rbuf<rstr> vname;
		count_tab(*p);
		if(!str_analyse(sh,p->cont,p->vword,p))
		{
			return false;
		}
		//仅编译器内部使用
		ifn(ifdef_replace(sh,sh.m_vdefine,p->vword))
		{
			return false;
		}
		if(!obtain_name(sh,vname,p->vword,*p))
		{
			rserror(rstr("obtain error ")+
				ybase::get_file_name(p));
			return false;
		}
		for(int i=0;i<vname.count();i++)
		{
			ifn(read_file(sh,vname[i]))
			{
				rserror("can't read file "+vname[i].torstr());
				return false;
			}
			tfile* pfile=sh.m_file.find(tfile(vname[i]));
			if(pfile==null)
			{
				return false;
			}
			ifn(proc_file(sh,pfile))
			{
				return false;
			}
		}
		return true;
	}

	static rbool obtain_name(const tsh& sh,rbuf<rstr>& vname,rbuf<tword>& v,const tfile& f)
	{
		rstr exe_dir=rdir::get_exe_dir();
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val!=rskey(c_import))
			{
				continue;
			}
			if(v.get(i-1).val==rsoptr(c_sharp))
			{
				v[i-1].clear();
			}
			v[i].val.clear();
			rstr name;
			if(v.get(i+1).is_cstr())
			{
				name=v.get(i+1).val;
				v[i+1].clear();
			}
			else
			{
				//处理不带引号的import
				int j;
				for(j=i+1;j<v.count();j++)
				{
					if(v[j].pos.line!=v[i].pos.line)
					{
						break;
					}
					name+=v[j].val;
					v[j].val.clear();
				}
				name=ybase::add_quote(name.torstr());
			}
			if(name.count()<3)
			{
				return false;
			}
			name.pop();
			name.pop_front();
			name=rdir::dir_std(name);
			rstr temp=get_abs_name(rdir::get_prev_dir(f.name),name);
			ifn(rfile::exist(temp))
			{
				ifn(get_file(sh,vname,name,temp))
				{
					return false;
				}
			}
			if(!vname.exist(temp)&&!sh.m_file.exist(tfile(temp)))
			{
				vname.push(temp);
			}
		}
		ybase::arrange(v);
		return true;
	}

	static rbool get_file(const tsh& sh,const rbuf<rstr>& vname,
		const rstr& name,rstr& abs_name)
	{
		for(int i=0;i<sh.m_path.count();i++)
		{
			//todo: 直接import
			abs_name=get_abs_name(sh.m_path[i],name);
			if(rfile::exist(abs_name))
			{
				return true;
			}
		}
		return false;
	}

	static rstr get_abs_name(rstrw path,const rstrw& name)
	{
		if(path.empty())
		{
			return rstr();
		}
		rbuf<rstrw> temp=r_split<rstrw>(name,rstrw("/"));
		if(temp.empty())
		{
			return rstr();
		}
		for(int i=0;i<temp.count();i++)
		{
			if(temp[i]==rstrw(".."))
			{
				path=rdir::get_prev_dir_w(path);
			}
			elif(temp[i]==rstrw("."))
			{
				;
			}
			else
			{
				path+=temp[i];
				if(i!=temp.count()-1)
				{
					path+=rstrw("/");
				}
			}
		}
		return path.torstr();
	}

	static rstr get_abs_path(const rstrw& s)
	{
		if(s.sub(0,2)==rstrw("//")||s.sub(1,3)==rstrw(":/"))
		{
			return s.torstr();
		}
		return get_abs_name(rdir::get_cur_dir_w(),s);
	}

	static void this_replace(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i]!=rskey(c_this))
			{
				continue;
			}
			if(v.get(i+1)==rsoptr(c_arrow_r))
			{
				v[i+1].val=rsoptr(c_dot);
				continue;
			}
			v[i].val.clear();
			v[i].multi+=rsoptr(c_sbk_l);
			v[i].multi+=rsoptr(c_addr);
			v[i].multi+=rskey(c_this);
			v[i].multi+=rsoptr(c_sbk_r);
		}
		ybase::arrange(v);
	}

	static void extern_replace(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i]!=rskey(c_extern))
			{
				continue;
			}
			int pos=v.find(rsoptr(c_semi),i);
			if(pos<v.count())
			{
				ybase::clear_word_val(v,i,pos+1);
			}
		}
		ybase::arrange(v);
	}

	static void key_replace(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val==rskey(c_include))
			{
				v[i].val=rskey(c_import);
			}
			elif(v[i].val==rskey(c_private))//这里不能用超级宏实现，因为有带冒号和不带冒号两种
			{
				v[i].clear();
				if(rsoptr(c_colon)==v.get(i+1).val)
				{
					v[i+1].clear();
				}
			}
			elif(v[i].val==rskey(c_public))
			{
				v[i].clear();
				if(rsoptr(c_colon)==v.get(i+1).val)
				{
					v[i+1].clear();
				}
			}
			elif(v[i].val==rskey(c_protected))
			{
				v[i].clear();
				if(rsoptr(c_colon)==v.get(i+1).val)
				{
					v[i+1].clear();
				}
			}
			elif(v[i].val==rsoptr(c_sharp)&&v.get(i+1).val=="pragma")
			{
				if(i+2<v.count())
				{
					v[i+2].clear();
				}
				v[i].clear();
				v[i+1].clear();
			}
			elif(v[i].val=="__FILE__")
			{
				v[i].val=ybase::add_quote(v[i].pos.file->name);
			}
			elif(v[i].val=="__LINE__")
			{
				v[i].val=v[i].pos.line;
			}
		}
		ybase::arrange(v);
	}

	static rbool def_replace_one(const tsh& sh,rbuf<tword>& v,const rset<tmac>& vmac)
	{
		tmac item;
		for(int i=0;i<v.count();i++)
		{
			item.name=v[i].val;
			tmac* p=vmac.find(item);
			if(p==null)
			{
				continue;
			}
			if(p->is_super)
			{
				ifn(ysuper::replace_item(sh,v,i,*p))
				{
					return false;
				}
			}
			else
			{
				v[i].val.clear();
				v[i].multi=p->vstr;
			}
		}
		return true;
	}

	static rbool def_replace(const tsh& sh,const rset<tmac>& vdefine,rbuf<tword>& v)
	{
		for(int i=0;i<c_rs_deep;i++)
		{
			ifn(def_replace_one(sh,v,vdefine))
			{
				return false;
			}
			ifn(ybase::arrange(v))
			{
				return true;
			}
		}
		return false;
	}

	static rbool obtain_def(const tsh& sh,rset<tmac>& vdefine,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val!=rskey(c_define))
			{
				continue;
			}
			if(v.get(i-1).val==rsoptr(c_sharp))
			{
				v[i-1].clear();
			}
			if(v.get(i+1).is_name()&&v.get(i+2)==rsoptr(c_sbk_l))
			{
				//todo:暂时替换成mac
				v[i].val=rskey(c_mac);
				continue;
			}
			if(v.get(i+1)=="$")
			{
				int right=i;
				ifn(ysuper::add_super_mac(sh,v,right,vdefine))
				{
					return false;
				}
				ybase::clear_word_val(v,i,right+1);
				i=right;
				continue;
			}
			tmac item;
			item.name=v.get(i+1).val;
			if(item.name.empty())
			{
				rserror(v[i]);
				return false;
			}
			for(int k=i+2;k<v.count()&&v.get(k).pos==v[i].pos;k++)
			{
				item.vstr.push(v[k].val);
				v[k].clear();
			}
			if(vdefine.exist(item))
			{
				vdefine.erase(item);
				/*rserror(v.get(i+1),"redefined");
				return false;*/
			}
			vdefine.insert(item);
			v[i+1].clear();
			v[i].clear();
		}
		ybase::arrange(v);
		return true;
	}

	//fixme:
	static rbool ifdef_replace(const tsh& sh,const rset<tmac>& vdefine,rbuf<tword>& v)
	{
		tmac item;
		for(int i=v.count()-1;i>=0;i--)
		{
			if(v[i]!=rsoptr(c_sharp))
			{
				continue;
			}
			rstr key=v.get(i+1).val;
			if(key!=rskey(c_ifdef)&&
				key!=rskey(c_ifndef))
			{
				continue;
			}
			if(i+2>=v.count())
			{
				rserror(v[i],"ifdef");
				return false;
			}
			item.name=v[i+2].val;
			int endpos=r_find_a<tword>(v,tword(rskey(c_endif)),i+3);
			if(endpos>=v.count())
			{
				rserror(v[i],"ifdef");
				return false;
			}
			int elsepos=endpos;
			for(int j=i+3;j<endpos;j++)
			{
				if(v[j]==rsoptr(c_sharp)&&
					v.get(j+1)==rskey(c_else))
				{
					elsepos=j+1;
					break;
				}
			}
			rbool defined=vdefine.exist(item);
			if(key==rskey(c_ifdef))
			{
				if(defined)
				{
					ybase::clear_word_val(v,elsepos,endpos);
				}
				else
				{
					ybase::clear_word_val(v,i,elsepos);
				}
			}
			else
			{
				if(defined)
				{
					ybase::clear_word_val(v,i,elsepos);
				}
				else
				{
					ybase::clear_word_val(v,elsepos,endpos);
				}
			}
			v[i].clear();
			v[i+1].clear();
			v[i+2].clear();
			v[endpos-1].clear();
			v[endpos].clear();
			v[elsepos-1].clear();
			v[elsepos].clear();
		}
		ybase::arrange(v);
		return true;
	}

	static void combine_double(rbuf<tword>& v)
	{
		for(int i=1;i<v.count()-1;i++)
		{
			if(v[i]=="."&&
				v[i-1].val.is_number()&&
				v[i+1].val.is_number())
			{
				v[i-1].val+=v[i].val;
				v[i-1].val+=v[i+1].val;
				v[i].clear();
				v[i+1].clear();
				i++;
			}
		}
		ybase::arrange(v);
	}

	static void combine_float(rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			ifn(v[i]=="."&&v.get(i-1).val.is_number())
			{
				continue;
			}
			rstr s=v.get(i+1).val;
			if(s.get_top()!=r_char('f'))
			{
				continue;
			}
			ifn(s.sub(0,s.count()-1).is_number())
			{
				continue;
			}
			v[i].multi+="double";
			v[i].multi+="(";
			v[i].multi+=v[i-1].val+"."+s.sub(0,s.count()-1);
			v[i].multi+=")";
			v[i].multi+=".";
			v[i].multi+="tofloat";
			v[i].val.clear();
			v[i+1].val.clear();
			v[i-1].val.clear();
		}
		ybase::arrange(v);
	}

	static void const_replace(rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			const_replace(v[i]);
		}
	}

	static void const_replace(tword& word)
	{
		if(word.val.count()>0&&rstr::is_number(word.val[0]))
		{
			if(r_find_a<uchar>(word.val.m_buf,r_char('_'))<word.val.count())
			{
				rstr s;
				for(int i=0;i<word.val.count();i++)
				{
					if(word.val[i]!=r_char('_'))
					{
						s+=word.val[i];
					}
				}
				word.val=r_move(s);
			}
		}
		if(word.val.count()>2)
		{
			if(word.val[0]==r_char('0')&&word.val[1]==r_char('x'))
			{
				word.val=rstr::hextodec(word.val.sub(2));
			}
			if(word.val[0]==r_char('0')&&word.val[1]==r_char('b'))
			{
				word.val=rstr::bintodec(word.val.sub(2));
			}
		}
	}

	static int count_tab_line(const rstr& s)
	{
		int i;
		for(i=0;i<s.count();i++)
		{
			if(s[i]!=r_char(' ')&&s[i]!=0x9)
			{
				break;
			}
		}
		int sum=0;
		for(int k=0;k<i;k++)
		{
			if(s[k]==r_char(' '))
			{
				sum++;
			}
			elif(s[k]==0x9)
			{
				sum+=4;
			}
		}
		return sum/4;
	}

	static void count_tab(tfile& file)
	{
		file.line_list=r_split_e<rstr>(file.cont,rstr("\n"));
		file.line_list.push_front(rstr());//行号从1开始
		for(int i=0;i<file.line_list.count();i++)
		{
			file.tab_list.push(count_tab_line(file.line_list[i]));
		}
	}
};
﻿#pragma once

#include "yadd.h"
#include "yexp.h"

//简单替换
struct yrep
{
	static rbool typeof_replace(tsh& sh,tfunc& tfi,tenv env)
	{
		for(int i=0;i<tfi.vsent.count();i++)
		{
			if(!typeof_replace(sh,tfi,tfi.vsent[i],env))
			{
				return false;
			}
		}
		return true;
	}

	static rbool typeof_replace(tsh& sh,tfunc& tfi,tsent& sent,tenv env)
	{
		rbuf<tword>& v=sent.vword;
		for(int i=0;i<v.count();i++)
		{
			if(v[i]!=rskey(c_typeof))
			{
				continue;
			}
			int left=i+1;
			if(v.get(left)!=rsoptr(c_sbk_l))
			{
				rserror(sent,"miss (");
				return false;
			}
			int right=ybase::find_symm_sbk(sh,v,left);
			if(right>=v.count())
			{
				rserror(sent,"miss )");
				return false;
			}
			tsent dst;
			dst.pos=sent.pos;
			dst.vword=v.sub(left+1,right);
			if(dst.vword.count()==1&&yfind::is_class(sh,dst.vword[0].val))
			{
				dst.type=dst.vword[0].val;
			}
			else
			{
				if(!yexp::p_exp(sh,dst,tfi,0,env))
				{
					return false;
				}
			}
			ybase::clear_word_val(v,i,right+1);
			v[i].val=ybase::add_quote(dst.type);
		}
		ybase::arrange(v);
		return true;
	}

	static void fpoint_replace(const tsh& sh,tfunc& tfi)
	{
		for(int i=0;i<tfi.vsent.count();++i)
		{
			fpoint_replace(sh,*tfi.ptci,tfi.vsent[i].vword);
		}
	}

	static void fpoint_replace(const tsh& sh,const tclass& tci,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val!=rsoptr(c_addr))
			{
				continue;
			}
			const tclass* ptci;
			rstr name;
			tfunc* ptfi;
			int left;
			if(v.get(i+2).val==rsoptr(c_dot))
			{
				ptci=yfind::class_search(sh,v.get(i+1).val);
				if(null==ptci)
				{
					continue;
				}
				name=v.get(i+3).val;
				left=i+4;
			}
			else
			{
				name=v.get(i+1).val;
				ptci=&tci;
				ptfi=yfind::func_search(*ptci,name);
				if(null==ptfi)
				{
					ptci=sh.m_main;	
				}
				left=i+2;
			}
			if(v.get(left)!=rsoptr(c_sbk_l))
			{
				ptfi=yfind::func_search(*ptci,name);
				if(null==ptfi)
				{
					continue;
				}
				ybase::clear_word_val(v,i,left);
				v[i].multi=ybase::get_func_declare_lisp(sh,*ptci,*ptfi);
				i=left-1;
			}
			else
			{
				int right=ybase::find_symm_sbk(sh,v,left);
				if(right>=v.count())
				{
					continue;
				}
				rbuf<tsent> vsent;
				ybase::split_param(sh,vsent,v.sub(left+1,right));
				rbuf<rstr> vtype;
				for(int j=0;j<vsent.count();j++)
				{
					vtype.push(vsent[j].vword.get(0).val);
				}
				ptfi=yfind::func_search_same(*ptci,name,vtype);
				if(null==ptfi)
				{
					continue;
				}
				ybase::clear_word_val(v,i,right+1);
				v[i].multi=ybase::get_func_declare_lisp(sh,*ptci,*ptfi);
				i=right;
			}
		}
		ybase::arrange(v);
	}

	static void const_replace(const tsh& sh,rbuf<tsent>& vsent)
	{
		for(int i=0;i<vsent.count();++i)
		{
			if(sh.m_key.is_asm_ins(vsent[i].vword.get_bottom().val))
			{
				continue;
			}
			const_replace(sh,vsent[i].vword);
		}
	}

	static void const_replace(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(!v[i].is_const())
			{
				continue;
			}
			if(v[i].is_cint()&&v.get(i+1).val==rsoptr(c_dot))
			{
				v[i].multi.push(rskey(c_int));
				v[i].multi.push(rsoptr(c_sbk_l));
				v[i].multi.push(v[i].val);
				v[i].multi.push(rsoptr(c_sbk_r));
				v[i].val.clear();
			}
			elif(v[i].is_cdouble()&&v.get(i+1).val==rsoptr(c_dot))
			{
				v[i].multi.push(rstr("double"));
				v[i].multi.push(rsoptr(c_sbk_l));
				v[i].multi.push(v[i].val);
				v[i].multi.push(rsoptr(c_sbk_r));
				v[i].val.clear();
			}
			elif(v[i].is_cstr()&&
				(v.get(i+1).val==rsoptr(c_dot)||
				yfind::is_rstr_optr(sh,v.get(i+1).val)||
				yfind::is_rstr_optr(sh,v.get(i-1).val)))
			{
				v[i].multi.push(rskey(c_rstr));
				v[i].multi.push(rsoptr(c_sbk_l));
				v[i].multi.push(v[i].val);
				v[i].multi.push(rsoptr(c_sbk_r));
				v[i].val.clear();
			}
		}
		ybase::arrange(v);
	}

	static void replace_neg(const tsh& sh,rbuf<tsent>& vsent)
	{
		for(int i=0;i<vsent.count();i++)
		{
			replace_neg(sh,vsent[i].vword);
		}
	}

	static void replace_neg(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count()-1;i++)
		{
			if(v[i]!=rsoptr(c_minus))
			{
				continue;
			}
			if(i==0)
			{
				v[i].val="neg";
				continue;
			}
			if(v[i-1]==rsoptr(c_equal)||
				v[i-1]==rsoptr(c_sbk_l)||
				v[i-1]==rsoptr(c_mbk_l)||
				v[i-1]==rsoptr(c_comma)||
				v[i-1]==rsoptr(c_equal_equal)||
				v[i-1]==rsoptr(c_not_equal))
			{
				v[i].val="neg";
			}
		}
	}

	static rbool size_off_to_zero(const tsh& sh,tfunc& tfi)
	{
		for(int i=0;i<tfi.vsent.count();++i)
		{
			if(!size_off_to_zero(sh,tfi.vsent[i].vword))
			{
				rserror(tfi.vsent[i],"size_off_to_zero error");
				return false;
			}
		}
		return true;
	}

	static rbool size_off_to_zero(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].val!=rskey(c_sizeof)&&v[i].val!=rskey(c_s_off))
			{
				continue;
			}
			if(i+1>=v.count())
			{
				return false;
			}
			if(v.get(i+1).val!=rsoptr(c_sbk_l))
			{
				v[i].multi.push(v[i].val);
				v[i].multi.push(v.get(i+1).val);
				v[i+1].clear();
				v[i].val=rstr("0");
				i++;
			}
			else
			{
				int right=ybase::find_symm_sbk(sh,v,i+1);
				if(right>=v.count())
				{
					return false;
				}
				v[i].multi.push(v[i].val);
				v[i].multi+=ybase::vword_to_vstr(v.sub(i+2,right));
				ybase::clear_word_val(v,i+1,right+1);
				v[i].val=rstr("0");
				i=right;
			}
		}
		ybase::arrange(v);
		return true;
	}

	static rbool size_off_replace(const tsh& sh,tfunc& tfi)
	{
		for(int i=0;i<tfi.vsent.count();++i)
		{
			if(!yrep::size_off_replace(sh,tfi.vsent[i].vword,tfi))
			{
				rserror(tfi.vsent[i],"size_off_replace error");
				return false;
			}
		}
		return true;
	}

	static rbool size_off_replace(const tsh& sh,rbuf<tword>& v,const tfunc& tfi)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i].multi.count()!=2)
			{
				continue;
			}
			rstr name=v[i].multi[1];
			if(v[i].multi[0]==rskey(c_sizeof))
			{
				if(rskey(c_s_local)==name)
				{
					v[i].val=yfind::get_func_local_size(tfi);
				}
				elif(rskey(c_s_param)==name)
				{
					v[i].val=yfind::get_func_param_size(tfi);
				}
				else
				{
					tclass* ptci=yfind::class_search(sh,name);
					if(null==ptci)
					{
						return false;
					}
					v[i].val=ptci->size;
				}
			}
			elif(v[i].multi[0]==rskey(c_s_off))
			{
				tdata* ptdi=yfind::local_search(tfi,name);
				if(null==ptdi)
				{
					return false;
				}
				v[i].val=ptdi->off;
			}
			else
			{
				continue;
			}
			v[i].multi.clear();
		}
		ifn(sh.m_key.is_asm_ins(v.get_bottom().val))
		{
			return true;
		}
		if(sh.m_mode!=tsh::c_gpp)
		{
			for(int i=1;i<v.count();i++)
			{
				if(!v[i].is_name())
				{
					continue;
				}
				tdata* ptdi=yfind::local_search(tfi,v[i].val);
				if(ptdi==null)
				{
					continue;
				}
				rbuf<rstr> vdst;
				if(v.get(i-1).val==rsoptr(c_addr))
				{
					vdst.push(rstr("ebp"));
					vdst.push(rstr("+"));
					vdst.push(rstr(ptdi->off));
					v[i-1].clear();
				}
				else
				{
					vdst.push(rstr(rsoptr(c_mbk_l)));
					vdst.push(rstr("ebp"));
					vdst.push(rstr("+"));
					vdst.push(rstr(ptdi->off));
					vdst.push(rstr(rsoptr(c_mbk_r)));
				}
				v[i].clear();
				v[i].multi=r_move(vdst);
			}
		}
		ybase::arrange(v);
		return true;
	}

	static rbool local_var_replace(const tsh& sh,tfunc& tfi)
	{
		for(int i=0;i<tfi.vsent.count();i++)
		{
			if(sh.m_key.is_asm_ins(tfi.vsent[i].vword.get_bottom().val))
			{
				continue;
			}
			if(!local_var_replace(sh,i,tfi))
			{
				return false;
			}
		}
		ybase::part_vsent(tfi);
		return true;
	}

	static rbool local_var_replace(const tsh& sh,int i,tfunc& tfi)
	{
		rbuf<tword>& v=tfi.vsent[i].vword;
		if(v.count()<2||
			!yfind::is_class_t(sh,v.get(0).val)||
			!v.get(1).is_name())
		{
			return true;
		}
		tdata tdi;
		if(!ymemb::a_data_define(sh,tdi,v))
		{
			return false;
		}
		v[0].val.clear();
		if(v.count()==2)
		{
			v[1].val.clear();//清除未初始化的变量定义
		}
		//如int a(1)这样的定义千万不能重复调用构造函数
		rbool bstruct=v.count()>2&&v[2].val==rsoptr(c_sbk_l);
		ybase::arrange(v);
		//排除重复定义的
		tdata* ptdi=yfind::local_search(tfi,tdi.name);
		if(null==ptdi)
		{
			tfi.local.push(tdi);
		}
		else
		{
			if(ptdi->type!=tdi.type)
			{
				rserror(v.get(0),"diff type local var redefined");
				return false;
			}
		}
		rbuf<tword> vtemp;
		if(ybase::is_quote(tdi.type)&&v.get(1)==rsoptr(c_equal))
		{
			tdata temp_item;
			temp_item.type="rp<void>";
			temp_item.name=rskey(c_ltemp)+rstr(tfi.tid);
			tfi.tid++;
			tfi.local.push(temp_item);

			vtemp+=temp_item.name;
			vtemp+=rsoptr(c_equal);
			vtemp+=rsoptr(c_addr);
			vtemp+=rsoptr(c_sbk_l);
			vtemp+=v.sub(2);
			vtemp+=rsoptr(c_sbk_r);
			vtemp+=rsoptr(c_semi);
			vtemp+=rskey(c_mov);
			vtemp+=tdi.name;
			vtemp+=rsoptr(c_comma);
			vtemp+=temp_item.name;
			v=r_move(vtemp);
		}
		else
		{
			if(ptdi==null&&!yfind::is_empty_struct_type(sh,tdi.type)&&!have_jump_or_tag(sh,i,tfi))
			{
				tfi.local.top().off=-1;//标记为-1表示不需要调用空构造函数，不允许未定义先使用
			}
			else
			{
				yadd::add_destructor_func(sh,*tfi.ptci,tdi,vtemp,false);
			}
			if(!bstruct)
			{
				yadd::add_structor_func(sh,tdi,vtemp);
			}
			vtemp+=r_move(v);
			v=r_move(vtemp);
		}
		return true;
	}

	static rbool have_jump_or_tag(const tsh& sh,int i,tfunc& tfi)
	{
		for(int j=0;j<i;j++)
		{
			if(ybase::is_tag<tword>(tfi.vsent[j].vword))
			{
				return true;
			}
			int type=sh.m_key.get_key_index(tfi.vsent[j].vword.get_left().val);
			if(ybase::is_jmp_ins(type))
			{
				return true;
			}
		}
		return false;
	}

	static rbool var_struct_replace(const tsh& sh,const tfunc& tfi)
	{
		for(int i=0;i<tfi.vsent.count();++i)
		{
			if(sh.m_key.is_asm_ins(tfi.vsent[i].vword.get_bottom().val))
			{
				continue;
			}
			if(!var_struct_replace(sh,tfi.vsent[i].vword,tfi))
			{
				rserror(tfi.vsent[i],"var_struct_replace error");
				return false;
			}
		}
		return true;
	}

	static rbool var_struct_replace(const tsh& sh,rbuf<tword>& v,const tfunc& tfi)
	{
		//暂时只处理a(1)，忽略this.a(1)
		int left=1;
		if(v.get(left).val!=rsoptr(c_sbk_l))
		{
			return true;
		}
		tdata* ptdi=yfind::local_search(tfi,v.get(0).val);
		if(ptdi==null)
		{
			return true;
		}
		if(ybase::is_quote(ptdi->type))
		{
			return true;
		}
		int right=ybase::find_symm_sbk(sh,v,left);
		if(right>=v.count())
		{
			return false;
		}
		if(right!=v.count()-1)
		{
			return true;
		}
		//动态类型和构造函数有歧义
		rbuf<tword> vtemp;
		vtemp.push(tword(ptdi->type));
		vtemp.push(tword(rsoptr(c_dot)));
		vtemp.push(tword(ptdi->type));
		vtemp.push(tword(rsoptr(c_sbk_l)));
		vtemp+=v.sub(0,left);
		rbuf<tword> vsub=v.sub(left+1,right);
		if(!vsub.empty())
		{
			vtemp.push(tword(rsoptr(c_comma)));
			vtemp+=vsub;
		}
		vtemp.push(tword(rsoptr(c_sbk_r)));
		v=r_move(vtemp);
		return true;
	}

	/*
	(int)a
	->
	a.to<int>

	(int)(a.b)
	->
	(a.b).to<int>
	*/
	static rbool trans_replace(const tsh& sh,rbuf<tword>& v)
	{
		for(int i=0;i<v.count();i++)
		{
			if(v[i]!=rsoptr(c_sbk_l))
			{
				continue;
			}
			if(v.get(i+2)!=rsoptr(c_sbk_r))
			{
				continue;
			}
			if(v.get(i-1)==rskey(c_sizeof)||
				v.get(i-1)==rskey(c_typeof))
			{
				continue;
			}
			ifn(yfind::is_class(sh,v.get(i+1).val))
			{
				continue;
			}
			if(i+3>=v.count())
			{
				rserror(v[i],"trans_replace error");
				return false;
			}
			rbuf<tword> src;
			rstr dst_type=v[i+1].val;
			if(v.get(i+3)==rsoptr(c_sbk_l))
			{
				int right=ybase::find_symm_sbk(sh,v,i+3);
				if(right>=v.count())
				{
					rserror(v[i],"trans_replace error");
					return false;
				}
				src=v.sub(i+3,right+1);
				ybase::clear_word_val(v,i,right+1);
			}
			else
			{
				src+=v[i+3];
				ybase::clear_word_val(v,i,i+4);
			}
			v[i].multi+=ybase::vword_to_vstr(src);
			v[i].multi+=rsoptr(c_dot);
			v[i].multi+=rskey(c_to);
			v[i].multi+=rsoptr(c_tbk_l);
			v[i].multi+=dst_type;
			v[i].multi+=rsoptr(c_tbk_r);
			if(ybase::arrange(v))
			{
				return trans_replace(sh,v);
			}
			return true;
		}
		return true;
	}
};
﻿#pragma once

#include "ylambda.h"
#include "ycontrol.h"
#include "ymac.h"
#include "yrep.h"
#include "ylazy.h"

//单词转换为语句，控制结构线性化，运算符替换成标准函数调用的S表达式
//即[ class func []]形式，例如[ rf print []]
//从这里开始行号已经放在sent中
struct ysent
{
	static rbool process(tsh& sh,tfunc& tfi,tenv env)
	{
		if(env.ptfi!=null)
		{
			add_class(sh,tfi,env);
		}
		ifn(ylambda::function_replace(sh,tfi.vword))
		{
			return false;
		}
		ylambda::lambda_var_replace(sh,tfi);
		ifn(ylambda::lambda_replace(sh,tfi))
		{
			return false;
		}
		//强制转换替换
		ifn(yrep::trans_replace(sh,tfi.vword))
		{
			return false;
		}
		ifn(macro_replace(sh,tfi))
		{
			return false;
		}
		if(!ymac::replace(sh,*tfi.ptci,tfi.vword))
		{
			return false;
		}
		if(!yfunctl::ftl_replace(sh,*tfi.ptci,tfi.vword,null))
		{
			return false;
		}
		if(!ycontrol::proc_func(sh,tfi))
		{
			return false;
		}
		ifn(ymac::func_mac_replace(sh,tfi.vsent))
		{
			return false;
		}
		ylambda::lambda_proc(sh,tfi);
		//增加全局变量引用
		add_main_quote(sh,tfi);
		yrep::replace_neg(sh,tfi.vsent);
		//常量dot替换成临时变量
		//如 0.toint -> int(0).toint
		// "abc"+a  ->  rstr("abc")+a
		yrep::const_replace(sh,tfi.vsent);
		//找到直接定义的局部变量
		yrep::local_var_replace(sh,tfi);
		//函数指针常量替换
		yrep::fpoint_replace(sh,tfi);
		//sizeof s_off替换成0，稍后处理
		if(!yrep::size_off_to_zero(sh,tfi))
		{
			return false;
		}
		//进行类型推断
		if(!proc_type_infer(sh,tfi,env))
		{
			return false;
		}
		if(!yrep::typeof_replace(sh,tfi,env))
		{
			return false;
		}
		//变量构造函数替换如a(1) -> int.int(a,1)
		//这个变量必须是已定义的，不能是类型推断
		if(!yrep::var_struct_replace(sh,tfi))
		{
			return false;
		}
		//表达式标准化
		if(!yexp::p_exp_all(sh,tfi,env))
		{
			return false;
		}
		ifn(ylazy::extact_and_or(sh,tfi,tfi.tid,env))
		{
			return false;
		}
		ifn(ylazy::replace_and_or(sh,tfi))
		{
			return false;
		}
		//临时变量替换，替换后有些表达式类型会变空
		if(!replace_temp_var(sh,tfi,tfi.tid))
		{
			return false;
		}
		ifn(tfi.sdynamic.empty())
		{
			tdata tdi;
			tdi.type=rskey(c_int);
			tdi.name="_EBP";
			tfi.local+=tdi;

			tsent sent;
			sent.pos=tfi.pos;
			sent.vword.push(tword(rstr("mov")));//tword没有设置pos
			sent.vword.push(tword(rstr("_EBP")));//todo:
			sent.vword.push(tword(rstr(",")));
			sent.vword.push(tword(rstr("ebp")));
			tfi.vsent.push_front(r_move(sent));
		}
		if(env.ptfi!=null)
		{
			tsent sent;
			sent.pos=tfi.pos;
			sent.vword.push(tword(rstr("mov")));//tword没有设置pos
			sent.vword.push(tword(rstr("_PENV")));
			sent.vword.push(tword(rstr(",")));
			sent.vword.push(tword(rstr(env.v_ebp)));
			tfi.vsent.push_front(r_move(sent));
		}
		
		//增加局部变量和成员变量的构造和析构
		yadd::add_local_and_memb(sh,tfi);
		//获取局部变量偏移
		obtain_local_off(sh,tfi.local);
		obtain_param_off(tfi);
		//增加全局变量初始化汇编
		add_main_init_asm(sh,tfi);
		ylambda::lambda_add_init_asm(sh,tfi);
		//sizeof s_off替换成实际值
		if(!yrep::size_off_to_zero(sh,tfi))
		{
			return false;
		}
		if(!yrep::size_off_replace(sh,tfi))
		{
			return false;
		}
		//汇编语句常量求值
		if(!asm_const_eval(sh,tfi))
		{
			return false;
		}
		if(!ymac::replace(sh,*tfi.ptci,tfi.vword))
		{
			return false;
		}
		//成员变量里有sizeof s_off的情况需要再次替换
		//注意成员变量初始化的时候不能使用临时变量
		//再处理一次，获取所有表达式的类型
		return yexp::p_exp_all(sh,tfi,tenv());
	}

	static rbool macro_replace(tsh& sh,tfunc& tfi)
	{
		extern rbool r_func_to_x86(tsh& sh,tfunc& tfi,tenv env);
		rbuf<tword>& v=tfi.vword;
		for(int i=0;i<v.count();i++)
		{
			if(sh.m_macro.exist(v[i].val))
			{
				tfunc* ptfi=sh.m_macro[v[i].val];
				ifn(r_func_to_x86(sh,*ptfi,tenv()))
				{
					return false;
				}
#ifndef _RS
				((void (__stdcall *)(rbuf<tword>&,int))(ptfi->code))(v,i);
#endif
			}
		}
		ybase::arrange(v);
		return true;
	}

	static void add_class(tsh& sh,tfunc& tfi,tenv env)
	{
		rstr name="_func_class_"+env.ptfi->name_dec;
		if(!yfind::is_class(sh,name))
		{
			tclass item;
			item.name=name;
			for(int i=0;i<env.ptfi->local.count();i++)
			{
				item.vdata.push(env.ptfi->local[i]);
			}
			for(int i=0;i<env.ptfi->param.count();i++)
			{
				item.vdata.push(env.ptfi->param[i]);
			}
			sh.m_class.insert(item);
		}

		tdata tdi;
		tdi.type=name+"&";
		tdi.name=rskey(c_penv);
		tdi.size=4;
		tdi.count=1;
		tfi.local.push(tdi);
	}

	//增加全局变量引用的初始化汇编语句
	static void add_main_init_asm(tsh& sh,tfunc& tfi)
	{
		if(sh.m_mode==tsh::c_gpp)
		{
			return;
		}
		if(tfi.name!="main")
		{
			int i;
			for(i=0;i<tfi.local.count();i++)
			{
				if(tfi.local[i].type=="main&"&&
					tfi.local[i].name==rskey(c_pmain))
				{
					break;
				}
			}
			if(i>=tfi.local.count())
			{
				return;
			}
		}
		tsent sent;
		sent.pos=tfi.pos;
		sent.vword.push(tword(rstr("mov")));//tword没有设置pos
		sent.vword.push(tword(rskey(c_pmain)));
		sent.vword.push(tword(rstr(",")));//todo:
		if(sh.m_mode==tsh::c_vm||sh.m_mode==tsh::c_jit)
		{
			sent.vword.push(tword(rstr((uint)(sh.m_main_data.begin()))));
		}
		else
		{
			sent.vword.push(tword(rstr("_PMAIN_A")));
		}
		tfi.vsent.push_front(r_move(sent));
	}

	//全局变量和成员变量都不能使用类型推断
	//全局变量必须用g_开头
	static void add_main_quote(tsh& sh,tfunc& tfi)
	{
		ifn(tfi.ptci->name==rskey(c_main)&&tfi.name==rskey(c_main))
		{
			int i;
			for(i=0;i<tfi.vword.count();i++)
			{
				if(yfind::data_member_search(
					*sh.m_main,tfi.vword[i].val)!=null)
				{
					break;
				}
			}
			if(i>=tfi.vword.count())
			{
				return;
			}
		}
		tdata tdi;
		tdi.type="main&";
		tdi.name=rskey(c_pmain);
		tdi.size=4;
		tdi.count=1;
		tfi.local.push(tdi);
	}

	static rbool asm_const_eval(tsh& sh,tfunc& tfi)
	{
		for(int i=0;i<tfi.vsent.count();++i)
		{
			if(sh.m_key.is_asm_ins(tfi.vsent[i].vword.get_bottom().val))
			{
				ifn(yconsteval::op_const_exp(sh,tfi.vsent[i].vword,true))
				{
					return false;
				}
			}
		}
		return true;
	}

	static void obtain_local_off(tsh& sh,rbuf<tdata>& local)
	{
		int off=c_point_size;
		for(int i=0;i<local.count();++i)
		{
			local[i].size=yfind::get_type_size(sh,local[i].type);
			local[i].off=off;
			off+=yfind::get_ceil_space(local[i]);
		}
	}

	static void obtain_param_off(tfunc& tfi)
	{
		int off=yfind::get_func_local_size(tfi);
		off+=c_point_size;//ebp占用的
		off+=c_point_size;//返回地址占用的
		for(int i=0;i<tfi.param.count();++i)
		{
			tfi.param[i].off=off;
			off+=yfind::get_ceil_space(tfi.param[i]);
		}
		tfi.retval.off=off;
	}

	static rbool proc_type_infer(tsh& sh,tfunc& tfi,tenv env)
	{
		for(int i=0;i<tfi.vsent.count();++i)
		{
			if(!proc_type_infer(sh,tfi.vsent[i],tfi,env))
			{
				return false;
			}
		}
		ybase::part_vsent(tfi);
		return true;
	}

	static rbool proc_type_infer(tsh& sh,tsent& sent,tfunc& tfi,tenv env)
	{
		tclass& tci=*tfi.ptci;
		if(sent.vword.count()>=3&&
			sent.vword[1].val==rsoptr(c_equal)&&
			sent.vword[0].is_name())
		{
			//处理类型推断
			rstr name=sent.vword[0].val;
			if(null!=yfind::local_search(tfi,name))
			{
				return true;
			}
			if(env.ptfi!=null&&null!=yfind::local_search(*env.ptfi,name))
			{
				return true;
			}
			if(null!=yfind::data_member_search(tci,name))
			{
				return true;
			}
			if(null!=yfind::data_member_search(*sh.m_main,name))
			{
				return true;
			}
			tsent temp=sent.sub(2,sent.vword.count());
			if(!yrep::typeof_replace(sh,tfi,temp,env))
			{
				return false;
			}
			if(!yexp::p_exp(sh,temp,tfi,0,env))
			{
				return false;
			}
			tdata tdi;
			tdi.name=name;
			tdi.type=ybase::get_tname(temp.type);//引用推断为对象
			
			tfi.local.push(tdi);
			rbuf<tword> vtemp;
			yadd::add_destructor_func(sh,tci,tdi,vtemp,false);
			yadd::add_structor_func(sh,tdi,vtemp);
			vtemp+=r_move(sent.vword);
			sent.vword=r_move(vtemp);
		}
		return true;
	}

	static rbool replace_temp_var_v(tsh& sh,tfunc& tfi,rbuf<tword>& v,int& tid)
	{
		for(int i=1;i<v.count();i++)
		{
			if(v[i].val!=rskey(c_btemp))
			{
				continue;
			}
			tclass* ptci=yfind::class_search(sh,v.get(i+2).val);
			if(null==ptci)
			{
				continue;
			}
			int left=i-1;
			if(v[left].val!=rsoptr(c_mbk_l))
			{
				continue;
			}
			int right=ybase::find_symm_mbk(sh,v,left);
			if(right>=v.count())
			{
				return false;
			}
			tdata tdi;
			tdi.type=ptci->name;
			tdi.name=rskey(c_temp)+rstr(tid);
			tid++;
			rbuf<tword> result;
			result+=rsoptr(c_mbk_l);
			result+=tdi.type;
			result+=rsoptr(c_comma);
			result+=tdi.type;
			result+=rsoptr(c_comma);
			result+=rsoptr(c_mbk_l);
			result+=tdi.name;
			rbuf<tword> vparam=v.sub(left+6,right-1);
			ifn(vparam.empty())
			{
				result+=rsoptr(c_comma);
				result+=vparam;
			}
			result+=rsoptr(c_mbk_r);
			result+=rsoptr(c_mbk_r);
			result+=rsoptr(c_semi);
			tfi.local.push(tdi);
			for(int j=left;j<=right;j++)
			{
				v[j].clear();
			}
			v[left].val=tdi.name;
			ybase::arrange(v);
			result+=r_move(v);
			result+=rsoptr(c_semi);
			//这里加入析构可能破坏ebx，所以所有的析构函数都要保护ebx
			yadd::add_destructor_func(sh,*tfi.ptci,tdi,result,false);
			v=r_move(result);
			return true;
		}
		return true;
	}

	static rbool replace_temp_var(tsh& sh,tfunc& tfi,int& tid)
	{
		for(int i=0;i<tfi.vsent.count();++i)
		{
			if(sh.m_key.is_asm_ins(tfi.vsent[i].vword.get_bottom().val))
			{
				continue;
			}
			for(int j=0;j<c_rs_deep;j++)//最多150层嵌套
			{
				//刚好是先构造内层的临时变量，再构造外层的临时变量
				//这种循环替换的方式好像比递归更清晰
				int temp=tid;
				if(!replace_temp_var_v(sh,tfi,tfi.vsent[i].vword,tid))
				{
					rserror(tfi.vsent[i],"replace_temp_var_v");
					return false;
				}
				if(temp==tid)
				{
					break;
				}
			}
		}
		ybase::part_vsent(tfi);
		return true;
	}
};
﻿#pragma once

#include "ybase.h"

//超级宏
struct ysuper
{
	static rbool add_super_mac(const tsh& sh,const rbuf<tword>& v,int& i,rset<tmac>& vmac)
	{
		tmac mitem;
		mitem.is_super=true;
		mitem.name=v.get(i+2).val;
		int left=i+3;
		int right=left;
		for(;right<v.count()&&v[right].pos==v[i].pos;right++)
		{
			;
		}
		if(right>=v.count())
		{
			rserror(v.get(i),"miss mac");
			return false;
		}
		if(v[right]!=rsoptr(c_bbk_l))
		{
			rserror(v.get(i),"miss mac $ {");
			return false;
		}
		mitem.param=ybase::vword_to_vstr(v.sub(left,right));
		left=right;
		right=ybase::find_symm_bbk(sh,v,left);
		if(right>=v.count())
		{
			rserror(v.get(i),"miss mac $ }");
			return false;
		}
		mitem.vstr=ybase::vword_to_vstr(v.sub(left+1,right));
		if(vmac.exist(mitem))
		{
			vmac.erase(mitem);
			/*rserror(v.get_bottom(),"mac redefined");
			return false;*/
		}
		vmac.insert(mitem);
		i=right;
		return true;
	}

	static rbool replace_item(const tsh& sh,rbuf<tword>& v,int& i,tmac& mitem)
	{
		for(int j=i+2;j<=v.count();j++)
		{
			rbuf<tword> arr;
			rbuf<rstr> src=ybase::vword_to_vstr(v.sub(i+1,j));
			if(match_here(sh,mitem.param,src,arr))
			{
				ifn(replace_super_word(v[i],mitem.vstr,arr))
				{
					rserror(v.get(i));
					return false;
				}
				ybase::clear_word_val(v,i,j);
				i=j-1;
				break;
			}
		}
		return true;
	}

	//todo 限制递归深度
	static rbool match_here(const tsh& sh,const rbuf<rstr>& reg,
		const rbuf<rstr>& src,rbuf<tword>& arr)
	{
		if(reg.empty())
		{
			return src.empty();
		}
		if(reg[0]=="_mword")
		{
			return match_multi(sh,reg.sub(1),src,arr);
		}
		if(!src.empty())
		{
			if(reg[0]=="_word")
			{
				tword temp;
				temp.multi+=src[0];
				arr.push_move(temp);
				if(match_here(sh,reg.sub(1),src.sub(1),arr))
				{
					return true;
				}
				arr.pop();
				return false;
			}
			if(reg[0]!=src[0])
			{
				return false;
			}
			if(src[0]==rsoptr(c_sbk_l))
			{
				int right_r=ybase::find_symm_sbk(sh,reg,0);
				if(right_r>=reg.count())
				{
					return false;
				}
				int right_s=ybase::find_symm_sbk(sh,src,0);
				if(right_s>=src.count())
				{
					return false;
				}
				return (match_here(sh,reg.sub(1,right_r),
					src.sub(1,right_s),arr)&&
					match_here(sh,reg.sub(right_r+1),
					src.sub(right_s+1),arr));
			}
			return match_here(sh,reg.sub(1),src.sub(1),arr);
		}
		return false;
	}

	static rbool match_multi(const tsh& sh,const rbuf<rstr>& reg,
		const rbuf<rstr>& src,rbuf<tword>& arr)
	{
		for(int i=0;i<=src.count();i++)
		{
			tword temp;
			temp.multi=src.sub(0,i);
			arr.push_move(temp);
			if(match_here(sh,reg,src.sub(i),arr))
			{
				return true;
			}
			else
			{
				arr.pop();
			}
		}
		return false;
	}

	static rbool replace_super_word(tword& word,const rbuf<rstr>& vstr,const rbuf<tword>& arr)
	{
		word.val.clear();
		for(int i=0;i<vstr.count();i++)
		{
			if(vstr[i]=="$"&&vstr.get(i+1).is_number())
			{
				int num=vstr.get(i+1).toint();
				if(num>=arr.count())
				{
					return false;
				}
				if(vstr.get(i+2)=="=>"&&vstr.get(i+3).is_number())
				{
					int index=vstr.get(i+3).toint();
					if(index>=arr[num].multi.count())
					{
						return false;
					}
					word.multi+=arr[num].multi[index];
					i+=3;
				}
				else
				{
					word.multi+=arr[num].multi;
					i++;
				}
			}
			else
			{
				word.multi+=vstr[i];
			}
		}
		link_sharp(word.multi);
		return true;
	}

	static void link_sharp(rbuf<rstr>& v)
	{
		for(int i=0;i<c_rs_deep;i++)
		{
			ifn(link_sharp_one(v))
			{
				return;
			}
		}
	}

	static rbool link_sharp_one(rbuf<rstr>& v)
	{
		rbuf<rstr> dst;
		rbool ret=false;
		for(int i=0;i<v.count();i++)
		{
			if(i<v.count()-2&&v[i+1]=="##")
			{
				rstr temp=ybase::del_quote(v[i])+ybase::del_quote(v[i+2]);
				if(v[i].get_bottom()==r_char('\"')||
					v[i+2].get_bottom()==r_char('\"'))
				{
					temp=ybase::add_quote(temp);
				}
				dst.push_move(temp);
				i+=2;
				ret=true;
			}
			elif(i<v.count()-1&&v[i]=="#")
			{
				dst.push(ybase::add_quote(v[i+1]));
				i++;
			}
			else
			{
				dst.push(v[i]);
			}
		}
		v=r_move(dst);
		return ret;
	}
};
﻿#pragma once

#include "ybase.h"

//词法分析
struct yword
{
	static rbool analyse(const tsh& sh,rstr& src,rbuf<tword>& result,const tfile* pfile)
	{
		result.clear();
		tword cur_word;
		cur_word.pos.file=(tfile*)pfile;
		cur_word.pos.line=1;
		int len;
		uchar* start;
		uchar* p;
		rstr stemp;
		stemp.set_size(sh.m_optr.m_optr_max);
		for(p=src.cstr();*p!=0;++p)
		{
			start=p;
			if(*p==r_char('/'))
			{
				//为了效率这里使用了过多的缩进
				if(*(p+1)==r_char('*'))
				{
					p+=2;
					int count=1;
					for(;*p!=0&&*(p+1)!=0;p++)
					{
						if(r_char('\n')==*p)
						{
							++cur_word.pos.line;
						}
						if(*p!=0&&*(p+1)!=0&&
							*p==r_char('/')&&
							*(p+1)==r_char('*'))
						{
							++count;
						}
						if(*p!=0&&*(p+1)!=0&&
							*p==r_char('*')&&
							*(p+1)==r_char('/'))
						{
							--count;
						}
						if(0==count)
						{
							break;
						}
					}
					if(count)
					{
						rserror(rstr(cur_word.pos.line)+
							rstr("miss */"));
						return false;
					}
					p++;
					continue;
				}
				elif(*(p+1)==r_char('/'))
				{
					p+=2;
					for(;*p&&*p!=r_char('\n');p++)
					{
						;
					}
					if(*p==0)
					{
						return true;
					}
					++cur_word.pos.line;
					continue;
				}
			}
			len=get_optr_s_len(sh,p,src.end()-p,stemp);
			if(len)
			{
				cur_word.val=rstr(p,p+len);
				result.push(cur_word);
				p+=len;
				p--;
			}
			elif(rstr::is_alpha(*p)||r_char('_')==*p||
				rcode::is_utf8_3(*p)&&*(p+1)!=0&&*(p+2)!=0||
				rcode::is_utf8_2(*p)&&*(p+1)!=0)
			{
				for(;*p!=0;++p)
				{
					if(rstr::is_number(*p)||
						rstr::is_alpha(*p)||r_char('_')==*p)
					{
						continue;
					}
					elif(rcode::is_utf8_3(*p)&&*(p+1)!=0&&*(p+2)!=0)
					{
						//todo
						//应该只能以汉字开头不能以特殊符号开头
						p+=2;
						continue;
					}
					elif(rcode::is_utf8_2(*p)&&*(p+1)!=0)
					{
						p++;
						continue;
					}
					else
					{
						break;
					}
				}
				cur_word.val=rstr(start,p);
				result.push(cur_word);
				p--;
			}
			elif(rstr::is_number(*p))
			{
				for(++p;*p!=0&&(rstr::is_number(*p)||r_char('_')==*p||
					rstr::is_alpha(*p));++p)
				{
					;
				}
				cur_word.val=rstr(start,p);
				result.push(cur_word);
				p--;
			}
			elif(r_char('\"')==*p)
			{
				int line=cur_word.pos.line;
				for(++p;*p!=0;++p)
				{
					if(r_char('\n')==*p)
					{
						++cur_word.pos.line;
					}
					if(*p==r_char('\\'))
					{
						if(*(p+1)==r_char('x')&&*(p+2)!=0&&*(p+3)!=0)
						{
							p+=3;
						}
						elif(*(p+1)!=0)
						{
							p++;
						}
						continue;
					}
					if(*p==r_char('\"'))
					{
						break;
					}
				}
				cur_word.pos.line=line;
				if(*p!=0)
				{
					cur_word.val=rstr(start,p+1);
					result.push(cur_word);
				}
				else
				{
					rserror(rstr(cur_word.pos.line)+
						rstr("miss \""));
					return false;
				}
			}
			elif(r_char('\'')==*p)
			{
				int line=cur_word.pos.line;
				for(++p;*p!=0;++p)
				{
					if(r_char('\n')==*p)
					{
						++cur_word.pos.line;
					}
					if(*p==r_char('\\'))
					{
						if(*(p+1)==r_char('x')&&*(p+2)!=0&&*(p+3)!=0)
						{
							p+=3;
						}
						elif(*(p+1)!=0)
						{
							p++;
						}
						continue;
					}
					if(*p==r_char('\''))
					{
						break;
					}
				}
				cur_word.pos.line=line;
				if(*p!=0)
				{
					cur_word.val=rstr(start,p+1);
					if(cur_word.val.count()<2)
					{
						rserror(rstr(cur_word.pos.line)+
							rstr("miss '"));
						return false;
					}
					cur_word.val[0]=r_char('\"');
					cur_word.val[cur_word.val.count()-1]=r_char('\"');
					add_rstr(sh,result,cur_word);
				}
				else
				{
					rserror(rstr(cur_word.pos.line)+
						rstr("miss '"));
					return false;
				}
			}
			elif(r_char('\n')==*p)
			{
				++cur_word.pos.line;
			}
			elif(r_char('`')==*p)
			{
				if(*(p+1)==0)
				{
					rserror(rstr(cur_word.pos.line)+
						rstr("miss `"));
					return false;
				}
				p++;
				cur_word.val=rstr((uint)(*(p)));
				result.push(cur_word);
			}
		}
		return true;
	}

	static int get_optr_s_len(const tsh& sh,const uchar* s,int len,rstr& stemp)
	{
		for(int i=sh.m_optr.m_optr_max;i>0;i--)
		{
			if(len<i)
			{
				continue;
			}
			xf::memcpy(stemp.begin(),s,i);
			stemp.m_buf.m_count=i;
			int pos=r_find_b<rstr>(sh.m_optr.m_optr_s,stemp);//这里是瓶颈
			if(pos<sh.m_optr.m_optr_s.count())
			{
				return sh.m_optr.m_optr_s[pos].count();
			}
		}
		return 0;
	}

	static void add_rstr(const tsh& sh,rbuf<tword>& result,const tword& word)
	{
		if(result.get_top()==rskey(c_import)||
			result.get_top()==rskey(c_include))
		{
			result.push(word);
			return;
		}
		tword temp;
		temp.pos=word.pos;
		temp.val=rskey(c_rstr);
		result.push(temp);
		temp.val=rsoptr(c_sbk_l);
		result.push(temp);
		result.push(word);
		temp.val=rsoptr(c_sbk_r);
		result.push(temp);
	}
};
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2012
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "rush", "rush.vcxproj", "{F132B255-A59F-48D1-9C64-69280C9BBD0A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F132B255-A59F-48D1-9C64-69280C9BBD0A}.Debug|Win32.ActiveCfg = Debug|Win32
		{F132B255-A59F-48D1-9C64-69280C9BBD0A}.Debug|Win32.Build.0 = Debug|Win32
		{F132B255-A59F-48D1-9C64-69280C9BBD0A}.Release|Win32.ActiveCfg = Release|Win32
		{F132B255-A59F-48D1-9C64-69280C9BBD0A}.Release|Win32.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal
﻿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F132B255-A59F-48D1-9C64-69280C9BBD0A}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>rush</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v110_xp</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v110_xp</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <OutputFile>$(OutDir)..\..\..\bin\$(ProjectName).exe</OutputFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <OutputFile>$(OutDir)..\..\..\bin\$(ProjectName).exe</OutputFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\rush.cxx" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\back\zasm.h" />
    <ClInclude Include="..\back\zbin.h" />
    <ClInclude Include="..\back\zgpp.h" />
    <ClInclude Include="..\back\zvm.h" />
    <ClInclude Include="..\back\zjit.h" />
    <ClInclude Include="..\back\zjitb.h" />
    <ClInclude Include="..\back\zjitf.h" />
    <ClInclude Include="..\back\zjiti.h" />
    <ClInclude Include="..\back\zmain.h" />
    <ClInclude Include="..\back\znasm.h" />
    <ClInclude Include="..\back\zopt.h" />
    <ClInclude Include="..\front\yadd.h" />
    <ClInclude Include="..\front\yautof.h" />
    <ClInclude Include="..\front\ybase.h" />
    <ClInclude Include="..\front\yclass.h" />
    <ClInclude Include="..\front\yclasstl.h" />
    <ClInclude Include="..\front\yconsteval.h" />
    <ClInclude Include="..\front\ycontrol.h" />
    <ClInclude Include="..\front\yexp.h" />
    <ClInclude Include="..\front\yfind.h" />
    <ClInclude Include="..\front\yformat.h" />
    <ClInclude Include="..\front\yfunctl.h" />
    <ClInclude Include="..\front\ylambda.h" />
    <ClInclude Include="..\front\ylazy.h" />
    <ClInclude Include="..\front\ymac.h" />
    <ClInclude Include="..\front\ymatch.h" />
    <ClInclude Include="..\front\ymemb.h" />
    <ClInclude Include="..\front\ypre.h" />
    <ClInclude Include="..\front\yrep.h" />
    <ClInclude Include="..\front\ysent.h" />
    <ClInclude Include="..\front\ysuper.h" />
    <ClInclude Include="..\front\yword.h" />
    <ClInclude Include="..\rlib\ralgo.h" />
    <ClInclude Include="..\rlib\rbuf.h" />
    <ClInclude Include="..\rlib\rcode.h" />
    <ClInclude Include="..\rlib\rdb.h" />
    <ClInclude Include="..\rlib\rdic.h" />
    <ClInclude Include="..\rlib\rdir.h" />
    <ClInclude Include="..\rlib\rf.h" />
    <ClInclude Include="..\rlib\rfile.h" />
    <ClInclude Include="..\rlib\rhash.h" />
    <ClInclude Include="..\rlib\rlist.h" />
    <ClInclude Include="..\rlib\rmutex.h" />
    <ClInclude Include="..\rlib\rnew.h" />
    <ClInclude Include="..\rlib\rpair.h" />
    <ClInclude Include="..\rlib\rset.h" />
    <ClInclude Include="..\rlib\rstr.h" />
    <ClInclude Include="..\rlib\rstrw.h" />
    <ClInclude Include="..\struct\tasm.h" />
    <ClInclude Include="..\struct\tbase.h" />
    <ClInclude Include="..\struct\tconf.h" />
    <ClInclude Include="..\struct\tdef.h" />
    <ClInclude Include="..\xlib\cpp\xbase.hpp" />
    <ClInclude Include="..\xlib\cpp\xf.hpp" />
    <ClInclude Include="..\xlib\xf.h" />
    <ClInclude Include="..\xlib\xfs.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>﻿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="rlib">
      <UniqueIdentifier>{5a98af4d-d0a1-4567-b038-2beed7edf748}</UniqueIdentifier>
    </Filter>
    <Filter Include="front">
      <UniqueIdentifier>{587fce6d-bb14-4f2e-9ed8-55eb21e387d5}</UniqueIdentifier>
    </Filter>
    <Filter Include="back">
      <UniqueIdentifier>{ad80822d-9cf8-45a4-ad48-f14dccdb7681}</UniqueIdentifier>
    </Filter>
    <Filter Include="struct">
      <UniqueIdentifier>{1bd38bd7-12db-4519-8f29-c890641f2fd3}</UniqueIdentifier>
    </Filter>
    <Filter Include="xlib">
      <UniqueIdentifier>{9912fb30-874f-44ba-9f10-ebc090f6e14f}</UniqueIdentifier>
    </Filter>
    <Filter Include="xlib\cpp">
      <UniqueIdentifier>{6acb8975-096a-4915-b0ce-939c39fba2fa}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\rush.cxx">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\rlib\ralgo.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rbuf.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rcode.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rdb.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rdic.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rdir.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rf.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rfile.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rhash.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rlist.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rmutex.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rnew.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rpair.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rset.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rstr.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\rlib\rstrw.h">
      <Filter>rlib</Filter>
    </ClInclude>
    <ClInclude Include="..\back\zasm.h">
      <Filter>back</Filter>
    </ClInclude>
    <ClInclude Include="..\back\zbin.h">
      <Filter>back</Filter>
    </ClInclude>
    <ClInclude Include="..\back\zgpp.h">
      <Filter>back</Filter>
    </ClInclude>
    <ClInclude Include="..\back\zjit.h">
      <Filter>back</Filter>
    </ClInclude>
    <ClInclude Include="..\back\zjitb.h">
      <Filter>back</Filter>
    </ClInclude>
    <ClInclude Include="..\back\zjitf.h">
      <Filter>back</Filter>
    </ClInclude>
    <ClInclude Include="..\back\zjiti.h">
      <Filter>back</Filter>
    </ClInclude>
    <ClInclude Include="..\back\zmain.h">
      <Filter>back</Filter>
    </ClInclude>
    <ClInclude Include="..\back\znasm.h">
      <Filter>back</Filter>
    </ClInclude>
    <ClInclude Include="..\back\zopt.h">
      <Filter>back</Filter>
    </ClInclude>
    <ClInclude Include="..\front\yadd.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\yautof.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\ybase.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\yclass.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\yclasstl.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\yconsteval.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\ycontrol.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\yexp.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\yfind.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\yfunctl.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\ylambda.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\ylazy.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\ymac.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\ymatch.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\ymemb.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\ypre.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\yrep.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\ysent.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\ysuper.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\yword.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\front\yformat.h">
      <Filter>front</Filter>
    </ClInclude>
    <ClInclude Include="..\struct\tasm.h">
      <Filter>struct</Filter>
    </ClInclude>
    <ClInclude Include="..\struct\tbase.h">
      <Filter>struct</Filter>
    </ClInclude>
    <ClInclude Include="..\struct\tconf.h">
      <Filter>struct</Filter>
    </ClInclude>
    <ClInclude Include="..\struct\tdef.h">
      <Filter>struct</Filter>
    </ClInclude>
    <ClInclude Include="..\back\zvm.h">
      <Filter>back</Filter>
    </ClInclude>
    <ClInclude Include="..\xlib\xf.h">
      <Filter>xlib</Filter>
    </ClInclude>
    <ClInclude Include="..\xlib\cpp\xbase.hpp">
      <Filter>xlib\cpp</Filter>
    </ClInclude>
    <ClInclude Include="..\xlib\cpp\xf.hpp">
      <Filter>xlib\cpp</Filter>
    </ClInclude>
    <ClInclude Include="..\xlib\xfs.h">
      <Filter>xlib</Filter>
    </ClInclude>
  </ItemGroup>
</Project>﻿#pragma once

#include "rbuf.h"

//binary search
template<typename T>
int r_find_b(const rbuf<T>& v,const T& a)
{
	int left=0;
	int right=v.count()-1;
	int mid;
	while(left<=right)
	{
		mid=(left+right)/2;
		if(v[mid]<a)
		{
			left=mid+1;
		}
		elif(a<v[mid])
		{
			right=mid-1;
		}
		else
		{
			return mid;
		}
	}
	return v.count();
}

template<typename T>
rbool r_not_equal(const T& a,const T& b)
{
	return a<b||b<a;
}

template<typename T>
void r_swap(T& a,T& b)
{
	T temp(r_move(a));
	a=r_move(b);
	b=r_move(temp);
}

template<typename T>
void r_reverse(rbuf<T>& v,int begin=0,int end=0)
{
	if(end<=0)
	{
		end=v.count();
	}
	if(begin<0)
	{
		begin=0;
	}
	rbuf<T> temp=v.sub(begin,end);
	int i=end-1;
	int j=0;
	while(i>=begin)
	{
		v[i]=r_move(temp[j]);
		i--;
		j++;
	}
}

template<typename T>
void r_qsort_in(rbuf<T>& v,int left,int right)
{
	if(left<right)
	{
		T pivot=v[right];
		int i=left;
		for(int j=left;j<right;j++)
		{
			if(v[j]<=pivot)
			{
				r_swap<T>(v[i],v[j]);
				i++;
			}
		}
		r_swap<T>(v[i],v[right]);
		r_qsort_in<T>(v,left,i-1);
		r_qsort_in<T>(v,i+1,right);
	}
}

template<typename T>
void r_qsort(rbuf<T>& v,int begin=0,int end=0)
{
	if(end<=0)
	{
		end=v.count();
	}
	if(begin<0)
	{
		begin=0;
	}
	if(begin+1<end)
	{
		r_qsort_in<T>(v,begin,end-1);
	}
}

template<typename T>
int r_find_a(const rbuf<T>& v,T a,int start=0)
{
	for(int i=start;i<v.count();i++)
	{
		if(a==v[i])
		{
			return i;
		}
	}
	return v.count();
}

template<typename V>
int r_find(const V& v,const V& m,int start=0)
{
	if(m.empty()||start>=v.count())
	{
		return v.count();
	}
	for(int i=start;i<v.count()-m.count()+1;i++)
	{
		if(v[i]!=m[0])
		{
			continue;
		}
		int j;
		for(j=0;j<m.count();j++)
		{
			if(v[i+j]!=m[j])
			{
				break;
			}
		}
		if(j>=m.count())
		{
			return i;
		}
	}
	return v.count();
}

template<typename V>
rbuf<V> r_split(const V& v,const V& m,int start=0)
{
	rbuf<V> result;
	V temp;
	int i;
	while(start<v.count())
	{
		int pos=r_find<V>(v,m,start);
		if(pos>=v.count())
		{
			break;
		}
		temp.clear();
		for(i=start;i<pos;i++)
		{
			temp+=v[i];
		}
		if(!temp.empty())
		{
			result.push_move(temp);
		}
		start=pos+m.count();
	}
	temp.clear();
	for(i=start;i<v.count();i++)
	{
		temp+=v[i];
	}
	if(!temp.empty())
	{
		result.push_move(temp);
	}
	return r_move(result);
}

template<typename T>
rbuf<rbuf<T> > r_split_a(const rbuf<T>& v,const T& a,int start=0)
{
	return r_split<rbuf<T> >(v,rbuf<T>(1,a),start);
}

//允许空元素
template<typename V>
rbuf<V> r_split_e(const V& v,const V& m,int start=0)
{
	rbuf<V> result;
	V temp;
	int i;
	while(start<v.count())
	{
		int pos=r_find<V>(v,m,start);
		if(pos>=v.count())
		{
			break;
		}
		temp.clear();
		for(i=start;i<pos;i++)
		{
			temp+=v[i];
		}
		result.push_move(temp);
		start=pos+m.count();
	}
	temp.clear();
	for(i=start;i<v.count();i++)
	{
		temp+=v[i];
	}
	ifn(result.empty()&&temp.empty())//todo:
	{
		result.push_move(temp);
	}
	return r_move(result);
}

template<typename T>
rbuf<rbuf<T> > r_split_e_a(const rbuf<T>& v,const T& a,int start=0)
{
	return r_split_e<rbuf<T> >(v,rbuf<T>(1,a),start);
}
﻿#pragma once

#include "rnew.h"

template<typename T>
struct rbuf
{
	T* m_p;
	int m_count;
	int m_max;
	uchar m_block[16];
	//当分配小内存时，m_p指向m_block，无需new可提高效率

	~rbuf<T>()
	{
		free_x();
	}

	rbuf<T>()
	{
		init();
	}

	rbuf<T>(int num)
	{
		init();
		alloc(num);
	}

	rbuf<T>(int num,const T& a)
	{
		init();
		alloc(num);
		for(int i=0;i<num;i++)
		{
			m_p[i]=a;
		}
	}

	rbuf<T>(const rbuf<T>& a)
	{
		init();
		copy(a);
	}

	rbuf<T>(rbuf<T>&& a)
	{
		move(a);
	}

	void move(rbuf<T>& a)
	{
#ifndef _RS
		if(a.m_p==(T*)(a.m_block))
		{
			xf::memcpy(this,&a,r_size(a));
			m_p=(T*)m_block;
		}
		else
		{
			m_p=a.m_p;
			m_count=a.m_count;
			m_max=a.m_max;
		}
#else
		if(a.m_p==&a.m_block)
		{
			xf::memcpy(this,&a,r_size(a));
			m_p=&m_block;
		}
		else
		{
			m_p=a.m_p;
			m_count=a.m_count;
			m_max=a.m_max;
		}
#endif
		a.init();//如果move后对象不再使用可以只置空a.m_p
	}

	//如果复制指针一定要处理好等于号，不支持自己复制自己
	void operator=(const rbuf<T>& a)
	{
		if(a.m_p!=m_p)
		{
			copy(a);
		}
	}

	void operator=(rbuf<T>&& a)
	{
		free_x();
		move(a);
	}

	friend rbuf<T> operator+(const rbuf<T>& a,const rbuf<T>& b)
	{
		int total=a.count()+b.count();
		int max=r_max(a.m_max,b.m_max);
		rbuf<T> ret;
		if(total>max)
		{
			ret.alloc_not_change(extend_num(total));
		}
		else
		{
			ret.alloc_not_change(max);
		}
		int i;
		for(i=0;i<a.count();i++)
		{
			ret[i]=a[i];
		}
		for(i=0;i<b.count();i++)
		{
			ret[i+a.count()]=b[i];
		}
		ret.m_count=total;
		return r_move(ret);
	}

	void operator+=(const rbuf<T>& a)
	{
		int total=a.count()+count();
		if(total>m_max)
		{
			realloc_not_change(extend_num(total));
		}
		for(int i=count();i<total;i++)
		{
			m_p[i]=a[i-count()];
		}
		m_count=total;
	}

	void operator+=(rbuf<T>&& a)
	{
		int total=a.count()+count();
		if(total>m_max)
		{
			realloc_not_change(extend_num(total));
		}
		for(int i=count();i<total;i++)
		{
			m_p[i]=r_move(a[i-count()]);
		}
		m_count=total;
	}

	void operator+=(const T& a)
	{
		this->push(a);
	}

	void operator+=(T&& a)
	{
		this->push(a);
	}

	T& operator[](int num) const
	{
		return m_p[num];
	}

	friend rbool operator==(const rbuf<T>& a,const rbuf<T>& b)
	{
		if(a.count()!=b.count())
		{
			return false;
		}
		for(int i=0;i<a.count();++i)
		{
			if(a[i]!=b[i])
			{
				return false;
			}
		}
		return true;
	}

	friend rbool operator!=(const rbuf<T>& a,const rbuf<T>& b)
	{
		return !(a==b);
	}

	void init()
	{
		m_p=null;
		m_count=0;
		m_max=0;
	}

	static T* next(void* p)
	{
		return (T*)p+1;
	}

	static T* prev(void* p)
	{
		return (T*)p-1;
	}

	int size() const 
	{
		return m_count*r_size(T);
	}

	int count() const
	{
		return m_count;
	}

	T* begin() const 
	{
		return m_p;
	}

	T* end() const 
	{
		return m_p+count();
	}

	T* rbegin() const 
	{
		if(0==m_count)
		{
			return null;
		}
		else
		{
			return m_p+count()-1;
		}
	}

	T* rend() const 
	{
		if(0==m_count)
		{
			return null;
		}
		else
		{
			return m_p-1;
		}
	}

	rbool empty() const 
	{
		return 0==m_count;
	}

	void clear()
	{
		m_count=0;
	}

	static int extend_num(int num)
	{
		return r_cond(num<16,16,num*2);
	}
	
	//应判断m_count是否太大,否则在64位上m_count++有可能归零
	void push(const T& a)
	{
		if(m_count>=m_max)
		{
			realloc_not_change(extend_num(m_count));
		}
		m_p[count()]=a;
		m_count++;
	}

	void push(T&& a)
	{
		if(m_count>=m_max)
		{
			realloc_not_change(extend_num(m_count));
		}
		m_p[count()]=a;
		m_count++;
	}

	void push_move(const T& a)
	{
		this->push(r_move(a));
	}

	T pop()
	{
		m_count--;
		return m_p[count()];
	}

	T pop_front()
	{
		T ret=r_move(m_p[0]);
		erase(0);
		return r_move(ret);
	}

	//没必要增加push_front的move版本
	void push_front(const T& a)
	{
		insert(0,a);
	}

	T& top() const 
	{
		return m_p[count()-1];
	}

	T& bottom() const 
	{
		return m_p[0];
	}

	T get_top() const 
	{
		if(count()>0)
		{
			return m_p[count()-1];
		}
		return T();
	}

	T get_right() const 
	{
		return get_top();
	}

	T get_bottom() const 
	{
		if(count()>0)
		{
			return m_p[0];
		}
		return T();
	}

	T get_left() const 
	{
		return get_bottom();
	}

	rbool erase(int num)
	{
		if(num>=count()||num<0)
		{
			return false;
		}
		for(int i=num;i<count()-1;++i)
		{
			*(m_p+i)=r_move(*(m_p+i+1));
		}
		m_count--;
		return true;
	}

	rbool erase(int begin,int end)
	{
		if(begin<0||end>count()||begin>=end)
		{
			return false;
		}
		for(int i=0;i<count()-end;i++)//count()-(end-begin)-begin
		{
			m_p[i+begin]=r_move(m_p[end+i]);//删除的元素稍后析构
		}
		m_count-=end-begin;
		return true;
	}

	rbool insert(int pos,const T& a)
	{
		if(pos>count()||pos<0)
		{
			return false;
		}
		if(m_count>=m_max)
		{
			realloc_not_change(extend_num(m_count));
		}
		for(int i=count();i>pos;--i)
		{
			m_p[i]=r_move(m_p[i-1]);
		}
		m_p[pos]=a;
		m_count++;
		return true;
	}

	rbool insert(int pos,const rbuf<T>& a)
	{
		if(pos>count()||pos<0||0==a.count())
		{
			return false;
		}
		if(m_max<m_count+a.count())
		{
			realloc_not_change(a.count()+count());
		}
		for(int i=0;i<count()-pos;i++)
		{
			m_p[a.count()+count()-1-i]=r_move(m_p[count()-1-i]);
		}
		for(int i=0;i<a.count();i++)
		{
			m_p[pos+i]=a[i];
		}
		m_count+=a.count();
		return true;
	}

	T* v_new(int num) const
	{
#ifdef _RGPP
		return r_new<T>(num);//GPP模式不能使用此优化技巧
#endif
		if(num*r_size(T)<=16)
		{
#ifndef _RS
			return (T*)m_block;
#else
			return &m_block;
#endif
		}
		return r_new<T>(num);
	}

	void v_delete()
	{
#ifdef _RGPP
		r_delete<T>(m_p);
		return;
#endif
#ifndef _RS
		if(m_p!=(T*)m_block)
		{
			r_delete<T>(m_p);
		}
#else
		if(m_p!=&m_block)
		{
			r_delete<T>(m_p);
		}
#endif
	}

	//这里的重复代码可用宏或者模板简化
	void alloc(int num)
	{
		if(m_p!=null)
		{
			return;
		}
		if(num<=0)
		{
			init();
			return;
		}
		m_p=v_new(num);
		m_max=num;
		m_count=m_max;
	}

	void alloc_not_change(int num)
	{
		if(m_p!=null)
		{
			return;
		}
		if(num<=0)
		{
			init();
			return;
		}
		m_p=v_new(num);
		m_max=num;
	}

	void realloc(int num)
	{
		if(null==m_p)
		{
			alloc(num);
			return;
		}
		if(num<=0)
		{
			free();
			return;
		}
		realloc_not_change_in(num);
		m_count=m_max;
	}

	void realloc_not_change(int num)
	{
		if(null==m_p)
		{
			alloc_not_change(num);
			return;
		}
		if(num<=0)
		{
			free();
			return;
		}
		realloc_not_change_in(num);
	}

	void realloc_not_change_in(int num)
	{
		T* p=v_new(num);
		int copy_size=r_min(num,m_count);
		for(int i=0;i<copy_size;i++)
		{
			p[i]=r_move(m_p[i]);
		}
		v_delete();
		m_p=p;
		m_max=num;
	}
	
	//不复制原有的元素
	void realloc_n(int num)
	{
		if(null==m_p)
		{
			alloc(num);
			return;
		}
		if(num<=0)
		{
			free();
			return;
		}
		v_delete();
		m_p=v_new(num);
		m_max=num;
		m_count=m_max;
	}

	void realloc_n_not_change(int num)
	{
		if(null==m_p)
		{
			alloc_not_change(num);
			return;
		}
		if(num<=0)
		{
			free();
			return;
		}
		v_delete();
		m_p=v_new(num);
		m_max=num;
	}
	
	void free_x()
	{
		if(null!=m_p)//m_p为空时rbuf必须保证m_count和m_max也为空
		{
			v_delete();
		}
	}

	void free()
	{
		free_x();
		init();
	}

	void copy(const rbuf<T>& a)
	{
		if(m_max<a.count())
		{
			realloc_n_not_change(a.m_max);
		}
		for(int i=0;i<a.count();i++)
		{
			m_p[i]=a[i];
		}
		m_count=a.count();
	}

	T get(int i) const
	{
		if((uint)i>=(uint)(count()))//补码判断
		{
			return T();
		}
		else 
		{
			return m_p[i];
		}
	}

	rbuf<T> sub(int begin,int end) const 
	{
		if(end>count())
		{
			end=count();
		}
		if(begin<0)
		{
			begin=0;
		}
		int temp=end-begin;
		rbuf<T> ret(temp);//alloc会判断temp<0的情况，所以不需要判断begin>=end
		for(int i=0;i<temp;i++)
		{
			ret[i]=m_p[begin+i];
		}
		return r_move(ret);
	}

	rbuf<T> sub(int begin) const 
	{
		return sub(begin,count());
	}

	rbool exist(const T& a) const
	{
		for(int i=0;i<count();i++)
		{
			if(a==m_p[i])
			{
				return true;
			}
		}
		return false;
	}

	int find(const T& a,int begin=0) const
	{
		for(int i=begin;i<count();i++)
		{
			if(a==m_p[i])
			{
				return i;
			}
		}
		return count();
	}

	int find_last(const T& a) const
	{
		for(int i=count()-1;i>=0;i--)
		{
			if(a==m_p[i])
			{
				return i;
			}
		}
		return count();
	}

	void print() const 
	{
		for(int i=0;i<count();i++)
		{
			m_p[i].print();
		}
	}

	void printl() const 
	{
		for(int i=0;i<count();i++)
		{
			m_p[i].printl();
		}
	}
#ifdef _RS
	rstr join(rstr s) const
	{
		rstr ret
		for i=0;i<count;i++
			if i!=0
				ret+=s
			ret+=m_p[i].torstr
		return ret
	}
	
	rbuf<T> map(void* f) const
	{
		rbuf<T> ret
		for i=0;i<count;i++
			ret.push(T[f,m_p[i]])
		return ret
	}
	
	void parallel(int num,void* f)
	{
		rmutex* pmu=r_new<rmutex>()
		int* pcur=r_new<int>()
		rbuf<T>* pthis=this
		rbuf<int> arr_thr
		*pcur=0
		for i=0;i<num;i++
			arr_thr.push(xf.create_thr(lambda(void* param){
				for
					pmu->enter
					if *pcur>=pthis->count
						pmu->leave
						return
					index=*pcur
					(*pcur)++
					pmu->leave
					void[f,&(*pthis)[index]]
			}))
		for i in arr_thr
			xf.wait_thr(arr_thr[i])
			xf.CloseHandle(arr_thr[i])
		r_delete<int>(pcur)
		r_delete<rmutex>(pmu)
	}
#endif
};
﻿#pragma once

#include "rstr.h"

struct rcode
{
	static rstr gbk_to_utf8(const rstr& s)
	{
		return utf16_to_utf8(gbk_to_utf16(s));
	}

	static rstr gbk_to_utf16(rstr s)
	{
		rstr result;
		int size=xf::gbk_to_utf16(s.cstr_t(),null,0);
		if(size<=0)
		{
			return result;
		}
		result.set_size(size*2);
		size=xf::gbk_to_utf16(s.cstr_t(),result.cstrw_t(),size);
		if(size<=0)
		{
			return rstr();
		}
		result.m_buf.m_count-=2;
		return r_move(result);
	}

	static rstr utf16_to_gbk(rstr s)
	{
		rstr result;
		int size=xf::utf16_to_gbk(s.cstrw_t(),null,0);
		if(size<=0)
		{
			return result;
		}
		result.set_size(size);
		size=xf::utf16_to_gbk(s.cstrw_t(),(char*)(result.begin()),size);
		if(size<=0)
		{
			return rstr();
		}
		result.pop();
		return r_move(result);
	}

	static rstr utf8_to_gbk(const rstr& s)
	{
		return utf16_to_gbk(utf8_to_utf16(s));
	}

	static rstr utf8_to_utf16(const rstr& s)
	{
		ushort temp;
		rstr result;
		for(int i=0;i<s.count();i++)
		{
			//todo: 未处理is_utf8_4
			if(is_utf8_3(s[i]))
			{
				if(i+2>=s.count())
				{
					continue;
				}
				temp=0;
				temp=(ushort)(OR(temp,SHL(AND(s[i],0xef),12)));
				temp=(ushort)(OR(temp,SHL(AND(s[i+1],0x3f),6)));
				temp=(ushort)(OR(temp,AND(s[i+2],0x3f)));
				result.push(get_first(temp));
				result.push(get_second(temp));
				i+=2;
			}
			elif(is_utf8_2(s[i]))
			{
				if(i+1>=s.count())
				{
					continue;
				}
				temp=0;
				temp=(ushort)(OR(temp,SHL(AND(s[i],0x1f),6)));
				temp=(ushort)(OR(temp,AND(s[i+1],0x3f)));
				result.push(get_first(temp));
				result.push(get_second(temp));
				i++;
			}
			else
			{
				result.push(s[i]);
				result.push((uchar)0);
			}
		}
		return r_move(result);
	}

	static rstr utf16_to_utf8(const rstr& s)
	{
		rstr result;
		if(s.count()%2!=0)
		{
			return result;
		}
		ushort temp;
		for(int i=0;i<s.count();i+=2)
		{
			if(s[i]<=0x7f&&s[i+1]==0)
			{
				result+=s[i];
				continue;
			}
			temp=*(ushort*)(s.begin()+i);
			if(s[i]>0x7f&&s[i+1]<=0x7)
			{
				result.push((uchar)(OR(SHR(temp,6),0xc0)));
				result.push((uchar)(OR(AND(temp,0x3f),0x80)));
			}
			else
			{
				result.push((uchar)(OR(SHR(temp,12),0xe0)));
				result.push((uchar)(OR(AND(SHR(temp,6),0x3f),0x80)));
				result.push((uchar)(OR(AND(temp,0x3f),0x80)));
			}
		}
		return r_move(result);
	}

	static rstr to_utf16_txt(const rstr& s)
	{
		if(is_utf16_txt(s))
		{
			return s;
		}
		rstr temp;
		temp.push((uchar)0xff);
		temp.push((uchar)0xfe);
		if(is_utf8_txt(s))
		{
			return temp+utf8_to_utf16(s.sub(3));
		}
		return temp+gbk_to_utf16(s);
	}

	static rstr add_utf8_head(const rstr& s)
	{
		rstr temp;
		temp.push((uchar)0xef);
		temp.push((uchar)0xbb);
		temp.push((uchar)0xbf);
		temp+=s;
		return r_move(temp);
	}

	static rstr to_utf8_txt(const rstr& s)
	{
		if(is_utf8_txt(s))
		{
			return s;
		}
		rstr temp;
		temp.push((uchar)0xef);
		temp.push((uchar)0xbb);
		temp.push((uchar)0xbf);
		if(is_utf16_txt(s))
		{
			return temp+utf16_to_utf8(s.sub(2));
		}
		return temp+gbk_to_utf8(s);
	}

	static rstr to_gbk_txt(const rstr& s)
	{
		if(is_utf8_txt(s))
		{
			return utf8_to_gbk(s.sub(3));
		}
		if(is_utf16_txt(s))
		{
			return utf16_to_gbk(s.sub(2));
		}
		return r_move(s);
	}

	static rbool is_utf16_txt(const rstr& s)
	{
		return (s.count()>=2&&
			s[0]==0xff&&
			s[1]==0xfe);
	}

	static rbool is_utf8_txt(const rstr& s)
	{
		return (s.count()>=3&&
			s[0]==0xef&&
			s[1]==0xbb&&
			s[2]==0xbf);
	}

	static rbool is_utf16_big_txt(const rstr& s)
	{
		return (s.count()>=2&&
			s[0]==0xfe&&
			s[1]==0xff);
	}

	static rbool is_utf32_txt(const rstr& s)
	{
		if(s.count()<4)
		{
			return false;
		}
		if(s[0]==0&&s[1]==0&&s[2]==0xfe&&s[3]==0xff)
		{
			return true;
		}
		if(s[0]==0xff&&s[1]==0xfe&&s[2]==0&&s[3]==0)
		{
			return true;
		}
		return false;
	}

	//是否utf8 3个字节起始
	static rbool is_utf8_3(uchar ch)
	{
		return ch>=0xe0&&ch<=0xef;
	}

	static rbool is_utf8_2(uchar ch)
	{
		return ch>=0xc0&&ch<=0xdf;
	}

	//是否unicode汉字，共20902个，+2个不常用字
	static rbool is_chs(ushort w)
	{
		return w>=0x4e00&&w<0x9fa6;
	}

	//是否gbk汉字第一字节，分布范围大约 30000多
	static rbool is_chs_first(uchar ch)
	{
		return ch>=0x81&&ch<=0xfd;
	}

	static char& get_second(ushort& ch)
	{
		return *((char*)(&ch)+1);
	}

	static char& get_first(ushort& ch)
	{
		return *((char*)(&ch));
	}

	//返回所需缓存区大小
	static int gbk_to_utf8_c(const uchar* src,uchar* dst)
	{
		rstr s=gbk_to_utf8(src);
		s.push((uchar)0);
		if(dst!=null)
		{
			xf::memcpy(dst,s.begin(),s.count());
		}
		return s.count();
	}

	static int gbk_to_utf16_c(const uchar* src,uchar* dst)
	{
		rstr s=gbk_to_utf16(src);
		s.push((uchar)0);
		s.push((uchar)0);
		if(dst!=null)
		{
			xf::memcpy(dst,s.begin(),s.count());
		}
		return s.count();
	}

	static int utf8_to_gbk_c(const uchar* src,uchar* dst)
	{
		rstr s=utf8_to_gbk(src);
		s.push((uchar)0);
		if(dst!=null)
		{
			xf::memcpy(dst,s.begin(),s.count());
		}
		return s.count();
	}

	static int utf8_to_utf16_c(const uchar* src,uchar* dst)
	{
		rstr s=utf8_to_utf16(src);
		s.push((uchar)0);
		s.push((uchar)0);
		if(dst!=null)
		{
			xf::memcpy(dst,s.begin(),s.count());
		}
		return s.count();
	}

	static int utf16_to_gbk_c(const uchar* src,uchar* dst)
	{
		rstr s;
		for(const uchar* p=src;;p+=2)
		{
			if(*p==0&&*(p+1)==0)
			{
				s.set_size(p-src);
				xf::memcpy(s.begin(),src,s.count());
				break;
			}
		}
		s=utf16_to_gbk(s);
		s.push((uchar)0);
		if(dst!=null)
		{
			xf::memcpy(dst,s.begin(),s.count());
		}
		return s.count();
	}

	static int utf16_to_utf8_c(const uchar* src,uchar* dst)
	{
		rstr s;
		for(const uchar* p=src;;p+=2)
		{
			if(*p==0&&*(p+1)==0)
			{
				s.set_size(p-src);
				xf::memcpy(s.begin(),src,s.count());
				break;
			}
		}
		s=utf16_to_utf8(s);
		s.push((uchar)0);
		if(dst!=null)
		{
			xf::memcpy(dst,s.begin(),s.count());
		}
		return s.count();
	}
};
﻿#pragma once

#include "rfile.h"

#define rdbint rdb<int,int>

//TL是数据长度，TA是地址
template<typename TA,typename TL>//uchar,ushort,uint,uint64
struct rdb
{
	rfile m_file;//use multi thread please define multi object
	rbuf<TA> m_index;

	enum
	{
		c_null,//空数据
		c_real,
		c_cp,//压缩数据
		c_error//异常数据
	};

	rdb()
	{
	}

	rdb(rstr name,rstr mode=rstr("r"))
	{
		open(name,mode);
	}

	rbool close()
	{
		return m_file.close();
	}

	rbool open_off(rstr name,int off,rstr mode="r")
	{
		if(!m_file.open(name,mode))
		{
			return false;
		}
		m_file.set_off(off);
		TL count;
		if(!m_file.read(r_size(TL),&count))
		{
			return false;
		}
		TL cmax;
		if(!m_file.read(r_size(TL),&cmax))//todo: r_size(cmax)
		{
			return false;
		}
		m_index.realloc_n_not_change(cmax);
		if(!m_file.read(count*r_size(TA),m_index.begin()))
		{
			return false;
		}
		m_index.m_count=count;
		for(int i=0;i<m_index.count();i++)
		{
			m_index[i]+=off;
		}
		return true;
	}

	rbool open(rstr name,rstr mode="r")
	{
		if(!rfile::exist(name))
		{
			if(!m_file.open_n(name,"rw"))
			{
				return false;
			}
			TL count=0;
			if(!m_file.write(r_size(TL),&count))
			{
				return false;
			}
			if(!m_file.write(r_size(TL),&count))
			{
				return false;
			}
			if(!m_file.close())
			{
				return false;
			}
		}
		if(!m_file.open(name,mode))
		{
			return false;
		}
		TL count;
		if(!m_file.read(r_size(TL),&count))
		{
			return false;
		}
		TL cmax;
		if(!m_file.read(r_size(TL),&cmax))
		{
			return false;
		}
		m_index.realloc_n_not_change(cmax);
		if(!m_file.read(count*r_size(TA),m_index.begin()))
		{
			return false;
		}
		m_index.m_count=count;
		return true;
	}

	int count() const
	{
		return m_index.count();
	}

	rstr operator[](int i)
	{
		rstr ret;
		if(!read(i,ret))
		{
			null;
		}
		return r_move(ret);
	}
	
	rbool read(int i,rstr& data)
	{
		data.clear();
		if(i>=m_index.count()||i<0)
		{
			return false;
		}
		if(m_index[i]==0)
		{
			return true;
		}
		char flag;
		TA off=m_index[i];
		if(!m_file.read(off,r_size(char),&flag))
		{
			return false;
		}
		if(flag==c_null)
		{
			return true;
		}
		if(flag!=c_real)
		{
			return false;
		}
		TL len;
		off+=r_size(char);
		if(!m_file.read(off,r_size(TL),&len))
		{
			return false;
		}
		data.m_buf.realloc_n(len);
		off+=r_size(TL);
		if(!m_file.read(off,data.count(),data.begin()))
		{
			return false;
		}
		return true;
	}

	rbool write(int i,const rstr& data)
	{
		if(i>=m_index.count()||i<0)
		{
			return false;
		}
		char flag=c_null;
		TA off=m_index[i];
		if(!m_file.write(off,r_size(char),&flag))
		{
			return false;
		}
		flag=c_real;
		off=m_file.size();
		m_index[i]=off;
		if(!m_file.write(off,r_size(char),&flag))
		{
			return false;
		}
		off+=r_size(char);
		TL len=data.count();
		if(!m_file.write(off,r_size(TL),&len))
		{
			return false;
		}
		off+=r_size(TL);
		if(!m_file.write(off,data.count(),data.begin()))
		{
			return false;
		}
		if(!m_file.write(get_index_off(i),r_size(TA),&m_index[i]))
		{
			return false;
		}
		return true;
	}

	rbool write_new(const rstr& data)
	{
		if(m_index.m_count>=m_index.m_max)
		{
			if(!extend())
			{
				return false;
			}
		}
		TA off;
		off=m_file.size();
		m_index.push(off);
		char flag=c_real;
		if(!m_file.write(off,r_size(char),&flag))
		{
			return false;
		}
		off+=r_size(char);
		TL len=data.count();
		if(!m_file.write(off,r_size(TL),&len))
		{
			return false;
		}
		off+=r_size(TL);
		if(!m_file.write(off,data.count(),data.begin()))
		{
			return false;
		}
		int i=m_index.count()-1;
		if(!m_file.write(get_index_off(i),r_size(TA),&m_index[i]))
		{
			return false;
		}
		if(!m_file.write(0,r_size(TL),&m_index.m_count))
		{
			return false;
		}
		return true;
	}

	rbool extend()
	{
		if(m_file.size()>=128*1024*1024)
		{
			return false;
		}
		rbuf<uchar> temp;
		temp.alloc(m_file.size()-get_data_off());
		if(!m_file.read(get_data_off(),temp.size(),temp.begin()))
		{
			return false;
		}
		int cmax=m_index.m_max;
		m_index.realloc_not_change(m_index.extend_num(m_index.count()));
		for(int i=0;i<m_index.count();i++)
		{
			m_index[i]+=(m_index.m_max-cmax)*r_size(TA);
		}
		if(!m_file.write(r_size(TL),r_size(TL),&m_index.m_max))
		{
			return false;
		}
		//这里必须用m_cmax,不能用m_count，因为刚开始只有8个字节
		if(!m_file.write(r_size(TL)*2,
			m_index.m_max*r_size(TA),m_index.begin()))
		{
			return false;
		}
		if(!m_file.write(get_data_off(),temp.size(),temp.begin()))
		{
			return false;
		}
		return true;
	}

	int find(rstr s) const
	{
		for(int i=0;i<count();i++)
		{
			if(operator[](i)==s)
			{
				return i;
			}
		}
		return count();
	}

	TA get_data_off() const
	{
		return m_index.m_max*r_size(TA)+r_size(TL)*2;
	}

	static int get_index_off(int i)
	{
		return r_size(TL)*2+r_size(TA)*i;
	}
};
﻿#pragma once

#include "rstr.h"
#include "rset.h"

template<typename T>
struct rdic_i
{
	T val;//val必须前置
	rstr key;

	friend rbool operator<(const rdic_i<T>& a,const rdic_i<T>& b)
	{
		return a.key<b.key;
	}
};

template<typename T>
struct rdic
{
	rset<rdic_i<T> > m_set;

	void clear()
	{
		m_set.clear();
	}

	T* begin() const
	{
		return (T*)(m_set.begin());
	}

	T* end() const
	{
		return (T*)(m_set.end());
	}

	T* next(T* p) const
	{
		return (T*)(m_set.next((rdic_i<T>*)p));
	}

	rstr get_key(T* p) const
	{
		return ((rdic_i<T>*)p)->key;
	}

	rbool empty() const
	{
		return m_set.empty();
	}

	int count() const
	{
		return m_set.count();
	}

	rbool exist(const rstr& key) const
	{
		rdic_i<T> item;
		item.key=key;
		return m_set.exist(item);
	}

	T* find(const rstr& key) const
	{
		rdic_i<T> item;
		item.key=key;
		return (T*)(m_set.find(item));
	}

	void insert(const rstr& key,const T& val)
	{
		rdic_i<T> item;
		item.key=key;
		item.val=val;
		m_set.insert(item);
	}

	T& operator[](const rstr& key)
	{
		rdic_i<T> item;
		item.key=key;
		m_set.insert_c(item);
		rdic_i<T>* p=m_set.find(item);
		return p->val;
	}
};
﻿#pragma once

#include "rstrw.h"
#include "rlist.h"

struct rdir
{
	enum
	{
		c_max_path=260,
		c_file_attr_dir=0x00000010,
	};
	
	static rstrw erase_suffix_w(const rstrw& name)
	{
		rstrw s=get_suffix_w(name);
		return name.sub(0,name.count()-s.count()-1);
	}

	static rstr erase_suffix(const rstr& path)
	{
		return erase_suffix_w(path).torstr();
	}

	static rstrw get_suffix_w(const rstrw& name)
	{
		ushort ch=r_char('.');
		int pos=name.find_last(ch);
		if(pos<name.count())
		{
			return name.sub(pos+1);
		}
		return rstrw();
	}

	static rstr get_suffix(const rstr& name)
	{
		return get_suffix_w(name).torstr();
	}
	
	static rstrw get_prev_dir_w(rstrw path)
	{
		if(path.empty())
		{
			return rstrw();
		}
		path.pop();
		ushort ch=r_char('/');
		int pos=path.find_last(ch);
		if(pos>=path.count())
		{
			return rstrw();
		}
		return path.sub(0,pos+1);
	}

	static rstr get_prev_dir(const rstr& path)
	{
		return get_prev_dir_w(path).torstr();
	}

	static rstrw get_name_w(const rstrw& path)
	{
		if(path.empty())
		{
			return rstrw();
		}
		ushort ch=r_char('/');
		int pos=path.find_last(ch);
		if(pos>=path.count())
		{
			return rstrw();
		}
		return path.sub(pos+1);
	}

	static rstr get_name(const rstr& path)
	{
		return get_name_w(path).torstr();
	}

	static rstrw get_real_name_w(rstrw name)
	{
		rstrw ret;
		wchar ch=r_char('.');
		int pos=name.m_buf.find_last(ch);
		if(pos<name.count())
		{
			ret=name.sub(0,pos);
		}
		return ret;
	}

	static rstr get_real_name(rstr name)
	{
		return get_real_name_w(name).torstr();
	}

	static rstrw get_exe_name_w()
	{
		rstrw ret;
		rbuf<wchar> buf(c_max_path+1);
		ifn(xf::get_exe_name(buf.begin(),c_max_path))
		{
			return ret;
		}
		ret.set_w(buf.begin());
		return dir_std_w(ret);
	}

	static rstr get_exe_name()
	{
		return get_exe_name_w().torstr();
	}

	static rstrw get_exe_dir_w()
	{
		return get_prev_dir_w(get_exe_name_w());
	}

	static rstr get_exe_dir()
	{
		return get_exe_dir_w().torstr();
	}

	static rstrw get_cur_dir_w()
	{
		rstrw ret;
		rbuf<wchar> buf(c_max_path+1);
		ifn(xf::get_cur_dir(buf.begin(),c_max_path))
		{
			return ret;
		}
		ret.set_w(buf.begin());
		ret=dir_std_w(ret);
		ret+=r_char('/');
		return r_move(ret);
	}

	static rstr get_cur_dir()
	{
		return get_cur_dir_w().torstr();
	}
	
	//非win系统区分大小写
	static rstrw dir_std_w(rstrw s)
	{
		for(ushort* p=s.begin();p!=s.end();++p)
		{
			if(r_char('\\')==*p)
			{
				*p=r_char('/');
			}
		}
		return r_move(s);
	}

	static rstr dir_std(const rstr& s)
	{
		return dir_std_w(s).torstr();
	}

	static rstrw dir_std_rev_w(rstrw s)
	{
		for(ushort* p=s.begin();p!=s.end();++p)
		{
			if(r_char('/')==*p)
			{
				*p=r_char('\\');
			}
		}
		return r_move(s);
	}

	static rstr dir_std_rev(const rstr& s)
	{
		return dir_std_rev_w(s).torstr();
	}

	static rbuf<rstr> get_file_bfs(rstr path)
	{
		rbuf<rstr> ret;
		if(path.count()>4096||0==path.count())//ubuntu's max path len is 4096
		{
			return ret;
		}
		path=dir_std(path);
		if(path.count()>=1&&path.get(path.count()-1)!=r_char('/'))
		{
			path+="/";
		}
		rlist<rstr> queue;
		queue.push(path);
		while(!queue.empty())
		{
			path=queue.pop_front();
			R_WIN32_FIND_DATAW wfd;
			void* handle=xf::FindFirstFileW(
				rcode::utf8_to_utf16(path+"*.*").cstrw_t(),&wfd); 
			if((int)handle==-1)
			{
				continue;
			}
			while(true)
			{
				rstr name;
				int wsize=xf::strlenw((wchar*)(&wfd.cFileName))*2;
				name.set_size(wsize);
				xf::memcpy(name.begin(),&wfd.cFileName,wsize);
				name=rcode::utf16_to_utf8(name);
				name=dir_std(name);
				if("."!=name&&".."!=name)
				{
					if(AND(wfd.dwFileAttributes,
						FILE_ATTRIBUTE_DIRECTORY))
					{
						queue.push(path+name+"/");
						ret.push(path+name+"/");
					}
					else
					{
						ret.push(path+name);
					}
				}
				ifn(xf::FindNextFileW(handle,&wfd))
				{
					break;
				}
			}
			xf::FindClose(handle);
		}
		return ret;
	}
};
﻿#pragma once

#include "../xlib/xfs.h"

struct rf
{
	static void printl(rstr s=rstr())
	{
		print(s+"\n");
	}

	static void print(rstr s=rstr())
	{
		xf::print((char*)(s.cstr()));
	}

	static int cmd_utf8(rstr s)
	{
		return xf::cmd(rcode::utf8_to_gbk(s).cstr_t());
	}

	static int cmd(rstr s)
	{
		return xf::cmd(s.cstr_t());
	}

	static rbuf<rstr> get_param()
	{
		return r_split<rstr>(xf::GetCommandLineA()," ");
	}

	static rbuf<rstr> param_split(rstr s)
	{
		rbuf<rstr> v;
		int j;
		for(int i=0;i<s.count();i++)
		{
			if(s[i]==r_char('\"'))
			{
				j=s.find("\"",i+1);
				v.push(s.sub(i+1,j));
				i=j;
			}
			elif(s[i]==r_char(' '))
			{
				continue;
			}
			else
			{
				for(j=i;j<s.count();j++)
				{
					if(s[j]==r_char(' '))
					{
						break;
					}
				}
				v.push(s.sub(i,j));
				i=j;
			}
		}
		return r_move(v);
	}

	static rbuf<rstr> vstr(const rstr& s1)
	{
		rbuf<rstr> result;
		result+=s1;
		return result;
	}

	static rbuf<rstr> vstr(const rstr& s1,const rstr& s2)
	{
		rbuf<rstr> result;
		result+=s1;
		result+=s2;
		return result;
	}

	static rbuf<rstr> vstr(const rstr& s1,const rstr& s2,
		const rstr& s3)
	{
		rbuf<rstr> result;
		result+=s1;
		result+=s2;
		result+=s3;
		return result;
	}

	static rbuf<rstr> vstr(const rstr& s1,const rstr& s2,
		const rstr& s3,const rstr& s4)
	{
		rbuf<rstr> result;
		result+=s1;
		result+=s2;
		result+=s3;
		result+=s4;
		return result;
	}

	static rbuf<rstr> vstr(const rstr& s1,const rstr& s2,
		const rstr& s3,const rstr& s4,const rstr& s5,const rstr& s6)
	{
		rbuf<rstr> result;
		result+=s1;
		result+=s2;
		result+=s3;
		result+=s4;
		result+=s5;
		result+=s6;
		return result;
	}

	static rbuf<rstr> vstr(const rstr& s1,const rstr& s2,
		const rstr& s3,const rstr& s4,const rstr& s5,const rstr& s6,
		const rstr& s7)
	{
		rbuf<rstr> result;
		result+=s1;
		result+=s2;
		result+=s3;
		result+=s4;
		result+=s5;
		result+=s6;
		result+=s7;
		return result;
	}

	static rbuf<rstr> vstr(const rstr& s1,const rstr& s2,
		const rstr& s3,const rstr& s4,const rstr& s5,const rstr& s6,
		const rstr& s7,const rstr& s8)
	{
		rbuf<rstr> result;
		result+=s1;
		result+=s2;
		result+=s3;
		result+=s4;
		result+=s5;
		result+=s6;
		result+=s7;
		result+=s8;
		return result;
	}

	static rbuf<rstr> vstr(const rstr& s1,
		const rstr& s2,const rstr& s3,const rstr& s4,
		const rstr& s5,const rstr& s6,const rstr& s7,const rstr& s8,
		const rstr& s9,const rstr& s10)
	{
		rbuf<rstr> result;
		result+=s1;
		result+=s2;
		result+=s3;
		result+=s4;
		result+=s5;
		result+=s6;
		result+=s7;
		result+=s8;
		result+=s9;
		result+=s10;
		return result;
	}

	static rbuf<rstr> vstr(const rstr& s1,
		const rstr& s2,const rstr& s3,const rstr& s4,
		const rstr& s5,const rstr& s6,const rstr& s7,const rstr& s8,
		const rstr& s9,const rstr& s10,const rstr& s11,const rstr& s12)
	{
		rbuf<rstr> result;
		result+=s1;
		result+=s2;
		result+=s3;
		result+=s4;
		result+=s5;
		result+=s6;
		result+=s7;
		result+=s8;
		result+=s9;
		result+=s10;
		result+=s11;
		result+=s12;
		return result;
	}
};
﻿#pragma once

#include "rstrw.h"

struct rfile
{
	void* m_fp;
	
	~rfile()
	{
		close();
	}

	rfile()
	{
		m_fp=null;
	}

	rfile(rstr name,rstr mode="r")
	{
		open(name,mode);
	}

	rbool close()
	{
		if(null==m_fp)
		{
			return false;
		}
		if(xf::fclose(m_fp)!=0)
		{
			return false;
		}
		m_fp=null;
		return true;
	}
	
	//mode: rb只读，wb重新创建写,rb+读写
	//推荐用 r只读，w写，rw读写，本函数只有二进制模式
	rbool open(rstr name,rstr mode="r")
	{
		m_fp=null;
		if(!exist(name))
		{
			if("rw"==mode)
			{
				if(!create(name))
				{
					return false;
				}
			}
			else
			{
				return false;
			}
		}
		if("r"==mode)
		{
			mode="rb";
		}
		elif("w"==mode)
		{
			mode="wb";
		}
		elif("rw"==mode)
		{
			mode="rb+";
		}
		m_fp=xfs::fopen(name,mode);
		if(null==m_fp)
		{
			return false;
		}
		return true;
	}

	//强制打开一个新文件
	rbool open_n(rstr name,rstr mode="rw")
	{
		xfs::remove(name);
		return open(name,mode);
	}

	rbool read(int off,int len,void* buf)
	{
		return read((int64)off,len,buf);
	}

	rbool read(int64 off,int len,void* buf)
	{
		if(null==m_fp)
		{
			return false;
		}
		set_off64(off);
		return len==(int)(xf::fread(buf,1,len,m_fp));
	}

	rbool read(int len,void* buf)
	{
		if(null==m_fp)
		{
			return false;
		}
		return len==(int)(xf::fread(buf,1,len,m_fp));
	}
	
	//读取并返回整个文件，通常用于小文件
	rstr read_all()
	{
		rstr ret;
		ret.set_size(size());
		if(!read(0,size(),ret.begin()))
		{
			return rstr();
		}
		return r_move(ret);
	}

	//直接读一个小文件
	static rstr read_all_n(const rstr& name)
	{
		rfile file(name);
		rstr ret;
		ret.set_size(file.size());
		if(!file.read(0,file.size(),ret.begin()))
		{
			return rstr();
		}
		return r_move(ret);
	}
	
	//读取一行（跳过空行）
	rstr read_line()
	{
		rstr ret;
		uchar c;
		while(read(1,&c))
		{
			if(r_char('\r')==c||r_char('\n')==c)
			{
				if(0==ret.count())
				{
					continue;
				}
				else
				{
					return ret;
				}
			}
			ret+=c;
		}
		return r_move(ret);
	}
	
	//读取一行，仅用于utf16文件
	rstrw read_line_w()
	{
		rstrw ret;
		ushort c;
		while(read(2,&c))
		{
			if(r_char('\r')==c||r_char('\n')==c)
			{
				if(0==ret.count())
				{
					continue;
				}
				else
				{
					return ret;
				}
			}
			ret+=c;
		}
		return r_move(ret);
	}

	rbool write(int off,int len,const void* buf)
	{
		return write((int64)off,len,buf);
	}

	rbool write(int64 off,int len,const void* buf)
	{
		if(null==m_fp)
		{
			return false;
		}
		set_off64(off);
		return len==(int)(xf::fwrite(buf,1,len,m_fp));
	}

	rbool write(int len,const void* buf)
	{
		if(null==m_fp)
		{
			return false;
		}
		return len==(int)(xf::fwrite(buf,1,len,m_fp));
	}

	rbool write(rstr s)
	{
		return write(s.size(),s.begin());
	}

	rbool write_line(rstr s)
	{
		return write(s.size(),s.begin())&&write(1,"\n");
	}

	rbool write_line_w(rstrw s)
	{
		return write(s.size(),s.begin())&&write(2,rstrw("\n").cstrw_t());
	}

	static rbool write_all_n(const rstr& name,const rstr& cont)
	{
		rfile file;
		ifn(file.open_n(name))
		{
			return false;
		}
		return file.write(cont);
	}

	int size()
	{
		return (int)(size64());
	}

	int64 size64()
	{
		if(null==m_fp)
		{
			return 0;//返回-1和返回0各有利弊
		}
		int64 cur=get_off64();
		xf::fseek64(m_fp,0,xf::X_SEEK_END);
		int64 ret=get_off64();
		set_off64(cur);
		return ret;
	}

	int get_off()
	{
		return (int)(get_off64());
	}

	int64 get_off64()
	{
		if(null==m_fp)
		{
			return 0;
		}
		return xf::ftell64(m_fp);
	}

	rbool set_off(int off)
	{
		return set_off64((int64)off);
	}

	rbool set_off64(int64 off)
	{
		return 0==xf::fseek64(m_fp,off,xf::X_SEEK_SET);
	}

	static rbool exist(rstr name)
	{
		void* fp=xfs::fopen(name,"rb");
		if(null==fp)
		{
			return false;
		}
		xf::fclose(fp);
		return true;
	}

	//强制创建文件
	static rbool create(rstr name,int64 size=0)
	{
		void* fp=xfs::fopen(name,"wb");
		if(null==fp)
		{
			return false;
		}
		xf::fclose(fp);
		if(size>0)
		{
			rfile file(name);
			file.set_off64(size-1);
			if(!file.write(1,"\0"))
			{
				return false;
			}
			return file.close();
		}
		return true;
	}

	static int64 get_size64(rstr name)
	{
		rfile file(name);
		return file.size64();
	}

	static int remove(rstr name)
	{
		return xfs::remove(name);
	}
};
﻿#pragma once

#include "rstr.h"

template<typename T>
struct rhash_i
{
	T val;
	rstr name;
	rhash_i<T>* pre;
	rhash_i<T>* next;
};

template<typename T>
struct rhash
{
	rbuf<rhash_i<T>*> m_hash;
	int m_count;

	~rhash<T>()
	{
		clear();
	}

	rhash<T>()
	{
		init();
	}

	rhash<T>(rhash<T>& a)
	{
		init();
		for(T* p=a.begin();p!=a.end();p=a.next(p))
		{
			insert(*p);
		}
	}

	void operator=(rhash<T>& a)
	{
		clear();
		for(T* p=a.begin();p!=a.end();p=a.next(p))
		{
			insert(*p);
		}
	}

	T& operator[](const rstr& name)
	{
		T* p=(T*)(find(name));
		if(p!=null)
		{
			return *p;
		}
		//找不到则插入一个空值
		T a;
		insert(a,name);
		p=(T*)(find(name));
		return *p;
	}

	void init()
	{
		//两个字节消耗256K内存，如果用3个字节需要64M内存
		m_hash.realloc_n(65536);
		for(int i=0;i<m_hash.count();i++)
		{
			m_hash[i]=null;
		}
		m_count=0;
	}

	void clear()
	{
		if(m_count==0)
		{
			return;
		}
		for(int i=0;i<m_hash.count();i++)
		{
			if(m_hash[i]!=null)
			{
				rhash_i<T>* p=m_hash[i];
				while(p!=null)
				{
					rhash_i<T>* temp=p;
					p=p->next;
					r_delete<rhash_i<T> >(temp);
				}
			}
		}
		init();
	}

	rbool exist(const rstr& name) const
	{
		return find(name)!=null;
	}

	T* find(const rstr& name) const
	{
		int addr=get_addr(name);
		rhash_i<T>* p=m_hash[addr];
		while(p!=null)
		{
			if(p->name==name)
			{
				return (T*)p;
			}
			p=p->next;
		}
		return null;
	}
	
	//如果重复则不插入
	void insert_c(T& a,rstr name=rstr())
	{
		if(exist(name))
		{
			return;
		}
		insert(a,name);
	}

	void insert(T& a,rstr name=rstr())
	{
		int addr=get_addr(name);
		rhash_i<T>* p=r_new<rhash_i<T> >();
		p->name=name;
		p->next=m_hash[addr];
		p->pre=null;
		p->val=a;
		if(m_hash[addr]!=null)
		{
			m_hash[addr]->pre=p;
		}
		m_hash[addr]=p;
		m_count++;
	}

	rbool erase(rstr name=rstr())
	{
		rhash_i<T>* p=(rhash_i<T>*)(find(name));
		if(p==null)
		{
			return false;
		}
		if(p->pre!=null)
		{
			p->pre->next=p->next;
			if(p->next!=null)
			{
				p->next->pre=p->pre;
			}
		}
		else
		{
			m_hash[get_addr(name)]=p->next;
			if(p->next!=null)
			{
				p->next->pre=null;
			}
		}
		r_delete<rhash_i<T> >(p);
		m_count--;
		return true;
	}

	T* begin() const
	{
		for(int i=0;i<m_hash.count();i++)
		{
			if(m_hash[i]!=null)
			{
				return (T*)(m_hash[i]);
			}
		}
		return null;
	}

	T* rend() const
	{
		for(int i=m_hash.count()-1;i>=0;i--)
		{
			if(m_hash[i]!=null)
			{
				rhash_i<T>* p=m_hash[i];
				while(p!=null&&p->next!=null)
				{
					p=p->next;
				}
				return (T*)p;
			}
		}
		return null;
	}
	
	//这个next有点慢，能不能把一个桶的最后一个元素的next指向下一个桶？
	T* next(T* cur) const
	{
		rhash_i<T>* p=(rhash_i<T>*)cur;
		if(p->next!=null)
		{
			return (T*)(p->next);
		}
		int addr=get_addr(p->name);
		for(int i=addr+1;i<m_hash.count();i++)
		{
			if(m_hash[i]!=null)
			{
				return (T*)(m_hash[i]);
			}
		}
		return null;
	}

	static int get_addr(const rstr& name)
	{
		return (int)(bkdr_hash16(name.begin(),name.count()));
	}

	static int bkdr_hash32(const void* data,int len)
	{
		uint seed=131; // 31 131 1313 13131 131313 etc..
		uint hash=0;
		for(int i=0;i<len;++i)
		{
			hash=(hash*seed)+((const uchar*)data)[i];
		}
		return (int)hash;
	}

	static ushort bkdr_hash16(const void* data,int len)
	{
		int val=bkdr_hash32(data,len);
		return (ushort)(val%65536);
	}
};
﻿#pragma once

#include "ralgo.h"

template<typename T>
struct rlist_i
{
	T val;
	rlist_i<T>* prev;
	rlist_i<T>* next;
};

template<typename T>
struct rlist
{
	rlist_i<T>* m_front;
	rlist_i<T>* m_rear;
	int m_count;

	~rlist<T>()
	{
		clear();
	}

	rlist<T>()
	{
		init();
	}

	rlist<T>(rlist<T>& a)
	{
		init();
		for(T* p=a.begin();p!=a.end();p=a.next(p))
		{
			this->push(*p);
		}
	}

	void operator=(rlist<T>& a)
	{
		clear();
		for(T* p=a.begin();p!=a.end();p=a.next(p))
		{
			this->push(*p);
		}
	}

	void init()
	{
		m_front=null;
		m_rear=null;
		m_count=0;
	}

	void clear()
	{
		while(m_front!=null)
		{
			m_rear=m_front->next;
			r_delete<rlist_i<T> >(m_front);
			m_front=m_rear;
		}
		init();
	}

	rbool empty() const
	{
		return m_count==0;
	}

	int count() const
	{
		return m_count;
	}

	T& top() const
	{
		return *(T*)m_rear;
	}

	void push(const T& a)
	{
		rlist_i<T>* p=r_new<rlist_i<T> >();
		p->val=a;
		p->next=null;
		p->prev=m_rear;
		if(empty())
		{
			m_front=p;
			m_rear=p;
		}
		else
		{
			m_rear->next=p;
			m_rear=p;
		}
		m_count++;
	}

	T pop()
	{
		m_count--;
		rlist_i<T>* p=m_rear;
		T ret=p->val;
		m_rear=p->prev;
		if(m_rear!=null)
		{
			m_rear->next=null;
		}
		if(empty())
		{
			m_front=null;
		}
		r_delete<rlist_i<T> >(p);
		return ret;
	}

	void push_front(const T& a)
	{
		rlist_i<T>* p=r_new<rlist_i<T> >();
		p->val=a;
		p->next=m_front;
		p->prev=null;
		if(empty())
		{
			m_front=p;
			m_rear=p;
		}
		else
		{
			m_front->prev=p;
			m_front=p;
		}
		m_count++;
	}

	T pop_front()
	{
		m_count--;
		rlist_i<T>* p=m_front;
		T ret=p->val;
		m_front=p->next;
		if(m_front!=null)
		{
			m_front->prev=null;
		}
		if(empty())
		{
			m_rear=null;
		}
		r_delete<rlist_i<T> >(p);
		return ret;
	}
	
	//前插
	void insert(T* pos,const T& a)
	{
		if(pos==null)
		{
			push(a);
			return;
		}
		rlist_i<T>* cur=(rlist_i<T>*)pos;
		rlist_i<T>* p=r_new<rlist_i<T> >();
		p->val=a;
		p->next=cur;
		p->prev=cur->prev;
		if(cur->prev!=null)
		{
			cur->prev->next=p;
		}
		cur->prev=p;
		if(p->prev==null)
		{
			m_front=p;
		}
		if(p->next==null)
		{
			m_rear=p;
		}
		m_count++;
	}

	void insert(int pos,const T& a)
	{
		insert(index(pos),a);
	}

	void erase(T* pos)
	{
		if(pos==null)
		{
			return;
		}
		rlist_i<T>* cur=(rlist_i<T>*)pos;
		if(cur->prev==null)
		{
			m_front=cur->next;
		}
		if(cur->next==null)
		{
			m_rear=cur->prev;
		}
		if(cur->prev!=null)
		{
			cur->prev->next=cur->next;
		}
		if(cur->next!=null)
		{
			cur->next->prev=cur->prev;
		}
		r_delete<rlist_i<T> >(cur);
		m_count--;
	}

	void erase(int pos)
	{
		erase(index(pos));
	}

	T* index(int n) const
	{
		rlist_i<T>* p=m_front;
		for(;n;n--)
		{
			if(p==null)
			{
				return null;
			}
			p=p->next;
		}
		return (T*)p;
	}

	T& operator[](int n) const
	{
		T* p=index(n);
		return *p;
	}

	T* begin() const
	{
		return (T*)m_front;
	}

	static T* end()
	{
		return null;
	}

	T* next(void* p) const
	{
		return (T*)(((rlist_i<T>*)p)->next);
	}

	T* prev(void* p) const
	{
		return (T*)(((rlist_i<T>*)p)->prev);
	}
};
﻿#pragma once

#include "../xlib/xf.h"

struct rmutex
{
	R_CRITICAL_SECTION m_mutex;

	rmutex()
	{
		xf::InitializeCriticalSection(&m_mutex);
	}

	~rmutex()
	{
		xf::DeleteCriticalSection(&m_mutex);
	}

	void enter()
	{
		xf::EnterCriticalSection(&m_mutex);
	}

	void leave()
	{
		xf::LeaveCriticalSection(&m_mutex);
	}
};

//用于整个函数的局部临时mutex
struct rmutex_t
{
	rmutex* m_p;

	rmutex_t()
	{
		m_p=null;
	}

	rmutex_t(rmutex& m)
	{
		m_p=&m;
		m_p->enter();
	}

	~rmutex_t()
	{
		if(m_p!=null)
		{
			m_p->leave();
		}
	}
};
﻿#pragma once

#include "../xlib/xf.h"

template<typename T>
T* r_new(int count=1)
{
	T* p=(T*)(xf::malloc(r_size(int)+count*r_size(T)));
	if(p==null)
	{
		xf::print("memory insufficient");
		xf::exit(1);
		return null;
	}
	*(int*)p=count;
	p=(T*)((uchar*)p+r_size(int));
	T* start=p;
	T* end=start+count;
	for(;p<end;p++)
	{
#ifndef _RS
		new(p)T();//((T*)p)->T::T();
#else
		p->T();
#endif
	}
	return start;
}

template<typename T>
T* r_new_n(int count=1)
{
	T* p=(T*)(xf::malloc(r_size(int)+count*r_size(T)));
	if(p==null)
	{
		xf::print("memory insufficient");
		xf::exit(1);
		return null;
	}
	*(int*)p=count;
	return (T*)((uchar*)p+r_size(int));
}

template<typename T>
void r_delete(T* p)
{
	uchar* start=(uchar*)p-r_size(int);
	T* end=p+*(int*)start;
	for(;p<end;p++)
	{
#ifndef _RS
		p->~T();
#else
		T.~T(*p);
#endif
	}
	xf::free(start);
}

template<typename T>
void r_delete_n(T* p)//这里模板参数没用
{
	xf::free((uchar*)p-r_size(int));
}

//模板特化放在头文件里只能包含一次
//如果注释掉这4个特化int、char等内置类型会初始化为0，效率略低
template<>
uchar* r_new<uchar>(int count)
{
	return r_new_n<uchar>(count);
}

template<>
void r_delete<uchar>(uchar* p)
{
	r_delete_n<uchar>(p);
}

template<>
ushort* r_new<ushort>(int count)
{
	return r_new_n<ushort>(count);
}

template<>
void r_delete<ushort>(ushort* p)
{
	r_delete_n<ushort>(p);
}
﻿#pragma once

template<typename TA,typename TB>
struct rpair
{
	TA first;
	TB second;

	friend rbool operator<(rpair<TA,TB>& a,rpair<TA,TB>& b)
	{
		return a.first<b.first;
	}
};
﻿#pragma once

#include "ralgo.h"

template<typename T>
struct rset_i
{
	T key;
	rset_i<T>* father;
	rset_i<T>* left;
	rset_i<T>* right;
	int col;
};

template<typename T>
struct rset
{
	rset_i<T>* m_root;
	rset_i<T>* m_nil;//todo:m_nil可用null代替?
	int m_count;

	enum
	{
		c_black,
		c_red,
	};

	~rset<T>()
	{
		clear_x(m_root);
		r_delete<rset_i<T> >(m_nil);
	}

	rset<T>()
	{
		m_nil=r_new<rset_i<T> >(1);
		init();
	}

	rset<T>(const rset<T>& a)
	{
		m_nil=r_new<rset_i<T> >(1);
		init();
		//用递归拷贝更快
		copy_x(a.m_nil,a.m_root);
	}

	void operator=(const rset<T>& a)
	{
		clear();
		copy_x(a.m_nil,a.m_root);
	}

	void copy_x(const rset_i<T>* xnil,const rset_i<T>* x)
	{
		if(x!=xnil)
		{
			copy_x(xnil,x->left);
			copy_x(xnil,x->right);
			insert(x->key);
		}
	}
	
	void copy_all(const rset<T>& a)
	{
		for(T* p=a.begin();p!=a.end();p=a.next(p))
		{
			insert(*p);
		}
	}

	void init()
	{
		m_nil->father=m_nil;
		m_nil->left=m_nil;
		m_nil->right=m_nil;
		m_nil->col=c_black;

		m_root=m_nil;
		m_count=0;
	}

	void clear()
	{
		clear_x(m_root);
		init();
	}

	void clear_x(rset_i<T>* x)
	{
		if(x!=m_nil)
		{
			clear_x(x->left);
			clear_x(x->right);
			r_delete<rset_i<T> >(x);
		}
	}

	rbool empty() const
	{
		return m_count==0;
	}

	int count() const
	{
		return m_count;
	}

	void left_rotate(rset_i<T>* x)
	{
		rset_i<T>* y;
		if(x->right==m_nil)
		{
			return;
		}
		y=x->right;
		x->right=y->left;
		if(y->left!=m_nil)
		{
			y->left->father=x;
		}
		y->father=x->father;
		if(x->father==m_nil)
		{
			m_root=y;
		}
		elif(x->father->left==x)
		{
			x->father->left=y;
		}
		else
		{
			x->father->right=y;
		}
		y->left=x;
		x->father=y;
	}

	void right_rotate(rset_i<T>* x)
	{
		rset_i<T>* y;
		if(x->left==m_nil)
		{
			return;
		}
		y=x->left;
		x->left=y->right;
		if(y->right!=m_nil)
		{
			y->right->father=x;
		}
		y->father=x->father;
		if(x->father==m_nil)
		{
			m_root=y;
		}
		elif(x->father->left==x)
		{
			x->father->left=y;
		}
		else
		{
			x->father->right=y;
		}
		y->right=x;
		x->father=y;
	}

	//重复代码需简化
	void insert_fixup(rset_i<T>* z)
	{
		rset_i<T>* y;
		while(z->father->col==c_red) 
		{ 
			if(z->father==z->father->father->left) 
			{ 
				y=z->father->father->right; 
				if(y->col==c_red) 
				{ 
					z->father->col=c_black; 
					y->col=c_black; 
					z->father->father->col=c_red; 
					z=z->father->father; 
				} 
				else 
				{
					if(z==z->father->right) 
					{ 
						z=z->father; 
						left_rotate(z); 
					} 
					z->father->col=c_black; 
					z->father->father->col=c_red; 
					right_rotate(z->father->father); 
				}
			} 
			else 
			{ 
				y=z->father->father->left; 
				if(y->col==c_red) 
				{ 
					z->father->col=c_black; 
					y->col=c_black; 
					z->father->father->col=c_red; 
					z=z->father->father; 
				} 
				else 
				{
					if(z==z->father->left) 
					{ 
						z=z->father; 
						right_rotate(z); 
					} 
					z->father->col=c_black; 
					z->father->father->col=c_red; 
					left_rotate(z->father->father);
				}
			} 
		} 
		m_root->col=c_black; 
	}

	void insert_p(rset_i<T>* z)
	{
		rset_i<T>* y=m_nil;
		rset_i<T>* x=m_root;
		while(x!=m_nil)
		{
			y=x;
			if(z->key<x->key)
			{
				x=x->left;
			}
			else
			{
				x=x->right;
			}
		}
		z->father=y;
		if(y==m_nil)
		{
			m_root=z;
		}
		elif(z->key<y->key)
		{
			y->left=z;
		}
		else
		{
			y->right=z;
		}
		z->left=m_nil;
		z->right=m_nil;
		z->col=c_red;
		insert_fixup(z);
	}

	void insert(const T& a)
	{
		rset_i<T>* p=r_new<rset_i<T> >();
		p->key=a;
		insert_p(p);
		m_count++;
	}

	void insert_c(const T& a)
	{
		if(exist(a))
		{
			return;
		}
		insert(a);
	}

	void erase_fixup(rset_i<T>* x)
	{
		rset_i<T>* w;
		while(x!=m_root&&x->col==c_black)
		{
			if(x==x->father->left)
			{
				w=x->father->right;
				if(w->col==c_red)
				{
					w->col=c_black;
					x->father->col=c_red;
					left_rotate(x->father);
					w=x->father->right;
				}
				if(w->left->col==c_black&&w->right->col==c_black)
				{
					w->col=c_red;
					x=x->father;
				}
				else 
				{
					if(w->right->col==c_black)
					{
						w->left->col=c_black;
						w->col=c_red;
						right_rotate(w);
						w=x->father->right;
					}
					w->col=x->father->col;
					x->father->col=c_black;
					w->right->col=c_black;
					left_rotate(x->father);
					x=m_root;
				}
			}
			else
			{
				w=x->father->left;
				if(w->col==c_red)
				{
					w->col=c_black;
					x->father->col=c_red;
					right_rotate(x->father);
					w=x->father->left;
				}
				if(w->right->col==c_black&&w->left->col==c_black)
				{
					w->col=c_red;
					x=x->father;
				}
				else
				{
					if(w->left->col==c_black)
					{
						w->right->col=c_black;
						w->col=c_red;
						left_rotate(w);
						w=x->father->left;
					}
					w->col=x->father->col;
					x->father->col=c_black;
					w->left->col=c_black;
					right_rotate(x->father);
					x=m_root;
				}
			}
		}
		x->col=c_black;
	}

	void transplant(rset_i<T>* u,rset_i<T>* v)
	{
		if(u->father==m_nil)
		{
			m_root=v;
		}
		elif(u==u->father->left)
		{
			u->father->left=v;
		}
		else
		{
			u->father->right=v;
		}
		v->father=u->father;
	}

	void erase_p(rset_i<T>* z)
	{
		rset_i<T>* y=z;
		rset_i<T>* x;
		int y_original_col=y->col;
		if(z->left==m_nil)
		{
			x=z->right;
			transplant(z,z->right);
		}
		elif(z->right==m_nil)
		{
			x=z->left;
			transplant(z,z->left);
		}
		else
		{
			y=minimum(z->right);
			y_original_col=y->col;
			x=y->right;
			if(y->father==z)
			{
				x->father=y;
			}
			else
			{
				transplant(y,y->right);
				y->right=z->right;
				y->right->father=y;
			}
			transplant(z,y);
			y->left=z->left;
			y->left->father=y;
			y->col=z->col;
		}
		if(y_original_col==c_black)
		{
			erase_fixup(x);
		}
	}

	void erase(const T& a)
	{
		rset_i<T>* x=search(m_root,a);
		if(x!=m_nil)
		{
			erase_p(x);
			r_delete<rset_i<T> >(x);
			m_count--;
		}
	}

	bool exist(const T& a) const
	{
		return search(m_root,a)!=m_nil;
	}

	rset_i<T>* successor(const rset_i<T>* x) const
	{
		rset_i<T>* y;
		if(x->right!=m_nil)
		{
			return minimum(x->right);
		}
		y=x->father;
		while(y!=m_nil&&x==y->right)
		{
			x=y;
			y=y->father;
		}
		return y;
	}

	rset_i<T>* predecessor(const rset_i<T>* x) const
	{
		rset_i<T>* y;
		if(x->left!=m_nil)
		{
			return maximum(x->left);
		}
		y=x->father;
		while(y!=m_nil&&x==y->left)
		{
			x=y;
			y=y->father;
		}
		return y;
	}

	rset_i<T>* minimum(const rset_i<T>* x) const
	{
		while(x->left!=m_nil)
		{
			x=x->left;
		}
		return (rset_i<T>*)x;
	}

	rset_i<T>* maximum(const rset_i<T>* x) const
	{
		while(x->right!=m_nil)
		{
			x=x->right;
		}
		return x;
	}

	rset_i<T>* search(const rset_i<T>* x,const T& a) const
	{
		while(x!=m_nil&&r_not_equal<T>(a,x->key))
		{
			if(a<x->key)
			{
				x=x->left;
			}
			else
			{
				x=x->right;
			}
		}
		return (rset_i<T>*)x;
	}

	T* find(const T& a) const
	{
		rset_i<T>* x=search(m_root,a);
		if(x==m_nil)
		{
			return null;
		}
		return (T*)x;
	}

	T* next(const void* p) const
	{
		rset_i<T>* x=successor((rset_i<T>*)p);
		if(x==m_nil)
		{
			return null;
		}
		return (T*)x;
	}
	
	T* prev(const void* p) const
	{
		rset_i<T>* x=predecessor((rset_i<T>*)p);
		if(x==m_nil)
		{
			return null;
		}
		return (T*)x;
	}

	T* begin() const
	{
		rset_i<T>* x=minimum(m_root);
		if(x==m_nil)
		{
			return null;
		}
		return (T*)x;
	}

	static T* end()
	{
		return null;
	}

	T* index(int n) const
	{
		T* p=begin();
		for(;n;n--)
		{
			if(p==null)
			{
				return null;
			}
			p=next(p);
		}
		return p;
	}

	T& operator[](int n) const
	{
		return *index(n);
	}
};
﻿#pragma once

#include "ralgo.h"

struct rstr
{
	rbuf<uchar> m_buf;

	~rstr()
	{
	}

	rstr()
	{
	}

#ifndef _RS
	rstr(const void* p)
	{
		set(p);
	}
#else
	rstr(const char* p)
	{
		set(p);
	}
#endif

	rstr(void* p,int len)
	{
		m_buf.alloc(len);
		xf::memcpy(begin(),p,len);
	}

	rstr(const void* p,const void* q)
	{
		int len=(int)((uchar*)q-(uchar*)p);
		m_buf.alloc(len);
		xf::memcpy(begin(),p,len);
	}

	rstr(int i)
	{
#ifndef _RS
		char tmp[32];
		xf::itoa(tmp,i);
		set(tmp);
#else
		rbuf<char> tmp(32);
		xf::itoa(tmp.begin(),i);
		set(tmp.begin());
#endif
	}

	rstr(uint i)
	{
#ifndef _RS
		char tmp[32];
		xf::utoa(tmp,i);
		set(tmp);
#else
		rbuf<char> tmp(32);
		xf::utoa(tmp.begin(),i);
		set(tmp.begin());
#endif
	}

	rstr(double i)
	{
#ifndef _RS
		char tmp[128];
		xf::dtoa(tmp,i);
		set(tmp);
#else
		rbuf<char> tmp(128);
		xf::dtoa(tmp.begin(),i);
		set(tmp.begin());
#endif
	}

	rstr(int64 i)
	{
#ifndef _RS
		char tmp[128];
		xf::int64toa(tmp,i);
		set(tmp);
#else
		rbuf<char> tmp(128);
		xf::int64toa(tmp.begin(),i);
		set(tmp.begin());
#endif
	}

	rstr(const rstr& s)
	{
		m_buf.alloc_not_change(s.m_buf.m_max);
		m_buf.m_count=s.count();
		xf::memcpy(begin(),s.begin(),s.count());
	}

	rstr(rstr&& s)
	{
		m_buf.move(s.m_buf);
	}

	//todo: 改为const
	int toint()
	{
		return xf::atoi(cstr_t());
	}

	uint touint()
	{
		return xf::atou(cstr_t());
	}

	double todouble()
	{
		return xf::atod(cstr_t());
	}

	int64 toint64()
	{
		int64 result;
		xf::atoint64(cstr_t(),&result);
		return result;
	}

	rstr torstr() const
	{
		return *this;
	}

	uchar* cstr()
	{
		this->push((uchar)0);//todo:
		this->pop();
		return begin();
	}

	char* cstr_t()
	{
		return (char*)cstr();
	}

	ushort* cstrw()
	{
		this->push((uchar)0);
		this->push((uchar)0);
		this->pop();
		this->pop();
		return (ushort*)begin();
	}

	wchar* cstrw_t()
	{
		return (wchar*)cstrw();
	}
	
	//赋值函数千万不要让编译器自动生成
	void operator=(const rstr& s)
	{
		m_buf.realloc_n_not_change(s.m_buf.m_max);
		m_buf.m_count=s.count();
		xf::memcpy(begin(),s.begin(),s.count());
		//m_buf=a.m_buf;
	}

	void operator=(rstr&& s)
	{
		m_buf.free();
		m_buf.move(s.m_buf);
	}

	uchar& operator[](int num) const 
	{
		return m_buf[num];
	}

	friend rbool operator==(const rstr& a,const rstr& b)
	{
		return a.m_buf==b.m_buf;
	}

	friend rbool operator!=(const rstr& a,const rstr& b)
	{
		return a.m_buf!=b.m_buf;
	}

	//有待优化
	friend rstr operator+(const rstr& a,const rstr& b)
	{
		int total=a.count()+b.count();
		int max=r_max(a.m_buf.m_max,b.m_buf.m_max);
		rstr ret;
		if(total>max)
		{
			ret.m_buf.alloc_not_change(rbuf<char>::extend_num(total));
		}
		else
		{
			ret.m_buf.alloc_not_change(max);
		}
		ret.m_buf.m_count=total;
		xf::memcpy(ret.begin(),a.begin(),a.m_buf.m_count);
		xf::memcpy(ret.begin()+a.m_buf.m_count,b.begin(),b.m_buf.m_count);
		return r_move(ret);
		//rstr ret;
		//ret.m_buf=a.m_buf+b.m_buf;
		//return ret;
	}

	void operator+=(const rstr& a)
	{
		m_buf+=a.m_buf;
	}

	void operator+=(rstr&& a)
	{
		m_buf+=r_move(a.m_buf);
	}

	void operator+=(uchar ch)
	{
		m_buf+=ch;
	}

	friend rbool operator<(const rstr& a,const rstr& b)
	{
		for(int i=0;i<a.count()&&i<b.count();i++)
		{
			if(a[i]!=b[i])
			{
				return a[i]<b[i];
			}
		}
		return a.count()<b.count();
	}

	friend rbool operator>(const rstr& a,const rstr& b)
	{
		return b<a;
	}

	friend rbool operator<=(const rstr& a,const rstr& b)
	{
		return !(a>b);
		//return a<b||a==b;
	}

	friend rbool operator>=(const rstr& a,const rstr& b)
	{
		return !(a<b);
		//return a>b||a==b;
	}

	uchar* set_size(int size)
	{
		m_buf.realloc_n(size);
		return begin();
	}

	void set(const void* p)
	{
		//todo:如果字符串长度为0没必要分配内存
		int len=xf::strlen((const char*)p);
		m_buf.realloc_n_not_change(rbuf<uchar>::extend_num(len));
		m_buf.m_count=len;
		xf::memcpy(m_buf.begin(),p,len);
	}

	void push(uchar ch)
	{
		m_buf.push(ch);
	}

	void push_front(uchar ch)
	{
		m_buf.push_front(ch);
	}

	uchar pop()
	{
		return m_buf.pop();
	}

	uchar pop_front()
	{
		return m_buf.pop_front();
	}

	int count() const 
	{
		return m_buf.count();
	}

	int size() const
	{
		return count();
	}

	uchar* begin() const 
	{
		return m_buf.begin();
	}

	uchar* end() const 
	{
		return m_buf.end();
	}

	rbool empty() const 
	{
		return m_buf.empty();
	}

	void clear()
	{
		m_buf.clear();
	}

	static uchar* next(void* p)
	{
		return ((uchar*)p)+1;
	}

	static uchar* prev(void* p)
	{
		return ((uchar*)p)-1;
	}

	uchar* pos(int num) const
	{
		return begin()+num;
	}

	int pos(void* p) const
	{
		return int((uchar*)p-begin());
	}

	rstr sub_trim(int num) const
	{
		return sub(0,count()-num);
	}

	rstr sub(int begin) const
	{
		return sub(begin,count());
	}

	rstr sub(int begin,int end) const
	{
		rstr ret;
		ret.m_buf=m_buf.sub(begin,end);
		return r_move(ret);
	}

	rbool erase(int begin,int end)
	{
		return m_buf.erase(begin,end);
	}

	rbool erase(int i)
	{
		return erase(i,i+1);
	}

	rbool insert(int pos,const rstr& a)
	{
		return m_buf.insert(pos,a.m_buf);
	}

	uchar get(int i) const
	{
		if(i>=count())
		{
			return (uchar)0;
		}
		else
		{
			return m_buf[i];
		}
	}

	uchar get_top() const
	{
		if(count()>0)
		{
			return m_buf.m_p[count()-1];
		}
		return (uchar)0;
	}

	uchar get_bottom() const
	{
		if(count()>0)
		{
			return m_buf.m_p[0];
		}
		return (uchar)0;
	}

	uchar get_left() const
	{
		return get_bottom();
	}

	uchar get_right() const
	{
		return get_top();
	}

	rbool is_number() const
	{
		if(empty())
		{
			return false;
		}
		for(int i=0;i<count();i++)
		{
			if(!is_number(m_buf[i]))
			{
				return false;
			}
		}
		return true;
	}

	int find(const rstr& s,int begin=0) const
	{
		return r_find<rstr>(*this,s,begin);
	}

	int find_last(uchar ch) const
	{
		return m_buf.find_last(ch);
	}

	rbool exist(const rstr& s) const
	{
		return find(s)<count();
	}

	static rbool is_alpha(uchar ch)
	{
		return (ch>=r_char('a')&&ch<=r_char('z')||
			ch>=r_char('A')&&ch<=r_char('Z'));
	}

	static rbool is_number(uchar ch)
	{
		return ch>=r_char('0')&&ch<=r_char('9');
	}

	static uchar chartoup(uchar ch)
	{
		return r_cond(ch>=r_char('a')&&ch<=r_char('z'),ch-32,ch);
	}

	static int upchartonum(uchar ch)
	{
		return r_cond(ch>=r_char('A'),ch-r_char('A')+10,ch-r_char('0'));
	}

	static int chartonum(uchar ch)
	{
		return upchartonum(chartoup(ch));
	}

	static rstr hextodec(rstr s)
	{
		uint a;
		xf::sscanf(s.cstr_t(),"%x",&a);
		return rstr(a);
	}

	static rstr bintodec(rstr s)
	{
		uint sum=0;
		uint pro=1;
		for(int i=s.count()-1;i>=0;i--)
		{
			if(s[i]==r_char('1'))
			{
				sum+=pro;
			}
			pro*=2;
		}
		return rstr(sum);
	}

	template<typename T>
	static rstr join(const rbuf<T>& v,const rstr& s)
	{
		rstr ret;
		for(int i=0;i<v.count();i++)
		{
			if(i!=0)
			{
				ret+=s;
			}
			ret+=v[i].torstr();
		}
		return r_move(ret);
	}

	void print()
	{
		xf::print(cstr_t());
	}

	void printl()
	{
		xf::print((*this+"\n").cstr_t());
	}

#ifndef _RS
	static rstr format(const char* f,...)
	{
		char buf[1024];
		va_list arg_list;
		va_start(arg_list,f);
		xf::vsnprintf(buf,r_size(buf),f,(char*)arg_list);
		va_end(arg_list);
		return rstr(buf);
	}
#else
	static rstr format(const char* f,int a)
	{
		rbuf<char> buf(1024);
		xf::vsnprintf(buf.begin(),buf.count(),f,(char*)(&a));
		return rstr(buf.begin());
	}

	rstrw torstrw()
	{
		return rstrw(*this);
	}
#endif
};
﻿#pragma once

#include "rcode.h"

struct rstrw
{
	rbuf<ushort> m_buf;

	~rstrw()
	{
	}

	rstrw()
	{
	}

	rstrw(const rstrw& s)
	{
		m_buf.alloc_not_change(s.m_buf.m_max);
		m_buf.m_count=s.count();
		xf::memcpy(begin(),s.begin(),s.size());
	}

	rstrw(const char* p)
	{
		rstr tmp=rcode::utf8_to_utf16(rstr(p));//todo:
		set_size(tmp.size());
		xf::memcpy(begin(),tmp.begin(),tmp.size());
	}

	rstrw(const rstr& s)
	{
		rstr tmp=rcode::utf8_to_utf16(s);
		set_size(tmp.size());
		xf::memcpy(begin(),tmp.begin(),tmp.size());
	}

	rstrw(rstrw&& s)
	{
		m_buf.move(s.m_buf);
	}

	rstr torstr() const
	{
		return rcode::utf16_to_utf8(rstr((char*)begin(),size()));
	}

	int toint()
	{
		return this->torstr().toint();
	}

	ushort* cstrw()
	{
		this->push((ushort)0);
		this->pop();
		return begin();
	}

	wchar* cstrw_t()
	{
		return (wchar*)(cstrw());
	}

	void operator=(const rstrw& a)
	{
		m_buf=a.m_buf;
	}

	void operator=(rstrw&& a)
	{
		m_buf.free();
		m_buf.move(a.m_buf);
	}

	ushort& operator[](int num) const 
	{
		return m_buf[num];
	}

	friend rbool operator==(const rstrw& a,const rstrw& b)
	{
		return a.m_buf==b.m_buf;
	}

	friend rbool operator!=(const rstrw& a,const rstrw& b)
	{
		return a.m_buf!=b.m_buf;
	}

	friend rstrw operator+(const rstrw& a,const rstrw& b)
	{
		rstrw ret;
		ret.m_buf=a.m_buf+b.m_buf;
		return r_move(ret);
	}

	void operator+=(const rstrw& a)
	{
		m_buf+=a.m_buf;
	}

	void operator+=(rstrw&& a)
	{
		m_buf+=r_move(a.m_buf);
	}

	void operator+=(ushort ch)
	{
		m_buf+=ch;
	}

	friend rbool operator<(const rstrw& a,const rstrw& b)
	{
		for(int i=0;i<a.count()&&i<b.count();i++)
		{
			if(a[i]!=b[i])
			{
				return a[i]<b[i];
			}
		}
		return a.count()<b.count();
	}

	friend rbool operator>(const rstrw& a,const rstrw& b)
	{
		return b<a;
	}

	friend rbool operator<=(const rstrw& a,const rstrw& b)
	{
		return !(a>b);
	}

	friend rbool operator>=(const rstrw& a,const rstrw& b)
	{
		return !(a<b);
	}

	ushort* set_count(int count)
	{
		m_buf.realloc_n(count);
		return begin();
	}

	ushort* set_size(int size)
	{
		return set_count(size/2);
	}

	void set_w(const wchar* p)
	{
		int len=xf::strlenw(p);
		m_buf.realloc_n_not_change(rbuf<ushort>::extend_num(len));
		m_buf.m_count=len;
		xf::memcpy(m_buf.begin(),p,len*2);
	}

	void push(ushort ch)
	{
		m_buf.push(ch);
	}

	void push_front(ushort ch)
	{
		m_buf.push_front(ch);
	}

	ushort pop()
	{
		return m_buf.pop();
	}

	ushort pop_front()
	{
		return m_buf.pop_front();
	}

	int count() const 
	{
		return m_buf.count();
	}

	int size() const
	{
		return count()*2;
	}

	ushort* begin() const 
	{
		return m_buf.begin();
	}

	ushort* end() const 
	{
		return m_buf.end();
	}

	rbool empty() const 
	{
		return m_buf.empty();
	}

	void clear()
	{
		m_buf.clear();
	}

	static ushort* next(void* p)
	{
		return ((ushort*)p)+1;
	}

	static ushort* prev(void* p)
	{
		return ((ushort*)p)-1;
	}

	ushort* pos(int num) const
	{
		return begin()+num;
	}

	int pos(void* p) const
	{
		return int((ushort*)p-begin());
	}

	rstrw sub(int begin) const
	{
		return sub(begin,count());
	}

	rstrw sub(int begin,int end) const
	{
		rstrw ret;
		ret.m_buf=m_buf.sub(begin,end);
		return r_move(ret);
	}

	rbool erase(int begin,int end)
	{
		return m_buf.erase(begin,end);
	}

	rbool erase(int i)
	{
		return erase(i,i+1);
	}

	rbool insert(int pos,const rstrw& a)
	{
		return m_buf.insert(pos,a.m_buf);
	}

	ushort get(int i) const
	{
		if(i>=count())
		{
			return (ushort)0;
		}
		else
		{
			return m_buf[i];
		}
	}

	ushort get_top() const
	{
		if(count()>0)
		{
			return m_buf.m_p[count()-1];
		}
		return (ushort)0;
	}

	ushort get_bottom() const
	{
		if(count()>0)
		{
			return m_buf.m_p[0];
		}
		return (ushort)0;
	}

	ushort get_left() const
	{
		return get_bottom();
	}

	ushort get_right() const
	{
		return get_top();
	}

	rbool is_number() const
	{
		if(empty())
		{
			return false;
		}
		for(int i=0;i<count();i++)
		{
			if(!is_number(m_buf[i]))
			{
				return false;
			}
		}
		return true;
	}

	static rbool is_number(ushort ch)
	{
		return ch>=r_char('0')&&ch<=r_char('9');
	}

	int find(rstrw s,int begin=0) const
	{
		return r_find<rstrw>(*this,s,begin);
	}

	int find_last(ushort ch) const
	{
		return m_buf.find_last(ch);
	}
};
﻿#pragma once

#include "../rlib/rstr.h"

struct treg
{
	uint eip;
	uint esp;
	uint ebp;
	uint esi;
	uint edi;
	uint eax;
	uint ebx;
	uint ecx;
	uint edx;

	enum 
	{
		c_esp=4,
		c_ebp=8,
		c_esi=12,
		c_edi=16,
		c_eax=20,
		c_ebx=24,
		c_ecx=28,
		c_edx=32
	};
};

struct topnd
{
	int type;
	int off;
	int val;

	enum
	{
		c_null,
		c_reg,//ebp
		c_imme,//4
		c_addr,//[ebp+4]
	};

	topnd()
	{
		clear();
	}

	void clear()
	{
		type=c_null;
		off=0;
		val=0;
	}

	rbool empty()
	{
		return type==c_null;
	}
};

struct tins
{
	int type;
	topnd first;
	topnd second;

	tins()
	{
		clear();
	}

	void clear()
	{
		type=c_rjit_n;
		first.clear();
		second.clear();
	}

	rbool empty()
	{
		return type==c_rjit_n;
	}

	enum
	{
		c_rjit_n,

		c_calle_i=6,

		c_call_i=12,
		c_call_r,
		c_call_a,

		c_ret_n=18,

		c_ret_i=24,
		c_ret_r,
		c_ret_a,

		c_push_i=30,
		c_push_r,
		c_push_a,

		c_pop_i=36,
		c_pop_r,
		c_pop_a,

		c_jmp_i=42,
		c_jmp_r,
		c_jmp_a,

		c_jebxz_i=48,
		c_jebxz_r,
		c_jebxz_a,

		c_jebxnz_i=54,
		c_jebxnz_r,
		c_jebxnz_a,

		c_halt_n=60,

		c_nop_n=66,

		c_lea_ri=72,
		c_lea_ai,
		c_lea_rr,
		c_lea_ar,
		c_lea_ra,
		c_lea_aa,

		c_mov_ri,
		c_mov_ai,
		c_mov_rr,
		c_mov_ar,
		c_mov_ra,
		c_mov_aa,

		c_movb_ri,
		c_movb_ai,
		c_movb_rr,
		c_movb_ar,
		c_movb_ra,
		c_movb_aa,

		c_movl_ri,
		c_movl_ai,
		c_movl_rr,
		c_movl_ar,
		c_movl_ra,
		c_movl_aa,

		c_add_ri,
		c_add_ai,
		c_add_rr,
		c_add_ar,
		c_add_ra,
		c_add_aa,

		c_sub_ri,
		c_sub_ai,
		c_sub_rr,
		c_sub_ar,
		c_sub_ra,
		c_sub_aa,
		
		c_imul_ri,
		c_imul_ai,
		c_imul_rr,
		c_imul_ar,
		c_imul_ra,
		c_imul_aa,

		c_idiv_ri,
		c_idiv_ai,
		c_idiv_rr,
		c_idiv_ar,
		c_idiv_ra,
		c_idiv_aa,

		c_imod_ri,
		c_imod_ai,
		c_imod_rr,
		c_imod_ar,
		c_imod_ra,
		c_imod_aa,

		c_cesb_ri,
		c_cesb_ai,
		c_cesb_rr,
		c_cesb_ar,
		c_cesb_ra,
		c_cesb_aa,

		c_cnesb_ri,
		c_cnesb_ai,
		c_cnesb_rr,
		c_cnesb_ar,
		c_cnesb_ra,
		c_cnesb_aa,

		c_cgsb_ri,
		c_cgsb_ai,
		c_cgsb_rr,
		c_cgsb_ar,
		c_cgsb_ra,
		c_cgsb_aa,

		c_cgesb_ri,
		c_cgesb_ai,
		c_cgesb_rr,
		c_cgesb_ar,
		c_cgesb_ra,
		c_cgesb_aa,

		c_clsb_ri,
		c_clsb_ai,
		c_clsb_rr,
		c_clsb_ar,
		c_clsb_ra,
		c_clsb_aa,

		c_clesb_ri,
		c_clesb_ai,
		c_clesb_rr,
		c_clesb_ar,
		c_clesb_ra,
		c_clesb_aa,

		c_band_ri,
		c_band_ai,
		c_band_rr,
		c_band_ar,
		c_band_ra,
		c_band_aa,

		c_bor_ri,
		c_bor_ai,
		c_bor_rr,
		c_bor_ar,
		c_bor_ra,
		c_bor_aa,

		c_bnot_i,
		c_bnot_r,
		c_bnot_a,

		c_bxor_ri=180,
		c_bxor_ai,
		c_bxor_rr,
		c_bxor_ar,
		c_bxor_ra,
		c_bxor_aa,

		c_bshl_ri,
		c_bshl_ai,
		c_bshl_rr,
		c_bshl_ar,
		c_bshl_ra,
		c_bshl_aa,

		c_bshr_ri,
		c_bshr_ai,
		c_bshr_rr,
		c_bshr_ar,
		c_bshr_ra,
		c_bshr_aa,

		c_bsar_ri,
		c_bsar_ai,
		c_bsar_rr,
		c_bsar_ar,
		c_bsar_ra,
		c_bsar_aa,

		c_udiv_ri,
		c_udiv_ai,
		c_udiv_rr,
		c_udiv_ar,
		c_udiv_ra,
		c_udiv_aa,

		c_umod_ri,
		c_umod_ai,
		c_umod_rr,
		c_umod_ar,
		c_umod_ra,
		c_umod_aa,
	
		c_ucgsb_ri,
		c_ucgsb_ai,
		c_ucgsb_rr,
		c_ucgsb_ar,
		c_ucgsb_ra,
		c_ucgsb_aa,

		c_ucgesb_ri,
		c_ucgesb_ai,
		c_ucgesb_rr,
		c_ucgesb_ar,
		c_ucgesb_ra,
		c_ucgesb_aa,

		c_uclsb_ri,
		c_uclsb_ai,
		c_uclsb_rr,
		c_uclsb_ar,
		c_uclsb_ra,
		c_uclsb_aa,

		c_uclesb_ri,
		c_uclesb_ai,
		c_uclesb_rr,
		c_uclesb_ar,
		c_uclesb_ra,
		c_uclesb_aa,
	};
};

struct tfile;

struct tpos
{
	tfile* file;
	int line;

	tpos()
	{
		clear();
	}

	void clear()
	{
		file=null;
		line=0;
	}

	rbool empty()
	{
		return file==null;
	}

	friend rbool operator==(const tpos& a,const tpos& b)
	{
		return a.file==b.file&&a.line==b.line;
	}

	friend rbool operator!=(const tpos& a,const tpos& b)
	{
		return a.file!=b.file||a.line!=b.line;
	}
};

struct tfunc;

struct tasm
{
	tins ins;//tins放在最前面便于把指针转换为tasm*
	rbuf<rstr> vstr;
	tpos pos;
	tfunc* ptfi;//反射到tfunc，不用初始化
	uchar* start;//jit地址

	tasm()
	{
		clear();
	}

	tasm(const rbuf<rstr>& vstr)
	{
		clear();
		this->vstr=vstr;
	}

	tasm(const rbuf<rstr>& vstr,tpos pos)
	{
		clear();
		this->vstr=vstr;
		this->pos=pos;
	}

	tasm(tasm&& a)
	{
		ins=a.ins;
		vstr=a.vstr;
		pos=a.pos;
		ptfi=a.ptfi;
		start=a.start;
	}

	void operator=(tasm&& a)
	{
		ins=a.ins;
		vstr=a.vstr;
		pos=a.pos;
		ptfi=a.ptfi;
		start=a.start;
	}

	void clear()
	{
		ins.clear();
		vstr.clear();
		pos.clear();
		ptfi=null;
		start=null;
	}
};

//优化节点
struct top_node
{
	rbuf<tasm> src;
	rbuf<tasm> dst;

	void clear()
	{
		src.clear();
		dst.clear();
	}
};
﻿#pragma once

#include "tconf.h"
#include "tasm.h"
#include "tdef.h"

struct tword
{
	rstr val;//最常用的数据成员放在首位可以略微提高效率
	rbuf<rstr> multi;//todo:rstr很难保存行号，用rbuf<tword*>可能更好
	tpos pos;//位置

	tword()
	{
		clear();
	}

	tword(const rstr& s)
	{
		clear();
		val=s;
	}

	tword(tword&& a)
	{
		pos=a.pos;
		val=a.val;
		multi=a.multi;
	}

	void operator=(tword&& a)
	{
		val.m_buf.free();
		multi.free();
		val=a.val;
		multi=a.multi;
		pos=a.pos;
	}

	void clear()
	{
		pos.clear();
		val.clear();
		multi.clear();
	}

	rbool empty() const
	{
		return val.empty()&&multi.empty();
	}
	
	//val和multi均不空表示sizeof
	rbool is_multi() const
	{
		return !multi.empty()&&val.empty();
	}

	friend rbool operator==(const tword& a,const tword& b)
	{
		return a.val==b.val;
	}

	friend rbool operator!=(const tword& a,const tword& b)
	{
		return !(a==b);
	}

	friend rbool operator==(const tword& a,const rstr& b)
	{
		return a.val==b;
	}

	friend rbool operator!=(const tword& a,const rstr& b)
	{
		return !(a==b);
	}

	friend rbool operator==(const rstr& a,const tword& b)
	{
		return a==b.val;
	}

	friend rbool operator!=(const rstr& a,const tword& b)
	{
		return !(a==b);
	}

	rbool is_name() const
	{
		if(val.empty())
		{
			return false;
		}
		int i=0;
		if(rstr::is_alpha(val.get(i))||r_char('_')==val.get(i))
		{
			i++;
		}
		elif(rcode::is_utf8_3(val.get(i))&&val.get(i+1)&&val.get(i+2))
		{
			i+=3;
		}
		elif(rcode::is_utf8_2(val.get(i))&&val.get(i+1))
		{
			i+=2;
		}
		else
		{
			return false;
		}
		for(;i<val.count();i++)
		{
			if(rstr::is_number(val[i])||rstr::is_alpha(val[i])||
				r_char('_')==val[i]||r_char('.')==val[i])
			{
				continue;
			}
			elif(rcode::is_utf8_3(val[i])&&val.get(i+1)&&val.get(i+2))
			{
				i+=2;
				continue;
			}
			elif(rcode::is_utf8_2(val[i])&&val.get(i+1))
			{
				i++;
				continue;
			}
			else
			{
				return false;
			}
		}
		return true;
	}

	rbool is_cint() const
	{
		return val.is_number();
	}

	rbool is_cuint() const
	{
		return val.sub(0,val.count()-1).is_number()&&val.get_top()==r_char('u');
	}

	rbool is_caddr() const
	{
		if(r_char('&')!=val.get(0)||r_char(')')!=val.get_top())
		{
			return false;
		}
		for(int i=0;i<val.count()-2;i++)
		{
			if(val[i]==r_char('.'))
			{
				return true;
			}
		}
		return false;
	}

	rbool is_cdouble() const
	{
		if(!rstr::is_number(val.get_bottom())||
			!rstr::is_number(val.get_top()))
		{
			return false;
		}
		int count=0;
		for(int i=1;i<val.count();i++)
		{
			if(val[i]==r_char('.'))
			{
				count++;
			}
		}
		return count==1;
	}

	//常量指针，一般只用于null
	rbool is_cpoint() const
	{
		return (val.sub(0,val.count()-1).is_number()&&val.get_right()==r_char('p')||
			is_caddr());
	}

	//字符串常量，如"a"
	rbool is_cstr() const
	{
		return val.get_bottom()==r_char('\"');
	}

	rbool is_const() const
	{
		return rstr::is_number(val.get(0))||val.get(0)==r_char('\"')||is_caddr();
	}
};

struct tmac
{
	rstr name;
	rbuf<rstr> param;
	rbuf<rstr> vstr;
	rbool is_super;

	tmac()
	{
		is_super=false;
	}

	tmac(const rstr& a)
	{
		name=a;
		is_super=false;
	}

	friend rbool operator<(const tmac& a,const tmac& b)
	{
		return a.name<b.name;
	}
};

struct ttl
{
	rstr name;
	rstr val;//默认值
};

struct tfile
{
	rstr name;
	rstr cont;
	rbuf<tword> vword;
	rbuf<rstr> line_list;
	rbuf<int> tab_list;//前面tab个数，1个tab等于4个空格（todo:改成8个空格）

	tfile()
	{
	}

	tfile(const rstr& name)
	{
		this->name=name;
	}

	friend rbool operator<(const tfile& a,const tfile& b)
	{
		return a.name<b.name;
	}
};

struct tdata
{
	rstr type;
	rstr name;
	int size;//真实大小
	int count;//数组个数
	int off;//相对偏移
	rbuf<tword> param;//默认参数

	tdata()
	{
		clear();
	}

	tdata(const rstr& type)
	{
		clear();
		this->type=type;
	}

	tdata(const rstr& type,const rstr& name)
	{
		clear();
		this->type=type;
		this->name=name;
	}

	void clear()
	{
		type.clear();
		name.clear();
		size=0;
		count=0;
		off=0;
		param.clear();
	}

	friend rbool operator==(const tdata& a,const tdata& b)
	{
		return a.name==b.name;
	}
};

//表达式和语句几乎没有区别
struct tsent
{
	rbuf<tword> vword;
	rstr type;//表达式类型，也可以理解为语句返回值的类型
	tpos pos;

	tsent()
	{
		clear();
	}

	tsent(tsent&& a)
	{
		pos=a.pos;
		type=a.type;
		vword=a.vword;
	}

	void operator=(tsent&& a)
	{
		type.m_buf.free();
		vword.free();
		pos=a.pos;
		type=a.type;
		vword=a.vword;
	}

	void clear()
	{
		pos.clear();
		type.clear();
		vword.clear();
	}

	tsent sub(int begin,int end) const
	{
		tsent ret;
		ret.pos=pos;
		ret.vword=vword.sub(begin,end);//类型信息为空
		return r_move(ret);
	}

	rbool empty() const
	{
		return vword.empty();
	}
};

struct tdynamic
{
	int key;
	rbuf<rbuf<rstr> > vparam;

	tdynamic()
	{
	}

	friend rbool operator<(const tdynamic& a,const tdynamic& b)
	{
		return a.key<b.key;
	}
};

struct tclass;

struct tfunc
{
	rbool is_final;
	rbool is_macro;
	rbool is_cfunc;
	rbool is_dynamic;
	rbool is_friend;
	rstr lambda_data;
	tdata retval;
	rstr name;
	rstr name_dec;//增加一个dec变量是为了提高查找效率

	rbuf<ttl> vtl;
	rbuf<tdata> param;//参数列表
	rbuf<tdata> local;//局部变量表
	
	rbuf<tword> vword;//函数内容的词表
	rbuf<tsent> vsent;//语句表
	rbuf<tasm> vasm;

	//tpos first_pos;//first_pos似乎没用
	//tpos last_pos;
	tpos pos;
	
	int64 count;
	tclass* ptci;//反射到tclass，不用初始化

	uchar* code;//jit代码段
	rset<tdynamic> sdynamic;
	int id;
	int tid;

	tfunc()
	{
		clear();
	}

	~tfunc()
	{
		if(code!=null)
		{
			xf::free_v(code);//注意jit以后不能直接调用默认的拷贝构造函数
		}
	}

	void clear()
	{
		is_final=false;
		is_macro=false;
		is_cfunc=false;
		is_dynamic=false;
		is_friend=false;
		lambda_data.clear();
		retval.clear();
		name.clear();
		name_dec.clear();

		vtl.clear();
		param.clear();
		local.clear();
		
		vword.clear();
		vsent.clear();
		vasm.clear();

		pos.clear();
		
		count=0;
		ptci=null;
		code=null;
		sdynamic.clear();
		id=0;
		tid=0;
	}

	rstr get_dec() const
	{
		rstr s;
		s+=name+"(";
		for(int j=0;j<param.count();j++)
		{
			if(j!=0)
			{
				s+=",";
			}
			s+=param[j].type;
		}
		s+=")";
		return r_move(s);
	}

	friend rbool operator<(const tfunc& a,const tfunc& b)
	{
		return a.name_dec<b.name_dec;
	}
};

struct tclass
{
	rstr name;
	rset<tmac> vmac;//宏列表
	rbuf<tdata> vdata;//数据成员列表
	rset<tfunc> vfunc;//函数成员列表
	rset<tfunc> vfunctl;//模板函数列表

	rbuf<tword> vword;
	rbuf<ttl> vtl;
	rbuf<tsent> vfather;//父类表

	int size;
	rbool is_friend;

	void clear()
	{
		name.clear();
		vmac.clear();
		vdata.clear();
		vfunc.clear();
		vfunctl.clear();

		vword.clear();
		vtl.clear();
		vfather.clear();

		size=0;
		is_friend=false;
	}

	tclass()
	{
		clear();
	}

	friend rbool operator<(const tclass& a,const tclass& b)
	{
		return a.name<b.name;
	}
};

struct taddr
{
	uint start;
	uint end;
	tfunc* ptfi;

	taddr()
	{
	}

	taddr(uint start,uint end,tfunc* ptfi)
	{
		this->start=start;
		this->end=end;
		this->ptfi=ptfi;
	}

	friend rbool operator<(const taddr& a,const taddr& b)
	{
		return a.end<=b.start;
	}
};

struct tenv
{
	tfunc* ptfi;
	uint v_ebp;

	tenv()
	{
		ptfi=null;
		v_ebp=0;
	}
};

struct tgpp
{
	tclass* p;
	rbool visit;

	tgpp()
	{
	}

	tgpp(tclass* p)
	{
		this->p=p;
	}

	friend rbool operator<(const tgpp& a,const tgpp& b)
	{
		return a.p<b.p;
	}
};

//共享状态
struct tsh
{
	toptr m_optr;
	tkey m_key;
	tconf m_conf;

	rset<tclass> m_class;
	rset<tclass> m_classtl;//模板

	rset<tfile> m_file;
	rset<tmac> m_vdefine;

	tclass* m_main;
	rstr m_main_data;//全局变量存储区
	rstr m_main_file;

	int m_mode;
	int m_point_size;
	uchar* m_main_cont;

	rbuf<top_node> m_match;

	rdic<void*> m_func_list;//jit静态函数地址表
	void* m_hins;
	int m_ret;

	rset<taddr> m_addr;
	rdic<void*> m_dll_func;
	rdic<tfunc*> m_macro;
	rbuf<rstr> m_path;

	enum
	{
		c_vm,
		c_jit,
		c_nasm,
		c_gpp,
	};

	tsh()
	{
		m_main=null;
		m_mode=c_vm;
		m_point_size=4;
		m_main_cont=null;
	}
};
﻿#pragma once

#include "../rlib/rdic.h"

struct tconf
{
	enum
	{
		c_auto_addinit=1,
		c_auto_addfunc=1,//自动增加构造析构等函数
		c_auto_import=1,
		c_op_empty_func=1,//优化基本数据类型空构造析构函数开关
		c_op_nop=1,
		c_op_zero=1,//优化add esp,0
		c_op_merge=1,//同一行连续加减同一个寄存器合并为一条指令
		c_op_ebp=1,//如果本函数未使用ebp可以不用push ebp节省3条指令
		c_op_base_calc=1,//优化基础运算，如调用int.opreator+可变成一条add指令
		c_op_pass=1,//优化参数传递，如传递int不需要调用拷贝构造函数
		c_op_const_eval=1,//常量表达式求值
		c_op_match=1,//汇编模式匹配优化
		c_run=1,
		c_stack_size=(2*1024*1024),
	};
};

struct toptr
{
	rbuf<rstr> m_optr;//编译器使用
	rbuf<rstr> m_optr_s;//排好序的运算符，因为词法分析是贪心的
	rdic<int> m_dic;//字典中存放的是优先级，值小的优先
	rdic<int> m_num;
	int m_optr_max;

	enum
	{
		c_sbk_l,
		c_sbk_r,//()小括号
		c_mbk_l,
		c_mbk_r,//[]中括号
		c_bbk_l,
		c_bbk_r,//{}大括号
		
		c_arrow_r,//->右箭头
		c_dot,//.
		c_domain,//::作用域运算符
		c_semi,//;分号
		c_colon,//:冒号
		c_comma,//,
		c_sharp,//预处理符号#
		c_sharp_sharp,//表达式起止符号,使用一个根本不会出现的符号
		c_at,
		c_at_at,

		c_destruct,//~
		c_addr,//&
		c_not,//!
		c_plusplus,//++
		c_minusminus,//--
		c_negative,
		c_dollar,
		
		c_mul,//*
		c_divide,//除
		c_modulo,
		
		c_plus,//+
		c_minus,//-
		
		c_less_equal,
		c_great_equal,
		c_equal_equal,
		c_not_equal,

		c_tbk_l,
		c_tbk_r,//<>尖括号

		c_and,
		c_or,
		
		c_arrow_l,//<-
		c_exchange,//<->

		c_equal,//=
		c_temp_94,//+=
		c_temp_95,//-=
		c_temp_96,//*=
		c_temp_97,// /=
		c_temp_98,// %=
		c_temp_99,// =>
		c_less_great,
	};

	toptr()
	{
		m_optr_max=0;
#ifndef _RS
		char* optr_arr[]={
#else
		optr_arr=array<char*>[
#endif
			"(","0","0",
			")","0","0",
			"[","0","0",
			"]","0","0",
			"{","0","0",
			"}","0","0",
			"->","0","2",
			".","0","2",
			"::","0","2",
			";","0","0",
			":","0","0",
			",","0","0",
			"#","0","0",
			"##","10","0",
			"@","0","0",
			"@@","0","0",

			"~","1","1",
			"&","1","1",
			"!","1","1",
			"++","1","1",
			"--","1","1",
			"neg","1","1",//todo:运算符不能用字母
			"$","0","1",

			"*","2","2",
			"/","2","2",
			"%","2","2",

			"+","3","2",
			"-","3","2",

			"<=","4","2",
			">=","4","2",
			"==","4","2",
			"!=","4","2",

			"<","4","2",
			">","4","2",

			"&&","5","2",
			"||","6","2",

			"<-","9","2",
			"<->","9","2",

			"=","9","2",
			"+=","9","2",
			"-=","9","2",
			"*=","9","2",
			"/=","9","2",
			"%=","9","2",
			"=>","9","2",
			"<>","4","2",
#ifndef _RS
		};
#else
		];
#endif
#ifndef _RS
		for(int i=0;i<r_size(optr_arr)/r_size(char*);i+=3)
		{
			m_optr+=optr_arr[i];
			m_dic[optr_arr[i]]=rstr(optr_arr[i+1]).toint();
			m_num[optr_arr[i]]=rstr(optr_arr[i+2]).toint();
		}
#else
		for(int i=0;i<optr_arr.count();i+=3)
		{
			m_optr+=optr_arr[i];
			m_dic[optr_arr[i]]=rstr(optr_arr[i+1]).toint();
			m_num[optr_arr[i]]=rstr(optr_arr[i+2]).toint();
		}
#endif
		sort_optr();
	}

	rstr& operator[](int n) const
	{
		return m_optr[n];
	}

	void sort_optr()
	{
		m_optr_s=m_optr;
		r_qsort<rstr>(m_optr_s);
		m_optr_max=0;
		for(int i=0;i<m_optr_s.count();i++)
		{
			if(m_optr_s[i].count()>m_optr_max)
			{
				m_optr_max=m_optr_s[i].count();
			}
		}
	}

	int get_grade(const rstr& s) const
	{
		int* p=m_dic.find(s);
		if(p==null)
		{
			return 0;
		}
		return *p;
	}
	
	//比较两个运算符的优先级，true表示第一个优先于第二个，相同优先级总是从左到右计算
	rbool precede(const rstr& first,const rstr& second) const
	{
		return get_grade(first)<=get_grade(second);
	}

	rbool is_optr(const rstr& s) const
	{
		return r_find_b<rstr>(m_optr_s,s)<m_optr_s.count();
	}
};

struct tkey
{
	rbuf<rstr> m_key;
	rdic<int> m_dic;

	enum
	{
		c_rjit,

		c_calle,
		c_call,
		c_retn,
		c_reti,

		c_push,
		c_pop,

		c_jmp,
		c_jebxz,//如果ebx等于0则跳转
		c_jebxnz,

		c_halt,
		c_nop,

		c_lea,
		c_mov,
		c_movb,
		c_movl,

		c_add,
		c_sub,
		c_imul,
		c_idiv,
		c_imod,

		c_cesb,
		c_cnesb,
		c_cgsb,//cmp great set ebx带符号设置指令，大于则置1，否则置0
		c_cgesb,
		c_clsb,
		c_clesb,

		c_band,
		c_bor,
		c_bnot,
		c_bxor,
		c_bshl,
		c_bshr,
		c_bsar,

		c_udiv,
		c_umod,
		c_ucgsb,
		c_ucgesb,
		c_uclsb,
		c_uclesb,

		c_rn,

		c_rd8,
		c_rd16,
		c_rd32,
		c_rd64,
		c_rdp,

		c_eip,
		c_esp,
		c_ebp,
		c_eax,
		c_ebx,
		c_ecx,
		c_edx,
		c_esi,
		c_edi,
		c_eflags,

		c_void,
		c_char,
		c_int,
		c_uint,
		c_int64,
		c_double,
		c_rp,
		c_var,
		c_rbuf,
		c_rstr,

		c_js_func,//JS函数
		c_js_obj,
		c_js_findf,

		c_if,
		c_ifn,//与unless功能一样,感觉ifnot或者ifn更清晰
		c_else,
		c_break,
		c_continue,
		c_continued,
		c_return,
		c_class,
		c_template,
		c_this,
		c_sizeof,
		c_main,
		c_include,
		c_import,
		c_endif,
		c_ifdef,
		c_ifndef,
		c_define,
		c_enum,
		c_for,
		c_to,
		c_in,
		c_case,
		c_friend,
		c_cfunc,
		c_dynamic,
		c_private,
		c_protected,
		c_public,
		c_switch,
		c_typename,
		c_typeof,
		c_s_ret,
		c_s_off,
		c_s_param,
		c_s_local,
		c_mac,//宏
		c_export,
		c_lambda,
		c_self,
		c_extern,
		c_btemp,//构造临时对象
		c_pcall,//函数指针调用
		c_LAMBDA,
		c_SELF,
		c_rvm,
		c_rvara,
		c_rvarb,
		c_temp,
		c_ltemp,
		c_plambda,
		c_pmain,//全局数据的引用
		c_penv,//环境指针
	};

	tkey()
	{
#ifndef _RS
		char* key_arr[]={
#else
		key_arr=array<char*>[
#endif
			"rjit",

			"calle",
			"call",
			"retn",
			"reti",

			"push",
			"pop",

			"jmp",
			"jebxz",
			"jebxnz",

			"halt",
			"nop",

			"lea",
			"mov",
			"movb",
			"movl",

			"add",
			"sub",
			"imul",
			"idiv",
			"imod",

			"cesb",
			"cnesb",
			"cgsb",
			"cgesb",
			"clsb",
			"clesb",

			"band",
			"bor",
			"bnot",
			"bxor",
			"bshl",
			"bshr",
			"bsar",

			"_udiv",
			"_umod",
			"_ucgsb",
			"_ucgesb",
			"_uclsb",
			"_uclesb",

			"rn",

			"rd8",
			"rd16",
			"rd32",
			"rd64",
			"rdp",

			"eip",
			"esp",
			"ebp",
			"eax",
			"ebx",
			"ecx",
			"edx",
			"esi",
			"edi",
			"eflags",

			"void",
			"char",
			"int",
			"uint",
			"int64",
			"double",
			"rp",
			"var",
			"rbuf",
			"rstr",

			"function",
			"_js_obj",
			"_js_findf",

			"if",
			"ifn",
			"else",
			"break",
			"continue",
			"continued",
			"return",
			"class",
			"template",
			"this",
			"sizeof",
			"main",
			"include",
			"import",
			"endif",
			"ifdef",
			"ifndef",
			"define",
			"enum",
			"for",
			"to",
			"in",
			"case",
			"friend",
			"cfunc",
			"dynamic",
			"private",
			"protected",
			"public",
			"switch",
			"typename",
			"typeof",
			"s_ret",
			"s_off",
			"s_param",
			"s_local",
			"mac",
			"export",
			"lambda",
			"self",
			"extern",
			"_BTEMP",
			"_PCALL",
			"_LAMBDA",
			"_SELF",
			"_RVM",
			"_RVARA",
			"_RVARB",
			"_TEMP",
			"_LTEMP",
			"_LAMBDA_C_P",
			"_PMAIN",
			"_PENV",
#ifndef _RS
		};
#else
		];
#endif
#ifndef _RS
		for(int i=0;i<r_size(key_arr)/r_size(char*);i++)
		{
			m_key+=key_arr[i];
		}
#else
		for(int i=0;i<key_arr.count();i++)
		{
			m_key+=key_arr[i];
		}
#endif
		sort_asm();
	}

	rstr& operator[](int n) const
	{
		return m_key[n];
	}

	int count() const
	{
		return m_key.count();
	}

	void sort_asm()
	{
		m_dic.clear();
		for(int i=0;i<m_key.count();i++)
		{
			m_dic[m_key[i]]=i;
		}
	}

	int get_key_index(const rstr& s) const
	{
		int* p=m_dic.find(s);
		if(p==null)
		{
			return m_key.count();
		}
		return *p;
	}

	rbool is_asm_ins(const rstr& s) const
	{
		int* p=m_dic.find(s);
		if(p==null)
		{
			return false;
		}
		int index=*p;
		return index>=0&&index<=c_rn;
	}

	rbool is_asm_reg(const rstr& s) const
	{
		for(int i=c_eip;i<=c_edi;++i)
		{
			if(s==m_key[i])
			{
				return true;
			}
		}
		return false;
	}
};
﻿#pragma once

#define c_rs_deep 150
#define c_point_size 4

#define rskey(a) (sh.m_key[tkey::a])
#define rsoptr(a) (sh.m_optr[toptr::a])

#define v_next_ins_js cur=(tins*)((uchar*)cur+r_size(tasm));goto next
#define v_next_ins reg.eip+=r_size(tasm);goto next

#define v_ato_int(a) (*r_to_pint(&(a)))
#define v_pto_int(a) (*r_to_pint(a))
#define v_ato_uint(a) (*r_to_puint(&(a)))
#define v_pto_uint(a) (*r_to_puint(a))
#define v_ato_char(a) (*r_to_pchar(&(a)))
#define v_pto_char(a) (*r_to_pchar(a))
#define v_pto_int64(a) (*r_to_pint64(a))
#define v_pto_f64(a) (*r_to_pdouble(a))
#define v_pto_rstr(a) (*r_to_prstr(a))

#define v_pto_pchar(a) ((char*)v_pto_int(a))
#define v_pto_pvoid(a) ((void*)v_pto_int(a))

#define v_get_imme_u(a) (r_to_uint((a).val))
#define v_get_reg_u(a) v_pto_uint(r_to_puchar(&reg)+(a).off)
#define v_get_addr_u(a) v_pto_uint(v_get_reg(a)+(a).val)

#define v_get_imme(a) ((a).val)
#define v_get_reg(a) v_pto_int(r_to_puchar(&reg)+(a).off)
#define v_get_addr(a) v_pto_int(v_get_reg(a)+(a).val)
#define v_get_lea(a) (v_get_reg(a)+v_get_imme(a))
#define v_get_addr_8(a) v_pto_char(v_get_reg(a)+(a).val)
#define v_get_addr_64(a) v_pto_int64(v_get_reg(a)+(a).val)
#define v_get_addr_f64(a) v_pto_f64(v_get_reg(a)+(a).val)

#define rsja znasm::get_opnd1_v(vstr)
#define rsjb znasm::get_opnd2_v(vstr)
#define rsj4(a,b,c,d) (zjiti::a(build_ins(sh,rskey(c_nop),b,c,d)))
#define rsjf(a,b) sh.m_func_list[a]=(void*)&b

#define rserror rf::printl(rstr("rs_src:")+__FILE__+" "+__LINE__);ybase::error
﻿#pragma once

#ifdef _MSC_VER
#include "cpp/xf.hpp"
#endif

#ifdef __GNUC__
#include "cpp/xf.hpp"
#endif

#ifdef _RJIT
#include "rs/xf.rs"
#endif

#ifdef _RNASM
#include "rs/xf.rs"
#endif

#ifdef _RVM
#include "rs/xf.rs"
#endif

#ifdef _RGPP
#include "gpp/xf.rs"
#endif
﻿#pragma once

#include "../rlib/rstrw.h"

//包含rstrw的xf
struct xfs
{
	static void* fopen(rstr name,rstr mode)
	{
#ifdef _WIN32
		return xf::_wfopen(rstrw(name).cstrw_t(),rstrw(mode).cstrw_t());
#endif
#ifdef _RS
		return xf::_wfopen(rstrw(name).cstrw_t(),rstrw(mode).cstrw_t());
#endif
#ifdef __GNUC__
		return xf::fopen(name.cstr_t(),mode.cstr_t());
#endif
	}

	static int remove(rstr name)
	{
#ifdef _WIN32
		return xf::_wremove(rstrw(name).cstrw_t());
#endif
#ifdef _RS
		return xf::_wremove(rstrw(name).cstrw_t());
#endif
#ifdef __GNUC__
		return xf::remove(name.cstr_t());
#endif
	}
};
﻿#pragma once

#include "cpp/xbase.hpp"

struct xsock
{
	static void init_sock()
	{
#ifdef _MSC_VER
		WORD wVersionRequested;
		WSADATA wsaData;

		wVersionRequested=MAKEWORD(1,1);

		if(0!=::WSAStartup(wVersionRequested,&wsaData))
		{
			return;
		}

		if(LOBYTE(wsaData.wVersion)!=1||HIBYTE(wsaData.wVersion)!=1)
		{
			return;
		}
#endif
	}

	static void clean_sock()
	{
#ifdef _MSC_VER
		::WSACleanup();
#endif
	}

	static int socket(int af,int type,int protocol)
	{
#ifdef _MSC_VER
		return ::socket(af,type,protocol);
#else
		return 0;
#endif
	}

	static int connect(int s,void* name,int namelen)
	{
#ifdef _MSC_VER
		return ::connect(s,(const struct sockaddr*)name,namelen);
#else
		return 0;
#endif
	}

	static int close(int s)
	{
#ifdef _MSC_VER
		return ::closesocket(s);
#else
		return 0;//return ::close(s);
#endif
	}

	static int send(int s,void* data,int size,int flags)
	{
#ifdef _MSC_VER
		return ::send(s,(const char*)data,size,flags);
#else
		return 0;
#endif
	}

	static int recv(int s,void* data,int size,int flags)
	{
#ifdef _MSC_VER
		return ::recv(s,(char*)data,size,flags);
#else
		return 0;
#endif
	}

	static int bind(int s,void* addr,int namelen)
	{
#ifdef _MSC_VER
		return ::bind(s,(const struct sockaddr*)addr,namelen);
#else
		return 0;
#endif
	}

	static int listen(int s,int backlog)
	{
#ifdef _MSC_VER
		return ::listen(s,backlog);
#else
		return 0;
#endif
	}

	static int accept(int s,void* addr,int* addrlen)
	{
#ifdef _MSC_VER
		return ::accept((SOCKET)s,(struct sockaddr*)addr,addrlen);
#else
		return 0;//return ::accept(s,(struct sockaddr*)addr,addrlen);
#endif
	}
};

struct xsock_t
{
	xsock_t()
	{
		xsock::init_sock();
	}

	~xsock_t()
	{
		xsock::clean_sock();
	}
};
#pragma once

#ifdef _MSC_VER

#pragma warning(disable:4996)
#pragma warning(disable:4345)

#pragma comment(lib,"Ws2_32")

#include <winsock2.h>
#include <windows.h>
#include <wchar.h>
#include <conio.h>
#include <io.h>
#include <process.h>
#else
#include <unistd.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#endif

#ifdef EMSCRIPTEN
#include <emscripten.h>
#endif

#include <stdlib.h>
#include <time.h>
#include <stdio.h>
#include <math.h>
#include <stdarg.h>
#include <string.h>

#include <utility>
#include <new>

#pragma pack(1)

#ifndef uint
typedef unsigned int uint;
#endif

#ifndef ushort
typedef unsigned short ushort;
#endif

#ifndef uchar
typedef unsigned char uchar;
#endif

#ifndef rbool
typedef int rbool;
#endif

#ifndef int64

#ifdef _MSC_VER
typedef __int64 int64;
typedef unsigned __int64 uint64;
#else
typedef long long int64;
typedef unsigned long long uint64;
#endif

#endif

#ifndef wchar

#ifdef _MSC_VER
typedef wchar_t wchar;
#else
typedef ushort wchar;
#endif

#endif

#ifdef _MSC_VER
typedef CRITICAL_SECTION R_CRITICAL_SECTION;
typedef WIN32_FIND_DATAW R_WIN32_FIND_DATAW;
#else
#define FILE_ATTRIBUTE_DIRECTORY 0x00000010
struct R_WIN32_FIND_DATAW
{
	int dwFileAttributes;
	int64 ftCreationTime;
	int64 ftLastAccessTime;
	int64 ftLastWriteTime;
	int nFileSizeHigh;
	int nFileSizeLow;
	int dwReserved0;
	int dwReserved1;
	wchar cFileName[260];
	wchar cAlternateFileName[14];
};
struct R_CRITICAL_SECTION
{
	char buf[24];
};
#endif

#define null nullptr
#define elif else if
#define ifn(a) if(!(a))

#define r_char(a) a
#define r_size(a) ((int)sizeof(a))
#define r_move(a) (std::move(a))
#define r_max(a,b) ((a)>(b)?(a):(b))
#define r_min(a,b) ((a)>(b)?(b):(a))
#define r_cond(cond,a,b) ((cond)?(a):(b))
#define r_ceil_div(a,b) r_cond(0==(a)%(b),(a)/(b),(a)/(b)+1)

#define r_to_int(a) ((int)(a))
#define r_to_uint(a) ((uint)(a))
#define r_to_char(a) ((char)(a))
#define r_to_uchar(a) ((uchar)(a))
#define r_to_int64(a) ((int64)(a))
#define r_to_double(a) ((double)(a))

#define r_to_pint(a) ((int*)(a))
#define r_to_puint(a) ((uint*)(a))
#define r_to_pchar(a) ((char*)(a))
#define r_to_puchar(a) ((uchar*)(a))
#define r_to_pint64(a) ((int64*)(a))
#define r_to_pdouble(a) ((double*)(a))
#define r_to_prstr(a) ((rstr*)(a))

#define AND(a,b) ((a)&(b))
#define OR(a,b) ((a)|(b))
#define XOR(a,b) ((a)^(b))
#define NOT(a) (~(a))

#define SHL(a,b) ((int)((int)(a)<<(int)(b)))
#define SHR(a,b) ((int)((uint)(a)>>(uint)(b)))
#define SAR(a,b) ((int)((int)(a)>>(int)(b)))
#pragma once

#include "xbase.hpp"

typedef void (* xthread_start)(void*);

#ifdef _MSC_VER
typedef uint xthread_ret;//32 bit
#define xthread_call __stdcall
typedef uint (__stdcall* pxthread)(void*);
#else
typedef void* xthread_ret;
#define xthread_call
typedef void* (* pxthread)(void*);
#endif

typedef xthread_ret (xthread_call* thread_start)(void*);

struct xf
{
	int argc;
	void* argv;

	enum
	{
		X_SEEK_SET=SEEK_SET,
		X_SEEK_END=SEEK_END,
	};

	static void print(const char* s)
	{
		::printf("%s",s);//%sַֹгַ
	}

	static void printf(const char* f,const char* s)
	{
		::printf(f,s);
	}

	static void vsnprintf(char* dst,int count,const char* f,char* args)
	{
#ifdef _MSC_VER
		::_vsnprintf(dst,count,f,args);
#else
#ifdef EMSCRIPTEN
		::vsnprintf(dst,count,f,(int*)args);
#else
		::vsnprintf(dst,count,f,args);
#endif
#endif
	}

	static void sprintf(char* src,const char* f,uint n)
	{
		::sprintf(src,f,n);
	}

	static void sprintf64(char* src,const char* f,double n)
	{
		::sprintf(src,f,n);
	}

	static void sscanf(const char* src,const char* f,uint* n)
	{
		::sscanf(src,f,n);
	}

	static void itoa(void* dst,int n)
	{
		::sprintf((char*)dst,"%d",n);
	}

	static void utoa(void* dst,uint n)
	{
		::sprintf((char*)dst,"%u",n);
	}

	static void dtoa(void* dst,double n)
	{
		::sprintf((char*)dst,"%f",n);
	}

	static void int64toa(void* dst,int64 n)
	{
#ifdef _MSC_VER
		::sprintf((char*)dst,"%I64d",n);
#else
		::sprintf((char*)dst,"%lld",n);
#endif
	}

	static int atoi(char* s)
	{
		int result;
		::sscanf(s,"%d",&result);
		return result;
	}

	static uint atou(char* s)
	{
		uint result;
		::sscanf(s,"%u",&result);
		return result;
	}

	static double atod(char* s)
	{
		double result;
		::sscanf(s,"%lf",&result);
		return result;
	}

	static void atoint64(char* s,int64* result)
	{
#ifdef _MSC_VER
		::sscanf(s,"%I64d",result);
#else
		::scanf(s,"%lld",result);
#endif
	}

	static void exit(int a)
	{
		::exit(a);
	}

	static uchar* malloc(int size)
	{
		return (uchar*)::malloc(size);
	}

	static void free(void* p)
	{
		::free(p);
	}

	static void memcpy(void* dst,const void* src,int size)
	{
		::memcpy(dst,src,size);
	}

	static int strlen(const char* s)
	{
		return (int)::strlen(s);
	}

	static int strlenw(const wchar* p)
	{
#ifdef _MSC_VER
		return ::lstrlenW(p);
#else
		int ret=0;
		while(*p!=0)
		{
			ret++;
			p++;
		}
		return ret;
#endif
	}

	static int tick()
	{
#ifdef _MSC_VER
		return ::GetTickCount();
#else
		return (int)((double)::clock()/CLOCKS_PER_SEC*1000);
#endif
	}

	static void sleep(int milliseconds)
	{
		if(milliseconds<50)
		{
			milliseconds=50;
		}
#ifdef _MSC_VER
		::Sleep(milliseconds);
#else
		if(milliseconds>2100000000)
		{
			::sleep(milliseconds/1000);
		}
		else
		{
			::usleep(milliseconds*1000);
		}
#endif
	}

	static int getch()
	{
#ifdef _MSC_VER
		return ::getch();
#else
		struct termios oldt,newt;
		int ch;
		::tcgetattr(STDIN_FILENO,&oldt);
		newt=oldt;
		newt.c_lflag&=~(ICANON|ECHO);
		::tcsetattr(STDIN_FILENO,TCSANOW,&newt);
		ch=::getchar();
		::tcsetattr(STDIN_FILENO,TCSANOW,&oldt);
		return ch;
#endif
	}

	static void srand()
	{
		::srand((uint)::time(null));
	}

	static int rand()
	{
		return ::rand();
	}

	static int cmd(const char* p)
	{
		return ::system(p);
	}

	static int get_exe_name(wchar* buf,int size)
	{
#ifdef _MSC_VER
		return GetModuleFileNameW(null,buf,size);
#else
#ifdef EMSCRIPTEN
		if(size>=10)
		{
			buf[0]='/';
			buf[1]='r';
			buf[2]=0;
			return true;
		}
		return false;
#else
		if(!get_cur_dir(buf,size))
		{
			return false;
		}
		int len=strlenw(buf);
		buf[len]='/';
		buf[len+1]='r';
		buf[len+2]=0;
		return true;
#endif
#endif
	}

	static int get_cur_dir(wchar* buf,int size)
	{
#ifdef _MSC_VER
		return GetCurrentDirectoryW(size,buf);
#else
#ifdef EMSCRIPTEN
		if(size>=2)
		{
			buf[0]=0;
			buf[1]=0;
			return true;
		}
		return false;
#else
		FILE* fp=popen("pwd","r");
		if(fp==null)
		{
			return false;
		}
		char tmp[4096];
		if(fgets(tmp,r_size(tmp),fp)==null)
		{
			return false;
		}
		pclose(fp);
		int i;
		for(i=0;i<strlen(tmp);i++)
		{
			buf[i]=tmp[i];
		}
		buf[i]=0;
		return true;
#endif
#endif
	}

	/*static int64 get_file_update_time(wchar* path)
	{
#ifdef _MSC_VER
		int64 ft;
		HANDLE hFile=::CreateFileW(path,
			GENERIC_READ,
			FILE_SHARE_READ,
			null,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			null);
		if(hFile==INVALID_HANDLE_VALUE)
		{
			return 0;
		}
		if(!::GetFileTime(hFile,null,null,(FILETIME*)&ft))
		{
			return 0;
		}
		::CloseHandle(hFile);
		return ft;
#else
		return 0;
		struct stat buf;
		int ret=stat(path,&buf);
		if(0!=ret)
		{
			return false;
		}
		*ft=(int64)buf.st_mtime;
		return true;
#endif
	}*/

	/*static int get_exe_size(uchar* data)
	{
#ifdef _MSC_VER
		PIMAGE_DOS_HEADER dos_head=(PIMAGE_DOS_HEADER)data;
		PIMAGE_OPTIONAL_HEADER op_head=(PIMAGE_OPTIONAL_HEADER)(
			data+dos_head->e_lfanew+4+20);
		PIMAGE_FILE_HEADER file_head=(PIMAGE_FILE_HEADER)(
			data+dos_head->e_lfanew+4);
		PIMAGE_SECTION_HEADER sec=(PIMAGE_SECTION_HEADER)(
			data+dos_head->e_lfanew+r_size(IMAGE_NT_HEADERS));
		int size=op_head->SizeOfHeaders;
		for(int i=0;i<file_head->NumberOfSections;i++)
		{
			size+=sec[i].SizeOfRawData;
		}
		return size;
#endif
	}*/

	static int ftell(void* fp)
	{
		return ::ftell((FILE*)fp);
	}

	static int64 ftell64(void* fp)
	{
#ifdef _MSC_VER
		return ::_ftelli64((FILE*)fp);
#else
		return ::ftello((FILE*)fp);
#endif
	}

	static int fseek(void* fp,int off,int start)
	{
		return ::fseek((FILE*)fp,off,start);
	}

	static int fseek64(void* fp,int64 off,int start)
	{
#ifdef _MSC_VER
		return ::_fseeki64((FILE*)fp,off,start);
#else
		return ::fseeko((FILE*)fp,off,start);
#endif
	}

	static void* _wfopen(wchar* name,wchar* mode)
	{
#ifdef _MSC_VER
		return (void*)::_wfopen(name,mode);
#else
		return null;
#endif
	}

	static void* fopen(char* name,char* mode)
	{
		return ::fopen(name,mode);
	}

	static int fclose(void* fp)
	{
		return ::fclose((FILE*)fp);
	}

	static int fread(void* buf,int size,int count,void* fp)
	{
		return ::fread(buf,size,count,(FILE*)fp);
	}

	static int fwrite(const void* buf,int size,int count,void* fp)
	{
		return ::fwrite(buf,size,count,(FILE*)fp);
	}

	static int _wremove(wchar* name)
	{
#ifdef _MSC_VER
		return ::_wremove(name);
#else
		return 0;
#endif
	}
	
	static int remove(char* name)
	{
		return ::remove(name);
	}

	/*static int _wrename(wchar* oldname,wchar* newname)
	{
#ifdef _MSC_VER
		return ::_wrename(oldname,newname);
#else
		return 0;
#endif
	}*/

	static int create_thr(thread_start start,void* param=null)
	{
		int tid;
#ifdef _MSC_VER
		tid=(int)::_beginthreadex(null,0,start,param,0,null);
		if(0==tid||1==tid)
		{
			return 0;
		}
		else
		{
			return tid;
		}
#else
		if(0!=::pthread_create((pthread_t*)&tid,null,start,param))
		{
			return 0;
		}
		else
		{
			return tid;
		}
#endif
	}

	static void wait_thr(int tid)
	{
#ifdef _MSC_VER
		::WaitForSingleObject((HANDLE)tid,INFINITE);
#else
		::pthread_join((pthread_t)tid,null);
#endif
	}

	static int MultiByteToWideChar(int a,int b,const char* src,int c,wchar* dst,int count)
	{
#ifdef _MSC_VER
		//ʹӢϵͳӦҲװ936ҳ
		return ::MultiByteToWideChar(a,b,src,c,dst,count);
#else
		int len=strlen(src);
		if(dst==null)
		{
			return len+1;
		}
		for(int i=0;i<len;i++)
		{
			dst[i]=src[i];
		}
		dst[len]=0;
		return len+1;
#endif
	}

	static int gbk_to_utf16(const char* src,wchar* dst,int count)
	{
		//ʹӢϵͳӦҲװ936ҳ
		return MultiByteToWideChar(936,0,src,-1,dst,count);
	}

	static int utf16_to_gbk(const wchar* src,char* dst,int buf_size)
	{
#ifdef _MSC_VER
		return ::WideCharToMultiByte(936,0,src,-1,dst,buf_size,null,null);
#else
		int len=strlenw(src);
		if(dst==null)
		{
			return len+1;
		}
		for(int i=0;i<len;i++)
		{
			dst[i]=(char)src[i];
		}
		dst[len]=0;
		return len+1;
#endif
	}

	static uchar* alloc_v(int len)
	{
#ifdef _MSC_VER
		return (uchar*)VirtualAlloc(null,len,
			MEM_COMMIT,PAGE_EXECUTE_READWRITE);
#else
		return null;
#endif
	}

	static void free_v(uchar* addr)
	{
#ifdef _MSC_VER
		VirtualFree(addr,0,MEM_RELEASE);
#endif
	}

	static xf* get_xf()
	{
		static xf g_xf;
		return &g_xf;
	}

	static char* GetCommandLineA()
	{
#ifdef _MSC_VER
		return ::GetCommandLineA();
#else
#ifdef EMSCRIPTEN
		return "rpp -interpret src/example/test/10_1.rpp";
#else
		static char temp[4096];
		temp[0]=0;
		for(int i=0;i<get_xf()->argc;i++)
		{
			strcat(temp,((char**)get_xf()->argv)[i]);
			strcat(temp," ");
		}
		return temp;
#endif
#endif
	}

	static void* FindFirstFileW(wchar* name,R_WIN32_FIND_DATAW* wfd)
	{
#ifdef _MSC_VER
		return ::FindFirstFileW(name,wfd);
#else
		return null;
#endif
	}

	static rbool FindNextFileW(void* handle,R_WIN32_FIND_DATAW* wfd)
	{
#ifdef _MSC_VER
		return ::FindNextFileW(handle,wfd);
#else
		return false;
#endif
	}

	static void FindClose(void* handle)
	{
#ifdef _MSC_VER
		::FindClose(handle);
#endif
	}

	static void InitializeCriticalSection(void* p)
	{
#ifdef _MSC_VER
		::InitializeCriticalSection((CRITICAL_SECTION*)p);
#endif
	}

	static void DeleteCriticalSection(void* p)
	{
#ifdef _MSC_VER
		::DeleteCriticalSection((CRITICAL_SECTION*)p);
#endif
	}

	static void EnterCriticalSection(void* p)
	{
#ifdef _MSC_VER
		::EnterCriticalSection((CRITICAL_SECTION*)p);
#endif
	}

	static void LeaveCriticalSection(void* p)
	{
#ifdef _MSC_VER
		::LeaveCriticalSection((CRITICAL_SECTION*)p);
#endif
	}

	/*static void* find_dll_full(const char* name)
	{
#ifdef _MSC_VER
		PBYTE pb=null;
		MEMORY_BASIC_INFORMATION mbi;
		while(VirtualQuery(pb,&mbi,r_size(mbi))==r_size(mbi))
		{
			if(mbi.State==MEM_FREE)
			{
				mbi.AllocationBase=mbi.BaseAddress;
			}
			if(mbi.AllocationBase==mbi.BaseAddress&&
				mbi.AllocationBase!=null) 
			{
				void* ret=GetProcAddress(
					(HINSTANCE)mbi.AllocationBase,name);
				if(ret!=null)
				{
					return ret;
				}
			} 
			pb+=mbi.RegionSize;
		}
		return null;
#endif
	}

	//Ƕ̰߳ȫ
	static void set_dll_list()
	{
#ifdef _MSC_VER
		tsh& sh=*get_psh();
		PBYTE pb=null;
		MEMORY_BASIC_INFORMATION mbi;
		while(VirtualQuery(pb,&mbi,r_size(mbi))==r_size(mbi))
		{
			if(mbi.State==MEM_FREE)
			{
				mbi.AllocationBase=mbi.BaseAddress;
			}
			if(mbi.AllocationBase==mbi.BaseAddress&&
				mbi.AllocationBase!=null)
			{
				//todo ȥGetProcAddress
				void* ret=GetProcAddress(
					(HINSTANCE)mbi.AllocationBase,"glutSpecialFunc");
				if(ret!=null)
				{
					set_dll_list_one(
						sh,(HINSTANCE)mbi.AllocationBase);
				}
				ret=GetProcAddress(
					(HINSTANCE)mbi.AllocationBase,"glBegin");
				if(ret!=null)
				{
					set_dll_list_one(
						sh,(HINSTANCE)mbi.AllocationBase);
				}
			}
			pb+=mbi.RegionSize;
		}
#endif
	}*/

/*#ifdef _MSC_VER
	static void set_dll_list_one(tsh& sh,HINSTANCE hModule)
	{
		char *pRet=null;
		PIMAGE_DOS_HEADER pImageDosHeader=NULL;
		PIMAGE_NT_HEADERS pImageNtHeader=NULL;
		PIMAGE_EXPORT_DIRECTORY pImageExportDirectory=null;

		pImageDosHeader=(PIMAGE_DOS_HEADER)hModule;
		pImageNtHeader=(PIMAGE_NT_HEADERS)((
			DWORD)hModule+pImageDosHeader->e_lfanew);
		pImageExportDirectory=(PIMAGE_EXPORT_DIRECTORY)(
			(DWORD)hModule+pImageNtHeader->OptionalHeader.DataDirectory[
				IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

		DWORD dwExportRVA=pImageNtHeader->OptionalHeader.DataDirectory[
			IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
		DWORD dwExportSize=pImageNtHeader->OptionalHeader.DataDirectory[
			IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

		DWORD* pAddressOfFunction=(DWORD*)(
			pImageExportDirectory->AddressOfFunctions+(DWORD)hModule);
		DWORD* pAddressOfNames=(DWORD*)(
			pImageExportDirectory->AddressOfNames+(DWORD)hModule);
		DWORD dwNumberOfNames=(DWORD)(
			pImageExportDirectory->NumberOfNames);
		DWORD dwBase=(DWORD)(pImageExportDirectory->Base);

		WORD* pAddressOfNameOrdinals=(WORD*)(
			pImageExportDirectory->AddressOfNameOrdinals+(DWORD)hModule);

		for(int i=0;i<(int)dwNumberOfNames;i++)
		{
			char *strFunction=(char*)(pAddressOfNames[i]+(DWORD)hModule);
			if(*strFunction==0)
			{
				continue;
			}
			pRet=(char*)(pAddressOfFunction[
				pAddressOfNameOrdinals[i]]+(DWORD)hModule);
			if((DWORD)pRet<dwExportRVA+(DWORD)hModule||
				(DWORD)pRet>dwExportRVA+(DWORD)hModule+dwExportSize)
			{
				sh.m_dll_func[strFunction]=(void*)pRet;
			}
		}
	}
#endif*/
};
﻿class char
{
	rd8 m_in

	final ~char()
	{
	}

	final char()
	{
	}

	final char(char& a)
	{
		this=a;
	}

	final char(char a)
	{
		this=a;
	}
	
	TYPE to<TYPE>()
	{
		xf.print("error\n")
	}
	
	template<>
	uint to<uint>()
	{
		return touint
	}
	
	template<>
	int to<int>()
	{
		return toint
	}
	
	template<>
	ushort to<ushort>()
	{
		return toint.toushort
	}
	
	template<>
	int64 to<int64>()
	{
		return toint.toint64
	}

	final int toint()
	{
		return (UCHAR)this;
	}

	final uint touint()
	{
		return (UCHAR)this;
	}

	/*rstr torstr()
	{
		rstr ret(this)
		return ret
	}*/

	char tochar()
	{
		mov esi,this
		mov1 s_ret,[esi]
	}

	final void operator=(char& a)
	{
		this=a;
	}

	final void operator=(char a)
	{
		this=a;
	}
	
	final void operator=(int a)
	{
		this=(char)a;
	}

	/*void operator=(uint a)
	{
		mov esi,this
		mov1 [esi],a
	}*/

	final void operator++()
	{
		this++;
	}

	friend operator<->(char& a,char& b)
	{
		c=a
		a=b
		b=c
	}

	final friend bool operator==(char a,char b)
	{
		return a==b;
	}

	final friend bool operator!=(char a,char b)
	{
		return a!=b;
	}

	final friend bool operator>(char a,char b)
	{
		return (uchar)a>(uchar)b;
	}

	final friend bool operator>=(char a,char b)
	{
		return (uchar)a>=(uchar)b;
	}

	final friend bool operator<(char a,char b)
	{
		return (uchar)a<(uchar)b;
	}

	final friend bool operator<=(char a,char b)
	{
		return (uchar)a<=(uchar)b;
	}

	/*void set(char a)
	{
		mov esi,this
		mov1 [esi],a
	}

	void set(int a)
	{
		mov esi,this
		mov1 [esi],a
	}

	void clear()
	{
		set(0)
	}

	bool empty()
	{
		return this.toint==0
	}*/

	/*void print()
	{
		rf.print this.torstr
	}

	void printl()
	{
		rf.printl this.torstr
	}*/
}
﻿class double
{
	rd64 m_in

	final ~double()
	{
	}

	final double()
	{
	}

	final double(double a)
	{
		this=a;
	}

	final double(double& a)
	{
		this=a;
	}
	
	final double(int a)
	{
		this=a;
	}

	final double(uint a)
	{
		this=a;
	}

	final int toint()
	{
		return (int)this;
	}

	rstr torstr()
	{
		rstr ret(this)
		return ret
	}
	
	friend double operator neg(double a)
	{
		return 0.0-a;
	}

	final void operator=(double a)
	{
		this=a;
	}

	final void operator=(double& a)
	{
		this=a;
	}

	friend operator<->(double& a,double& b)
	{
		c=a
		a=b
		b=c
	}

	final void operator+=(double a)
	{
		this+=a;
	}

	final void operator-=(double a)
	{
		this-=a;
	}

	final void operator*=(double a)
	{
		this*=a;
	}
	
	final void operator/=(double a)
	{
		this/=a;
	}

	friend double operator+(double a,double b) 
	{
		a+=b
		return a
	}

	friend double operator-(double a,double b)
	{
		a-=b
		return a
	}

	friend double operator*(double a,double b)
	{
		a*=b
		return a
	}

	friend double operator/(double a,double b)
	{
		a/=b
		return a
	}

	final friend bool operator<(double a,double b)
	{
		return a<b;
	}

	friend bool operator<=(double a,double b)
	{
		return a<b||a==b;
	}

	final friend bool operator==(double a,double b)
	{
		return a==b;
	}

	friend bool operator!=(double a,double b)
	{
		return !(a==b)
	}

	friend bool operator>(double a,double b)
	{
		return b<a;
	}

	friend bool operator>=(double a,double b)
	{
		return a>b||a==b;
	}
	
	double abs()
	{
		if this<0.0
			return 0.0-this
		return this
	}

	/*void clear()
	{
		mov esi,this
		mov [esi],0
		mov [esi+4],0
	}

	bool empty()
	{
		return 0==this
	}*/

	/*print()
	{
		rf.print this
	}

	printl()
	{
		rf.printl this
	}*/
}
﻿class float
{
	rd32 m_in
	
	~float()
	{
	}

	float()
	{
	}

	float(float a)
	{
		mov esi,[esp+4]
		mov [esi],[esp+8]
	}

	float(float& a)
	{
		mov edi,[esp+4]
		mov esi,[esp+8]
		mov [edi],[esi]
	}
	
	double todouble()
	{
		return double(this)
	}
	
	int toint()
	{
		return todouble.toint
	}

	rstr torstr()
	{
		rstr ret(this)
		return ret
	}
	
	friend float operator neg(float a)
	{
		return (0.0-a).tofloat
	}
	
	void operator=(float a)
	{
		mov esi,[esp+4]
		mov [esi],[esp+8]
	}

	void operator=(float& a)
	{
		mov edi,[esp+4]
		mov esi,[esp+8]
		mov [edi],[esi]
	}
	
	void operator=(double a)
	{
		this=a.tofloat
	}
	
	void operator+=(float a)
	{
		this=this+a
	}

	void operator-=(float a)
	{
		this=this-a
	}

	void operator*=(float a)
	{
		this=this*a
	}
	
	void operator/=(float a)
	{
		this=this/a
	}

	friend float operator+(float a,float b) 
	{
		return (double(a)+double(b)).tofloat
	}

	friend float operator-(float a,float b)
	{
		return (double(a)-double(b)).tofloat
	}

	friend float operator*(float a,float b)
	{
		return (double(a)*double(b)).tofloat
	}

	friend float operator/(float a,float b)
	{
		return (double(a)/double(b)).tofloat
	}

	friend bool operator<(float a,float b)
	{
		return double(a)<double(b)
	}

	friend bool operator<=(float a,float b)
	{
		return a<b||a==b;
	}

	friend bool operator==(float a,float b)
	{
		cesb a,b
		mov s_ret,ebx
	}

	friend bool operator!=(float a,float b)
	{
		return !(a==b)
	}

	friend bool operator>(float a,float b)
	{
		return double(a)>double(b)
	}

	friend bool operator>=(float a,float b)
	{
		return a>b||a==b;
	}
	
	float abs()
	{
		if this<0.0
			return neg this
		return this
	}

	void clear()
	{
		mov esi,this
		mov [esi],0
	}

	bool empty()
	{
		return 0==*(&this).to<int*>
	}

	/*print()
	{
		rf.print rstr(this)
	}

	printl()
	{
		rf.printl rstr(this)
	}*/
}﻿class int
{
	rd32 m_in

	enum
	{
		c_min=4294967295,
		c_max=0x7fffffff
	}

	final ~int()
	{
	}

	final int()
	{
	}

	final int(int a)
	{
		this=a;
	}

	final int(int& a)
	{
		this=a;
	}

	final int(char a)
	{
		this=(UCHAR)a;
	}

	final int(ushort a)
	{
		this=a;
	}

	final TYPE to<TYPE>()
	{
		return (TYPE)this;
	}
	
	template<>
	char to<char>()
	{
		return tochar()
	}
	
	template<>
	ushort to<ushort>()
	{
		return toushort
	}
	
	template<>
	int64 to<int64>()
	{
		return toint64
	}

	final ushort toushort()
	{
		return (ushort)this;
	}

	final int toint()
	{
		return this;
	}

	final uint touint()
	{
		return this;
	}
	
	int64 toint64()
	{
		int64 ret(this)
		return ret
	}
	
	double todouble()
	{
		double ret(this)
		return ret
	}

	rstr torstr()
	{
		rstr ret(this)
		return ret
	}
	
	final char tochar()
	{
		return (char)this;
	}

	final void operator=(int a)
	{
		this=a;
	}

	final void operator=(int& a)
	{
		this=a;
	}

	final void operator=(uint a)
	{
		this=a;
	}

	friend operator<->(int& a,int& b)
	{
		c=a
		a=b
		b=c
	}

	final friend int& operator=>(int a,int& this)
	{
		this=a;
		return this;
	}

	final void operator+=(int a)
	{
		this+=a;
	}

	final void operator-=(int a)
	{
		this-=a;
	}

	final void operator*=(int a)
	{
		this*=a;
	}
	
	final void operator/=(int a)
	{
		this/=a;
	}
	
	final void operator%=(int a)
	{
		this%=a;
	}

	final friend int operator neg(int a)
	{
		return -a;
	}

	final void operator++()
	{
		this++;
	}

	final void operator--()
	{
		this--;
	}

	final friend int operator+(int a,int b) 
	{
		return a+b;
	}

	final friend int operator-(int a,int b)
	{
		return a-b;
	}

	final friend int operator*(int a,int b)
	{
		return a*b;
	}

	final friend int operator/(int a,int b)
	{
		return a/b;
	}

	final friend int operator%(int a,int b)
	{
		return a%b;
	}

	final friend bool operator<(int a,int b)
	{
		return a<b;
	}

	final friend bool operator<=(int a,int b)
	{
		return a<=b;
	}

	final friend bool operator==(int a,int b)
	{
		return a==b;
	}

	final friend bool operator!=(int a,int b)
	{
		return a!=b;
	}

	final friend bool operator>(int a,int b)
	{
		return a>b;
	}

	final friend bool operator>=(int a,int b)
	{
		return a>=b;
	}

	final friend bool operator!(int a)
	{
		return !a;
	}

	final friend bool operator&&(int a,int b)
	{
		return a&&b;
	}

	final friend bool operator||(int a,int b)
	{
		return a||b;
	}
	
	int abs()
	{
		if this<0
			return -this
		return this
	}

	void set(int a)
	{
		this=a
	}

	void clear()
	{
		this=0
	}

	bool empty()
	{
		return 0==this
	}

	void print()
	{
		rf.print(this)
	}

	void printl()
	{
		rf.printl(this)
	}
}
﻿class int64
{
	rd64 m_in

	final ~int64()
	{
	}

	final int64()
	{
	}

	final int64(int64 a)
	{
		this=a;
	}

	final int64(int64& a)
	{
		this=a;
	}

	final int64(int a)
	{
		this=a;
	}

	final int64(uint a)
	{
		this=a;
	}
	
	TYPE to<TYPE>()
	{
		xf.print("error\n")
	}
	
	template<>
	int to<int>()
	{
		return toint
	}
	
	template<>
	uint to<uint>()
	{
		return toint.touint
	}
	
	template<>
	char to<char>()
	{
		return toint.tochar
	}
	
	template<>
	ushort to<ushort>()
	{
		return toint.toushort
	}

	final int toint()
	{
		return (int)this;
	}

	rstr torstr()
	{
		rstr ret(this)
		return ret
	}

	final void operator=(int64 a)
	{
		this=a;
	}

	final void operator=(int64& a)
	{
		this=a;
	}

	friend operator<->(int64& a,int64& b)
	{
		c=a
		a=b
		b=c
	}

	final void operator+=(int64 a)
	{
		this+=a;
	}

	final void operator-=(int64 a)
	{
		this-=a;
	}

	final void operator*=(int64 a)
	{
		this*=a;
	}
	
	final void operator/=(int64 a)
	{
		this/=a;
	}
	
	void operator%=(int64 a)
	{
		this=this%a
	}

	void operator++()
	{
		this+=1
	}

	void operator--()
	{
		this-=1
	}

	friend int64 operator+(int64 a,int64 b) 
	{
		a+=b
		return a
	}

	friend int64 operator-(int64 a,int64 b)
	{
		a-=b
		return a
	}
	
	friend int64 operator*(int64 a,int64 b)
	{
		a*=b
		return a
	}

	friend int64 operator/(int64 a,int64 b)
	{
		a/=b
		return a
	}
	
	//todo
	friend int64 operator%(int64 a,int64 b)
	{
		return a-a/b*b
	}
	
	final friend bool operator<(int64 a,int64 b)
	{
		return a<b;
	}

	friend bool operator<=(int64 a,int64 b)
	{
		return a<b||a==b;
	}

	final friend bool operator==(int64 a,int64 b)
	{
		return a==b;
	}

	friend bool operator!=(int64 a,int64 b)
	{
		return !(a==b)
	}

	friend bool operator>(int64 a,int64 b)
	{
		return b<a;
	}

	friend bool operator>=(int64 a,int64 b)
	{
		return b<=a;
	}
	
	friend int64 operator neg(int64 a)
	{
		return 0-a;
	}

	void clear()
	{
		this=0
	}

	bool empty()
	{
		return 0==this
	}

	/*print()
	{
		rf.print this
	}

	printl()
	{
		rf.printl this
	}*/
}
﻿class rp<T>
{
	rdp m_in

	final ~rp<T>()
	{
	}

	final rp<T>()
	{
	}

	final rp<T>(rp<T> a)
	{
		this=a;
	}

	final rp<T>(rp<T>& a)
	{
		this=a;
	}

	final TYPE to<TYPE>()
	{
		return (TYPE)this;
	}
	
	template<>
	char to<char>()
	{
		return toint.tochar
	}
	
	template<>
	ushort to<ushort>()
	{
		return toint.toushort
	}
	
	template<>
	int64 to<int64>()
	{
		return toint.toint64
	}

	final int toint()
	{
		return (int)this;
	}

	final uint touint()
	{
		return (uint)this;
	}

	final void operator=(rp<T> a)
	{
		this=a;
	}

	final void operator=(rp<T>& a)
	{
		this=a;
	}
	
	/*void operator=(int a)
	{
		mov esi,this
		mov [esi],a
	}*/

	final T& operator*()
	{
		//return *(T R_P)this;
	}
	
	//指针再取地址只能返回空指针，否则会产生递归定义
	final rp<void> operator&()
	{
		return this;
	}

	final void operator++()
	{
		this=((CHAR*)this)+R_SIZE(T);
	}

	final void operator--()
	{
		this=((CHAR*)this)-R_SIZE(T);
	}

	final void operator+=(int a)
	{
		this=((CHAR*)this)+R_SIZE(T)*a;
	}

	final void operator+=(uint a)
	{
		this=((CHAR*)this)+R_SIZE(T)*a;
	}

	final void operator-=(int a)
	{
		this=((CHAR*)this)-R_SIZE(T)*a;
	}

	final void operator-=(uint a)
	{
		this=((CHAR*)this)-R_SIZE(T)*a;
	}

	final T& operator[](int a)
	{
		return *(T R_P)(((CHAR*)this)+R_SIZE(T)*a);
	}

	final T& operator[](uint a)
	{
		return ((CHAR*)this)+R_SIZE(T)*a;
	}

	final friend rp<T> operator+(rp<T> a,int b)
	{
		return ((CHAR*)a)+R_SIZE(T)*b;
	}

	final friend rp<T> operator+(rp<T> a,uint b)
	{
		return ((CHAR*)a)+R_SIZE(T)*b;
	}

	final friend rp<T> operator-(rp<T> a,int b)
	{
		return ((CHAR*)a)-R_SIZE(T)*b;
	}

	final friend rp<T> operator-(rp<T> a,uint b)
	{
		return ((CHAR*)a)-R_SIZE(T)*b;
	}

	final friend int operator-(rp<T> a,rp<T> b)
	{
		return ((CHAR*)a-(CHAR*)b)/R_SIZE(T);
	}

	final friend bool operator<(rp<T> a,rp<T> b)
	{
		return a<b;
	}

	final friend bool operator<=(rp<T> a,rp<T> b)
	{
		return a<=b;
	}

	final friend bool operator>(rp<T> a,rp<T> b)
	{
		return a>b;
	}

	final friend bool operator>=(rp<T> a,rp<T> b)
	{
		return a>=b;
	}

	final friend bool operator==(rp<T> a,rp<T> b)
	{
		return a==b;
	}

	final friend bool operator!=(rp<T> a,rp<T> b)
	{
		return a!=b;
	}

	bool empty()
	{
		mov esi,this
		cesb [esi],0
		mov s_ret,ebx
	}

	void clear()
	{
		mov esi,this
		mov [esi],0
	}

	void print()
	{
		rf.print(this.touint)
	}

	void printl()
	{
		rf.printl(this.touint)
	}
}
﻿class uint
{
	rd32 m_in

	enum
	{
		c_min=0,
		c_max=0xffffffff,
	}

	final ~uint()
	{
	}

	final uint()
	{
	}

	final uint(uint a)
	{
		this=a;
	}

	final uint(uint& a)
	{
		this=a;
	}

	final uint(int a)
	{
		this=a;
	}

	final uint(char a)
	{
		this=(uchar)a;
	}

	final TYPE to<TYPE>()
	{
		return (TYPE)this;
	}
	
	template<>
	final char to<char>()
	{
		return (char)((uchar)this);
	}
	
	template<>
	final ushort to<ushort>()
	{
		return (ushort)this;
	}
	
	template<>
	final int64 to<int64>()
	{
		return this;
	}

	final int toint()
	{
		return this;
	}

	final uint touint()
	{
		return this;
	}

	rstr torstr()
	{
		rstr ret(this)
		return ret
	}

	final void operator=(uint a)
	{
		this=a;
	}

	final void operator=(uint& a)
	{
		this=a;
	}

	friend operator<->(uint& a,uint& b)
	{
		c=a
		a=b
		b=c
	}

	final void operator+=(uint a)
	{
		this+=a;
	}

	final void operator-=(uint a)
	{
		this-=a;
	}

	final void operator*=(uint a)
	{
		this*=a;
	}

	final void operator/=(uint a)
	{
		this/=a;
	}

	final void operator%=(uint a)
	{
		this%=a;
	}

	final void operator++()
	{
		this++;
	}

	final void operator--()
	{
		this--;
	}

	final friend uint operator+(uint a,uint b) 
	{
		return a+b;
	}

	final friend uint operator-(uint a,uint b)
	{
		return a-b;
	}

	final friend uint operator*(uint a,uint b)
	{
		return a*b;
	}

	final friend uint operator/(uint a,uint b)
	{
		return a/b;
	}

	final friend uint operator%(uint a,uint b)
	{
		return a%b;
	}

	final friend bool operator<(uint a,uint b)
	{
		return a<b;
	}

	final friend bool operator<=(uint a,uint b)
	{
		return a<=b;
	}

	final friend bool operator==(uint a,uint b)
	{
		return a==b;
	}

	final friend bool operator!=(uint a,uint b)
	{
		return a!=b;
	}

	final friend bool operator>(uint a,uint b)
	{
		return a>b;
	}

	final friend bool operator>=(uint a,uint b)
	{
		return a>=b;
	}

	/*void set(uint a)
	{
		mov esi,this
		mov [esi],a
	}

	void clear()
	{
		mov esi,this
		mov [esi],0
	}

	bool empty()
	{
		return 0==this
	}*/

	/*void print()
	{
		rf.print this
	}

	void printl()
	{
		rf.printl this
	}*/
}
﻿class ushort
{
	rd16 m_in

	~ushort()
	{
	}

	ushort()
	{
	}

	final ushort(ushort& a)
	{
		this=a;
	}

	final ushort(ushort a)
	{
		this=a;
	}
	
	ushort(char a)
	{
		this=a.toint
	}
	
	/*short toshort()
	{
		mov esi,this
		mov1 s_ret,[esi]
		mov1 [ebp+(s_off s_ret+1)],[esi+1]
	}*/
	
	TYPE to<TYPE>()
	{
		xf.print("error\n")
	}
	
	template<>
	int to<int>()
	{
		return toint
	}
	
	template<>
	uint to<uint>()
	{
		return touint
	}

	final int toint()
	{
		return this;
	}

	final uint touint()
	{
		return this;
	}

	rstr torstr()
	{
		rstr ret(this.toint)
		return ret
	}

	final void operator=(ushort& a)
	{
		this=a;
	}

	final void operator=(ushort a)
	{
		this=a;
	}
	
	final void operator=(int a)
	{
		this=a;
	}

	final void operator=(uint a)
	{
		this=a;
	}
	
	//void operator=(uint a)
	//{

	void operator++()
	{
		this=toint+1
	}

	void operator--()
	{
		this=toint-1
	}

	friend operator<->(ushort& a,ushort& b)
	{
		c=a
		a=b
		b=c
	}

	friend bool operator==(ushort a,ushort b)
	{
		return a.toint==b.toint
	}

	friend bool operator!=(ushort a,ushort b)
	{
		return a.toint!=b.toint
	}

	friend bool operator>(ushort a,ushort b)
	{
		return a.toint>b.toint
	}

	friend bool operator>=(ushort a,ushort b)
	{
		return a.toint>=b.toint
	}

	friend bool operator<(ushort a,ushort b)
	{
		return a.toint<b.toint
	}

	friend bool operator<=(ushort a,ushort b)
	{
		return a.toint<=b.toint
	}

	void clear()
	{
		this=0
	}

	bool empty()
	{
		return this.toint==0
	}

	/*print()
	{
		rf.print this.torstr
	}

	printl()
	{
		rf.printl this.torstr
	}*/
}
﻿#include "rp.rs"
#include "char.rs"
#include "int.rs"
#include "uint.rs"
#include "ushort.rs"
#include "int64.rs"
#include "double.rs"
#include "float.rs"

#include "ralgo.h"
#include "rbuf.h"
#include "rstr.h"
#include "rstrw.h"
#include "rcode.h"
#include "rf.h"
//#include "rmutex.h"

#define vector rbuf
#define string rstr
#define bool int
#define rbool int
#define long int64
#define uchar char
#define wchar ushort
#define r_size sizeof
#define r_move
#define r_ceil_div(a,b) r_cond(0==(a)%(b),(a)/(b),(a)/(b)+1)

#define r_max(a,b) r_cond(a>b,a,b)
#define r_min(a,b) r_cond(a<b,a,b)

/*#define r_to_int(a) ((int)(a))
#define r_to_uint(a) ((uint)(a))
#define r_to_char(a) ((char)(a))
#define r_to_uchar(a) ((uchar)(a))
#define r_to_int8(a) ((int8)(a))
#define r_to_double(a) ((double)(a))

#define r_to_pint(a) ((int*)(a))
#define r_to_puint(a) ((uint*)(a))
#define r_to_pchar(a) ((char*)(a))
#define r_to_puchar(a) ((uchar*)(a))
#define r_to_pint8(a) ((int8*)(a))
#define r_to_pdouble(a) ((double*)(a))
#define r_to_prstr(a) ((rstr*)(a))*/

#define true 1
#define false 0

#define null 0p
#define NULL 0p

#define elif else if
#define while for
#define default else
#define namespace friend class
#define goto jmp
#define struct class
#define static friend
#define const
#define inline
#define asm
#define auto
#define then
#define volatile
#define register
#define signed
#define unsigned
#define operator
#define typename

#define <- =
#define :: .

//与do...while相反
mac until(a)
{
	if(a)
	{
		break;
	}
}

mac$ @ _word ( _mword )
{
	stdcall[#$0,$1]
}

mac$ @@ _word ( _mword )
{
	cdecl[#$0,$1]
}

cfunc void main_c()
{
	sub esp,4
	call &main
	add esp,4
}

int r_cond(bool cond,int a,int b)
{
	if(cond)
	{
		return a
	}
	return b
}

T r_cond<T>(bool cond,T a,T b)
{
	if(cond)
	{
		return a
	}
	return b
}

char r_char(rstr s)
{
	return s[0]
}

void print(rstr s)
{
	rf.print(s);
}

void printl(rstr s=rstr())
{
	rf.printl(s);
}

void* findf(rstr s)
{
	return xf.find_func(s.cstr)
}

//推荐使用函数进行位运算，
//如果一定要使用位运算符请自行DIY位运算符和优先级
final int NOT(int a)
{
	return ~a;
}

final int AND(int a,int b)
{
	return a R_AND b;
}

final int OR(int a,int b)
{
	return a R_OR b;
}

int ORM(int num)
{
	rstr temp=num
	int* p=&num+1
	int ret=*p
	p++
	for(i=1;i<num;i++)
		ret=OR(ret,*p)
		p++
	return ret
}

final int XOR(int a,int b)
{
	return a R_XOR b;
}

final int SHL(int a,int b)
{
	return (uint)a R_LL (uint)b;
}

final int SHR(int a,int b)
{
	return (uint)a R_RR (uint)b;
}

final int SAR(int a,int b)
{
	return a R_RR b;
}

rbuf<T> array<T>(int num)
{
	rbuf<T> result
	T* p=&num+1
	for(i=0;i<num;i++)
	{
		result.push(*p)
		T.~T(*p)
		p++
	}
	return result
}

int stdcall(int count)
{
	count4=count*4
	char* name=(*(&count+1)).to<char*>
	pret=&count+count+1
	pfunc=xf.find_dll_func(name)
	if pfunc==null
		printl(name)
		return 0
	pstart=&count
	
	mov ebx,count
	sub ebx,1
	mov ecx,count4
	mov esi,pstart
	add esi,ecx
next:
	jebxz end
	push [esi]
	sub ebx,1
	sub esi,4
	jmp next
end:
	call pfunc
	mov edi,pret
	mov [edi],eax

	mov ecx,4
	imul ecx,count
	add ecx,4
	pop ebp
	add esp,sizeof(s_local)
	mov eax,[esp]
	_reti(eax,ecx)
}

void __declare()
{
	//todo:
	rbuf<char*> temp
}
﻿import xlib/gpp/xbase.rs

namespace xf
{
	enum
	{
		X_SEEK_SET=0,
		X_SEEK_END=2,
	};

	final void print(const char* s)
	{
		printf("%s",s);
	}

	final void vsnprintf(char* dst,int count,const char* f,char* args)
	{
		_vsnprintf((CHAR*)dst,count,(CHAR*)f,(va_list)args);
	}

	final void sscanf(const char* src,const char* f,uint* n)
	{
		sscanf((CHAR*)src,(CHAR*)f,n);
	}
	
	final void sprintf(char* dst,char* format,int n)
	{
		push n
		push format
		push dst
		calle "sprintf"
		add esp,12
	}

	final void sprintf(char* dst,char* format,uint n)
	{
		push n
		push format
		push dst
		calle "sprintf"
		add esp,12
	}
	
	final void sprintf(char* dst,char* format,int64 n)
	{
		lea esi,[ebp+s_off n]
		push [esi+4]
		push [esi]
		push format
		push dst
		calle "sprintf"
		add esp,16
	}

	final void sprintf(char* dst,char* format,double n)
	{
		sprintf(dst,format,n);
	}

	final void itoa(void* dst,int n)
	{
		sprintf((CHAR*)dst,"%d",n);
	}

	final void utoa(void* dst,uint n)
	{
		sprintf((CHAR*)dst,"%u",n);
	}

	final void dtoa(void* dst,double n)
	{
		sprintf((CHAR*)dst,"%f",n);
	}

	final void int64toa(void* dst,int64 n)
	{
		sprintf((CHAR*)dst,"%I64d",n);
	}

	int atoi(char* s)
	{
		int result;
		sscanf(s,"%d",&result);
		return result;
	}

	uint atou(char* s)
	{
		uint result;
		sscanf(s,"%u",&result);
		return result;
	}

	double atod(char* s)
	{
		double result;
		sscanf(s,"%lf",&result);
		return result;
	}

	int64 atoint64(char* s)
	{
		int64 result;
		sscanf(s,"%I64d",&result);
		return result;
	}

	final void exit(int a)
	{
		exit(a);
	}

	final uchar* malloc(int size)
	{
		/*uchar* temp=malloc(size);
		printf("malloc %x %d\n",temp,size);
		return temp;*/
		//printf("malloc %d\n",size);
		return malloc(size);
	}

	final void free(void* p)
	{
		//printf("free %x\n",p);
		free(p);
	}

	final void memcpy(void* dst,const void* src,int size)
	{
		memcpy(dst,src,size);
	}

	final int strlen(const char* s)
	{
		return strlen((CHAR*)s);
	}

	int strlenw(const wchar* p)
	{
		int ret=0;
		while(*p!=0)
		{
			ret++;
			p++;
		}
		return ret;
	}

	final int tick()
	{
		return GetTickCount();
	}

	final void sleep(int milliseconds)
	{
		push milliseconds
		calle "Sleep"
	}

	final int getch()
	{
		return getch();
	}

	/*static void srand()
	{
		::srand((uint)::time(null));
	}

	static int rand()
	{
		return ::rand();
	}*/

	final int cmd(const char* p)
	{
		push p
		calle "system"
		mov s_ret,eax
		add esp,4
	}

	final int get_exe_name(wchar* buf,int size)
	{
		return GetModuleFileNameW(0,(wchar_t*)buf,size);
	}

	final int get_cur_dir(wchar* buf,int size)
	{
		return GetCurrentDirectoryW(size,(wchar_t*)buf);
	}

	/*static int64 get_file_update_time(wchar* path)
	{
#ifdef _MSC_VER
		int64 ft;
		HANDLE hFile=::CreateFileW(path,
			GENERIC_READ,
			FILE_SHARE_READ,
			null,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			null);
		if(hFile==INVALID_HANDLE_VALUE)
			return 0;
		if(!::GetFileTime(hFile,null,null,(FILETIME*)&ft))
			return 0;
		::CloseHandle(hFile);
		return ft;
#else
		return 0;
		/*struct stat buf;
		int ret=stat(path,&buf);
		if(0!=ret)
		{
			return false;
		}
		*ft=(int64)buf.st_mtime;
		return true;*/
#endif
	}*/

	final int get_exe_size(uchar* data)
	{
		/*PIMAGE_DOS_HEADER dos_head=(PIMAGE_DOS_HEADER)data;
		PIMAGE_OPTIONAL_HEADER op_head=(PIMAGE_OPTIONAL_HEADER)(
			data+dos_head->e_lfanew+4+20);
		PIMAGE_FILE_HEADER file_head=(PIMAGE_FILE_HEADER)(
			data+dos_head->e_lfanew+4);
		PIMAGE_SECTION_HEADER sec=(PIMAGE_SECTION_HEADER)(
			data+dos_head->e_lfanew+r_size(IMAGE_NT_HEADERS));
		int size=op_head->SizeOfHeaders;
		for(int i=0;i<file_head->NumberOfSections;i++)
		{
			size+=sec[i].SizeOfRawData;
		}
		return size;*/
	}
	
	final int ftell(void* fp)
	{
		return ftell((FILE*)fp);
	}

	int64 ftell64(void* fp)
	{
		return ftell(fp)
	}
	
	final int fseek(void* fp,int off,int start)
	{
		return fseek((FILE*)fp,off,start);
	}

	int fseek64(void* fp,int64 off,int start)
	{
		return fseek(fp,off.toint,start)
	}

	final void* _wfopen(wchar* name,wchar* mode)
	{
		return _wfopen((wchar_t*)name,(wchar_t*)mode);
	}

	final int fclose(void* fp)
	{
		return fclose((FILE*)fp);
	}

	final int fread(void* buf,int size,int count,void* fp)
	{
		return fread(buf,size,count,(FILE*)fp);
	}

	final int fwrite(const void* buf,int size,int count,void* fp)
	{
		return fwrite(buf,size,count,(FILE*)fp);
	}

	final int _wremove(wchar* name)
	{
		return _wremove((wchar_t*)name);
	}

	final int rename(wchar* oldname,wchar* newname)
	{
		push newname
		push oldname
		calle "_wrename"
		add esp,8
		mov s_ret,eax
		//return 0==::_wrename(oldname,newname);
	}

	final int create_thr(void* start,void* param=null)
	{
		int tid=_beginthreadex(null,0,start,param,0,null);
		if(0==tid||1==tid)
		{
			return 0;
		}
		else
		{
			return tid;
		}
	}

	final void wait_thr(int tid)
	{
		WaitForSingleObject(tid,-1);
	}

	final int gbk_to_utf16(const char* src,wchar* dst,int count)
	{
		return MultiByteToWideChar(936,0,(CHAR*)src,-1,(wchar_t*)dst,count);
	}

	final int utf16_to_gbk(const wchar* src,char* dst,int buf_size)
	{
		return WideCharToMultiByte(936,0,(wchar_t*)src,-1,(CHAR*)dst,buf_size,0,0);
	}

	final uchar* alloc_v(int len)
	{
		return 0;
#ifdef _MSC_VER
		return (uchar*)VirtualAlloc(null,len,
			MEM_COMMIT,PAGE_EXECUTE_READWRITE);
#endif
	}

	final void free_v(uchar* addr)
	{
#ifdef _MSC_VER
		VirtualFree(addr,0,MEM_RELEASE);
#endif
	}
	
	final char* GetCommandLineA()
	{
		return GetCommandLineA();
	}
	
	final void* FindFirstFileW(wchar* name,void* wfd)
	{
		return FindFirstFileW((wchar_t*)name,(WIN32_FIND_DATAW*)wfd);
	}

	final rbool FindNextFileW(void* handle,void* wfd)
	{
		return FindNextFileW(handle,(WIN32_FIND_DATAW*)wfd);
	}

	final void FindClose(void* handle)
	{
		FindClose(handle);
	}
	
	final void InitializeCriticalSection(void* p)
	{
		push p
		calle "InitializeCriticalSection"
	}
	
	final void DeleteCriticalSection(void* p)
	{
		push p
		calle "DeleteCriticalSection"
	}
	
	final void EnterCriticalSection(void* p)
	{
		push p
		calle "EnterCriticalSection"
	}
	
	final void LeaveCriticalSection(void* p)
	{
		push p
		calle "LeaveCriticalSection"
	}
	
	final void* find_func(char* p)
	{
		push p
		calle "find_func"
		mov s_ret,eax
		add esp,4
	}
	
	final void* get_stdin()
	{
		calle "__iob_func"
		mov s_ret,eax
	}

	final void* get_stdout()
	{
		calle "__iob_func"
		add eax,32
		mov s_ret,eax
	}
	
	rstr scanl()
	{
		rstr result;
		result.clear();
		char c;
		void* fp=get_stdin();
		while(1==xf::fread(&c,1,1,fp))
		{
			if(13==c.toint||10==c.toint)
			{
				if(0==result.count())
				{
					continue;
				}
				else
				{
					return result;
				}
			}
			result+=c;
		}
		return result;
	}
	
	final int _beginthreadex(void* _Security,int _StackSize,
		void* start,void* _ArgList,int _InitFlag,void* addr)
	{
		push addr
		push _InitFlag
		push _ArgList
		push start
		push _StackSize
		push _Security
		calle "_beginthreadex"
		add esp,24
		mov s_ret,eax
	}
	
	final void WaitForSingleObject(int handle,int milliseconds)
	{
		push milliseconds
		push handle
		calle "WaitForSingleObject"
	}

	final bool CloseHandle(int handle)
	{
		push handle
		calle "CloseHandle"
		mov s_ret,eax
	}
	
	final void* find_dll_func(rstr s)
	{
		return find_dll_func(s.cstr)
	}

	final void* find_dll_func(char* p)
	{
		push p
		calle "find_dll"
		mov s_ret,eax
		add esp,4
	}
}

#define FILE_ATTRIBUTE_DIRECTORY 0x00000010

struct R_WIN32_FIND_DATAW
{
	int dwFileAttributes;
	int64 ftCreationTime;
	int64 ftLastAccessTime;
	int64 ftLastWriteTime;
	int nFileSizeHigh;
	int nFileSizeLow;
	int dwReserved0;
	int dwReserved1;
	wchar cFileName[260];
	wchar cAlternateFileName[14];
};

struct R_CRITICAL_SECTION
{
	char buf[24];
};
﻿class char
{
	rd8 m_in

	~char()
	{
	}

	char()
	{
	}

	char(char& a)
	{
		mov esi,this
		mov edi,a
		movb [esi],[edi]
	}

	char(char a)
	{
		mov esi,this
		movb [esi],a
	}
	
	TYPE to<TYPE>()
	{
		xf.print("error\n")
	}
	
	template<>
	uint to<uint>()
	{
		return touint
	}
	
	template<>
	int to<int>()
	{
		return toint
	}
	
	template<>
	ushort to<ushort>()
	{
		return toint.toushort
	}
	
	template<>
	int64 to<int64>()
	{
		return toint.toint64
	}

	int toint()
	{
		mov esi,this
		mov s_ret,0
		movb s_ret,[esi]
	}

	uint touint()
	{
		mov esi,this
		mov s_ret,0
		movb s_ret,[esi]
	}

	/*rstr torstr()
	{
		rstr ret(this)
		return ret
	}*/

	char tochar()
	{
		mov esi,this
		movb s_ret,[esi]
	}

	void operator=(char& a)
	{
		mov esi,this
		mov edi,a
		movb [esi],[edi]
	}

	void operator=(char a)
	{
		mov esi,this
		movb [esi],a
	}
	
	void operator=(int a)
	{
		mov esi,this
		movb [esi],a
	}

	void operator=(uint a)
	{
		mov esi,this
		movb [esi],a
	}

	void operator++()
	{
		this=toint+1
	}

	friend operator<->(char& a,char& b)
	{
		c=a
		a=b
		b=c
	}

	friend bool operator==(char a,char b)
	{
		return a.toint==b.toint
	}

	friend bool operator!=(char a,char b)
	{
		return a.toint!=b.toint
	}

	friend bool operator>(char a,char b)
	{
		return a.toint>b.toint
	}

	friend bool operator>=(char a,char b)
	{
		return a.toint>=b.toint
	}

	friend bool operator<(char a,char b)
	{
		return a.toint<b.toint
	}

	friend bool operator<=(char a,char b)
	{
		return a.toint<=b.toint
	}

	void set(char a)
	{
		mov esi,this
		movb [esi],a
	}

	void set(int a)
	{
		mov esi,this
		movb [esi],a
	}

	void clear()
	{
		set(0)
	}

	bool empty()
	{
		return this.toint==0
	}

	/*void print()
	{
		rf.print this.torstr
	}

	void printl()
	{
		rf.printl this.torstr
	}*/
}
﻿class double
{
	rd64 m_in

	~double()
	{
	}

	double()
	{
	}

	double(double a)
	{
		mov esi,this
		mov [esi],[ebp+s_off a]
		mov [esi+4],[ebp+(s_off a+4)]
	}

	double(double& a)
	{
		mov edi,this
		mov esi,a
		mov [edi],[esi]
		mov [edi+4],[esi+4]
	}
	
	//这个整数转浮点很慢
	double(int a)
	{
		rstr s(a)
		xf.sscanf(s.cstr,"%lf",&this)
	}

	double(uint a)
	{
		rstr s(a)
		xf.sscanf(s.cstr,"%lf",&this)
	}

	int toint()
	{
		rbuf<char> buf(128)
		xf.sprintf8(buf.begin,"%.0lf",this)
		return rstr(buf.begin).toint
	}

	rstr torstr()
	{
		rstr ret(this)
		return ret
	}
	
	friend double operator neg(double a)
	{
		return 0.0-a;
	}

	void operator=(double a)
	{
		mov esi,this
		mov [esi],[ebp+s_off a]
		mov [esi+4],[ebp+(s_off a+4)]
	}

	void operator=(double& a)
	{
		mov edi,this
		mov esi,a
		mov [edi],[esi]
		mov [edi+4],[esi+4]
	}

	friend operator<->(double& a,double& b)
	{
		c=a
		a=b
		b=c
	}

	void operator+=(double a)
	{
		lea esi,a
		push esi
		push this
		calle "faddl",8
		add esp,8
	}

	void operator-=(double a)
	{
		lea esi,a
		push esi
		push this
		calle "fsubl",8
		add esp,8
	}

	void operator*=(double a)
	{
		lea esi,a
		push esi
		push this
		calle "fmull",8
		add esp,8
	}
	
	void operator/=(double a)
	{
		lea esi,a
		push esi
		push this
		calle "fdivl",8
		add esp,8
	}

	friend double operator+(double a,double b) 
	{
		a+=b
		return a
	}

	friend double operator-(double a,double b)
	{
		a-=b
		return a
	}

	friend double operator*(double a,double b)
	{
		a*=b
		return a
	}

	friend double operator/(double a,double b)
	{
		a/=b
		return a
	}

	friend bool operator<(double a,double b)
	{
		lea esi,b
		push esi
		lea esi,a
		push esi
		calle "fclsbl",9
		mov s_ret,eax
		add esp,8
	}

	friend bool operator<=(double a,double b)
	{
		return a<b||a==b;
	}

	friend bool operator==(double a,double b)
	{
		cesb a,b
		if (ebx)
		{
			cesb [ebp+(s_off a+4)],[ebp+(s_off b+4)]
		}
		mov s_ret,ebx
	}

	friend bool operator!=(double a,double b)
	{
		return !(a==b)
	}

	friend bool operator>(double a,double b)
	{
		return b<a;
	}

	friend bool operator>=(double a,double b)
	{
		return a>b||a==b;
	}
	
	double abs()
	{
		if this<0.0
			return 0.0-this
		return this
	}

	void clear()
	{
		mov esi,this
		mov [esi],0
		mov [esi+4],0
	}

	bool empty()
	{
		return 0==this
	}

	/*print()
	{
		rf.print this
	}

	printl()
	{
		rf.printl this
	}*/
}
﻿
import front/ybase.h

bool evalue(rstr s)
{
	return eval(s,get_up_func,get_up_ebp)
}

bool eval(rstr s,tfunc* ptfi=null,int vebp=0)
{
	return eval_in(s.cstr,ptfi,vebp)
}

bool eval_in(char* s,tfunc* ptfi,int vebp)
{
	push vebp
	push ptfi
	push s
	calle "eval"
	mov s_ret,eax
	add esp,12
}

bool eval_vstr(rbuf<rstr>* vstr,tfunc* ptfi,int vebp)
{
	push vebp
	push ptfi
	push vstr
	calle "eval_vstr"
	mov s_ret,eax
	add esp,12
}

define get_up_func get_up_func_in(ebp,sizeof(s_local))
define get_cur_ebp ebp

mac get_up_ebp 
{
	(*ebp.to<int*>)
}

tfunc* get_up_func_in(int v_ebp,int local_size)
{
	return get_cur_func_in(*(v_ebp+local_size+4).to<int*>);
}

tfunc* get_cur_func()
{
	mov ecx,[ebp+4]
	return get_cur_func_in(ecx)
}

tfunc* get_cur_func_in(int pasm)
{
	push pasm
	calle "get_cur_func"
	mov s_ret,eax
	add esp,4
}

tfunc* findfunc(rstr name)
{
	p=findf(name)
	if p==null
		return null
	return get_cur_func_in(p.toint)
}

dynamic bool and(rbuf<rbuf<rstr>>* p,tfunc* ptfi,int vebp)
{
	for i=0;i<p->count;i++
		rbuf<rstr> v
		v.push('return')
		v+=(*p)[i]
		ifn eval_vstr(&v,ptfi,vebp)
			return false
	return true
}

dynamic bool or(rbuf<rbuf<rstr>>* p,tfunc* ptfi,int vebp)
{
	for i=0;i<p->count;i++
		rbuf<rstr> v
		v.push('return')
		v+=(*p)[i]
		if eval_vstr(&v,ptfi,vebp)
			return true
	return false
}
﻿class float
{
	rd32 m_in
	
	~float()
	{
	}

	float()
	{
	}

	float(float a)
	{
		mov esi,[esp+4]
		mov [esi],[esp+8]
	}

	float(float& a)
	{
		mov edi,[esp+4]
		mov esi,[esp+8]
		mov [edi],[esi]
	}
	
	double todouble()
	{
		return double(this)
	}
	
	int toint()
	{
		return todouble.toint
	}

	rstr torstr()
	{
		rstr ret(this)
		return ret
	}
	
	friend float operator neg(float a)
	{
		return (0.0-a).tofloat
	}
	
	void operator=(float a)
	{
		mov esi,[esp+4]
		mov [esi],[esp+8]
	}

	void operator=(float& a)
	{
		mov edi,[esp+4]
		mov esi,[esp+8]
		mov [edi],[esi]
	}
	
	void operator=(double a)
	{
		this=a.tofloat
	}
	
	void operator+=(float a)
	{
		this=this+a
	}

	void operator-=(float a)
	{
		this=this-a
	}

	void operator*=(float a)
	{
		this=this*a
	}
	
	void operator/=(float a)
	{
		this=this/a
	}

	friend float operator+(float a,float b) 
	{
		return (double(a)+double(b)).tofloat
	}

	friend float operator-(float a,float b)
	{
		return (double(a)-double(b)).tofloat
	}

	friend float operator*(float a,float b)
	{
		return (double(a)*double(b)).tofloat
	}

	friend float operator/(float a,float b)
	{
		return (double(a)/double(b)).tofloat
	}

	friend bool operator<(float a,float b)
	{
		return double(a)<double(b)
	}

	friend bool operator<=(float a,float b)
	{
		return a<b||a==b;
	}

	friend bool operator==(float a,float b)
	{
		cesb a,b
		mov s_ret,ebx
	}

	friend bool operator!=(float a,float b)
	{
		return !(a==b)
	}

	friend bool operator>(float a,float b)
	{
		return double(a)>double(b)
	}

	friend bool operator>=(float a,float b)
	{
		return a>b||a==b;
	}
	
	float abs()
	{
		if this<0.0
			return neg this
		return this
	}

	void clear()
	{
		mov esi,this
		mov [esi],0
	}

	bool empty()
	{
		return 0==*(&this).to<int*>
	}

	/*print()
	{
		rf.print rstr(this)
	}

	printl()
	{
		rf.printl rstr(this)
	}*/
}﻿class int
{
	rd32 m_in

	enum
	{
		c_min=4294967295,
		c_max=0x7fffffff
	}

	~int()
	{
	}

	int()
	{
	}

	int(int a)
	{
		mov esi,[esp+4]
		mov [esi],[esp+8]
		//mov esi,this
		//mov [esi],a
	}

	int(int& a)
	{
		mov edi,[esp+4]
		mov esi,[esp+8]
		mov [edi],[esi]
		//mov edi,this
		//mov esi,a
		//mov [edi],[esi]
	}

	int(char a)
	{
		mov edi,this
		mov [edi],0
		movb [edi],a
	}

	int(ushort a)
	{
		mov edi,this
		mov [edi],0
		movb [edi],a
		movb [edi+1],[ebp+(s_off a+1)]
	}

	TYPE to<TYPE>()
	{
		mov esi,this
		mov s_ret,[esi]
	}
	
	template<>
	char to<char>()
	{
		return tochar()
	}
	
	template<>
	ushort to<ushort>()
	{
		return toushort
	}
	
	template<>
	int64 to<int64>()
	{
		return toint64
	}

	ushort toushort()
	{
		mov esi,this
		movb s_ret,[esi]
		movb [ebp+(s_off s_ret+1)],[esi+1]
	}

	int toint()
	{
		mov esi,this
		mov s_ret,[esi]
	}

	uint touint()
	{
		mov esi,this
		mov s_ret,[esi]
	}
	
	int64 toint64()
	{
		int64 ret(this)
		return ret
	}
	
	double todouble()
	{
		double ret(this)
		return ret
	}

	rstr torstr()
	{
		rstr ret(this)
		return ret
	}
	
	char tochar()
	{
		mov esi,this
		movb s_ret,[esi]
	}

	void operator=(int a)
	{
		mov esi,[esp+4]
		mov [esi],[esp+8]
		//mov esi,this
		//mov [esi],a
	}

	void operator=(int& a)
	{
		mov edi,[esp+4]
		mov esi,[esp+8]
		mov [edi],[esi]
		//mov edi,this
		//mov esi,a
		//mov [edi],[esi]
	}

	void operator=(uint a)
	{
		mov esi,this
		mov [esi],a
	}

	friend operator<->(int& a,int& b)
	{
		c=a
		a=b
		b=c
	}

	friend int& operator=>(int a,int& this)
	{
		mov esi,this
		mov [esi],a
		return this
	}

	void operator+=(int a)
	{
		mov esi,[esp+4]
		add [esi],[esp+8]
		//mov esi,this
		//add [esi],a
	}

	void operator-=(int a)
	{
		mov esi,[esp+4]
		sub [esi],[esp+8]
		//mov esi,this
		//sub [esi],a
	}

	void operator*=(int a)
	{
		mov esi,[esp+4]
		imul [esi],[esp+8]
		//mov esi,this
		//imul [esi],a
	}
	
	void operator/=(int a)
	{
		mov esi,[esp+4]
		idiv [esi],[esp+8]
		//mov esi,this
		//idiv [esi],a
	}
	
	void operator%=(int a)
	{
		mov esi,[esp+4]
		imod [esi],[esp+8]
		//mov esi,this
		//imod [esi],a
	}

	friend int operator neg(int a)
	{
		mov esi,0
		sub esi,[esp+4]
		mov [esp+8],esi
		//mov esi,0
		//sub esi,a
		//mov s_ret,esi
		//mov esi,a
		//bnot esi
		//add esi,1
		//mov s_ret,esi
	}

	void operator++()
	{
		mov esi,[esp+4]
		add [esi],1
		//mov esi,this
		//add [esi],1
	}

	void operator--()
	{
		mov esi,[esp+4]
		sub [esi],1
		//mov esi,this
		//sub [esi],1
	}

	friend int operator+(int a,int b) 
	{
		add [esp+4],[esp+8]
		mov [esp+12],[esp+4]
		//add a,b
		//mov s_ret,a
	}

	friend int operator-(int a,int b)
	{
		sub [esp+4],[esp+8]
		mov [esp+12],[esp+4]
		//sub a,b
		//mov s_ret,a
	}

	friend int operator*(int a,int b)
	{
		imul [esp+4],[esp+8]
		mov [esp+12],[esp+4]
		//imul a,b
		//mov s_ret,a
	}

	friend int operator/(int a,int b)
	{
		idiv [esp+4],[esp+8]
		mov [esp+12],[esp+4]
		//idiv a,b
		//mov s_ret,a
	}

	friend int operator%(int a,int b)
	{
		imod [esp+4],[esp+8]
		mov [esp+12],[esp+4]
		//imod a,b
		//mov s_ret,a
	}

	friend bool operator<(int a,int b)
	{
		clsb [esp+4],[esp+8]
		mov [esp+12],ebx
		//clsb a,b
		//mov s_ret,ebx
	}

	friend bool operator<=(int a,int b)
	{
		clesb [esp+4],[esp+8]
		mov [esp+12],ebx
		//clesb a,b
		//mov s_ret,ebx
	}

	friend bool operator==(int a,int b)
	{
		cesb [esp+4],[esp+8]
		mov [esp+12],ebx
		//cesb a,b
		//mov s_ret,ebx
	}

	friend bool operator!=(int a,int b)
	{
		cnesb [esp+4],[esp+8]
		mov [esp+12],ebx
		//cnesb a,b
		//mov s_ret,ebx
	}

	friend bool operator>(int a,int b)
	{
		clsb [esp+8],[esp+4]
		mov [esp+12],ebx
		//clsb b,a
		//mov s_ret,ebx
		//return b<a;
	}

	friend bool operator>=(int a,int b)
	{
		clesb [esp+8],[esp+4]
		mov [esp+12],ebx
		//clesb b,a
		//mov s_ret,ebx
		//return b<=a;
	}

	friend bool operator!(int a)
	{
		cesb [esp+4],0
		mov [esp+8],ebx
		//cesb a,0
		//mov s_ret,ebx
	}

	friend bool operator&&(int a,int b)
	{
		cesb [esp+4],0
		jebxz next
		mov [esp+12],0
		reti 8
next:
		cnesb [esp+8],0
		mov [esp+12],ebx
	}

	friend bool operator||(int a,int b)
	{
		cesb [esp+4],0
		jebxnz next
		mov [esp+12],1
		reti 8
next:
		cnesb [esp+8],0
		mov [esp+12],ebx
	}
	
	int abs()
	{
		if this<0
			return -this
		return this
	}

	void set(int a)
	{
		mov esi,this
		mov [esi],a
	}

	void clear()
	{
		mov esi,this
		mov [esi],0
	}

	bool empty()
	{
		return 0==this
	}

	void print()
	{
		rf.print(this)
	}

	void printl()
	{
		rf.printl(this)
	}
}
﻿class int64
{
	rd64 m_in

	~int64()
	{
	}

	int64()
	{
	}

	int64(int64 a)
	{
		mov esi,this
		mov [esi],[ebp+s_off a]
		mov [esi+4],[ebp+(s_off a+4)]
	}

	int64(int64& a)
	{
		mov edi,this
		mov esi,a
		mov [edi],[esi]
		mov [edi+4],[esi+4]
	}

	int64(int a)
	{
		mov esi,this
		mov [esi],a
		mov [esi+4],0
		mov edi,a
		if(a<0)
		{
			mov esi,this
			mov [esi+4],uint.c_max
		}
	}

	int64(uint a)
	{
		mov esi,this
		mov [esi],a
		mov [esi+4],0
	}
	
	TYPE to<TYPE>()
	{
		xf.print("error\n")
	}
	
	template<>
	int to<int>()
	{
		return toint
	}
	
	template<>
	uint to<uint>()
	{
		return toint.touint
	}
	
	template<>
	char to<char>()
	{
		return toint.tochar
	}
	
	template<>
	ushort to<ushort>()
	{
		return toint.toushort
	}

	int toint()
	{
		mov esi,this
		mov s_ret,[esi]
	}

	rstr torstr()
	{
		rstr ret(this)
		return ret
	}

	void operator=(int64 a)
	{
		mov esi,this
		mov [esi],[ebp+s_off a]
		mov [esi+4],[ebp+(s_off a+4)]
	}

	void operator=(int64& a)
	{
		mov edi,this
		mov esi,a
		mov [edi],[esi]
		mov [edi+4],[esi+4]
	}

	friend operator<->(int64& a,int64& b)
	{
		c=a
		a=b
		b=c
	}

	void operator+=(int64 a)
	{
		lea esi,a
		push esi
		push this
		calle "addl",8
		add esp,8
	}

	void operator-=(int64 a)
	{
		lea esi,a
		push esi
		push this
		calle "subl",8
		add esp,8
	}

	void operator*=(int64 a)
	{
#ifdef _RNASM
		this=this*a
#else
		lea esi,a
		push esi
		push this
		calle "imull",8
		add esp,8
#endif
	}
	
	void operator/=(int64 a)
	{
#ifdef _RNASM
		this=this/a
#else
		lea esi,a
		push esi
		push this
		calle "idivl",8
		add esp,8
#endif
	}
	
	void operator%=(int64 a)
	{
		this=this%a
	}

	void operator++()
	{
		this+=1
	}

	void operator--()
	{
		this-=1
	}

	friend int64 operator+(int64 a,int64 b) 
	{
		a+=b
		return a
	}

	friend int64 operator-(int64 a,int64 b)
	{
		a-=b
		return a
	}
	
	friend int64 operator*(int64 a,int64 b)
	{
#ifdef _RNASM
		mov eax,[ebp+(s_off b+4)]
		push eax
		mov ecx,b
		push ecx
		mov edx,[ebp+(s_off a+4)]
		push edx
		mov eax,a
		push eax
		rn call long_mul
		mov s_ret,eax
		mov [ebp+(s_off s_ret+4)],edx
		pop ebp
		reti 16
long_mul:
		mov eax,[esp+8]
		mov ecx,[esp+0x10]
		rn or ecx,eax  
		mov ecx,[esp+0xc]
		rn jne hard
		mov eax,[esp+4]
		rn db 0xf7,0xe1//mul eax,ecx
		reti 0x10
hard:
		push ebx
		rn db 0xf7,0xe1//mul eax,ecx
		mov ebx,eax
		mov eax,[esp+8]
		rn db 0xf7,0x64,0x24,0x14//mul eax,[esp+0x14]
		add ebx,eax
		mov eax,[esp+8]
		rn db 0xf7,0xe1//mul eax,ecx
		add edx,ebx
		pop ebx
		reti 0x10
#else
		a*=b
		return a
#endif
	}

	friend int64 operator/(int64 a,int64 b)
	{
#ifdef _RNASM
		mov eax,[ebp+(s_off b+4)]
		push eax
		mov ecx,b
		push ecx
		mov edx,[ebp+(s_off a+4)]
		push edx
		mov eax,a
		push eax
		rn call long_div
		mov s_ret,eax
		mov [ebp+(s_off s_ret+4)],edx
		pop ebp
		reti 16
long_div:
		push edi
		push esi
		push ebx
		rn xor edi,edi
		mov eax,[esp+0x14]
		rn or eax,eax 
		rn jge L1
		rn inc edi 
		mov edx,[esp+0x10] 
		rn neg eax 
		rn neg edx 
		rn sbb eax,0 
		mov [esp+0x14],eax 
		mov [esp+0x10],edx 
L1:
		mov eax,[esp+0x1c] 
		rn or eax,eax 
		rn jge L2
		rn inc edi 
		mov edx,[esp+0x18] 
		rn neg eax 
		rn neg edx 
		rn sbb eax,0 
		mov [esp+0x1c],eax 
		mov [esp+0x18],edx 
L2:
		rn or eax,eax 
		rn jne L3
		mov ecx,[esp+0x18] 
		mov eax,[esp+0x14] 
		rn xor edx,edx 
		rn db 0xf7,0xf1//div eax,ecx 
		mov ebx,eax 
		mov eax,[esp+0x10] 
		rn db 0xf7,0xf1//div eax,ecx 
		mov edx,ebx 
		jmp L4
L3:
		mov ebx,eax 
		mov ecx,[esp+0x18] 
		mov edx,[esp+0x14] 
		mov eax,[esp+0x10] 
L5:
		rn shr ebx,1 
		rn rcr ecx,1 
		rn shr edx,1 
		rn rcr eax,1 
		rn or ebx,ebx 
		rn jne L5
		rn db 0xf7,0xf1//div eax,ecx 
		mov esi,eax 
		rn db 0xf7,0x64,0x24,0x1c//mul eax,[esp+0x1c]
		mov ecx,eax 
		mov eax,[esp+0x18] 
		rn db 0xf7,0xe6//mul eax,esi 
		add edx,ecx 
		rn jb L6
		rn cmp edx,[esp+0x14] 
		rn ja L6
		rn jb L7
		rn cmp eax,[esp+0x10] 
		rn jbe L7
L6:
		rn dec esi 
L7:
		rn xor edx,edx 
		mov eax,esi 
L4:
		rn dec edi 
		rn jne L8
		rn neg edx 
		rn neg eax 
		rn sbb edx,0 
L8:
		pop ebx 
		pop esi
		pop edi
		reti 16
#else
		a/=b
		return a
#endif
	}
	
	//todo
	friend int64 operator%(int64 a,int64 b)
	{
		return a-a/b*b
	}
	
	friend bool operator<(int64 a,int64 b)
	{
#ifdef _RNASM
		mov eax,[ebp+(s_off a+4)]
		rn cmp eax,[ebp+(s_off b+4)]
		rn jg tag_zero
		rn jl tag_one
		mov ecx,a 
		rn cmp ecx,b 
		rn jae tag_zero
tag_one:
		mov s_ret,1  
		return  
tag_zero:
		mov s_ret,0
#else
		lea esi,b
		push esi
		lea esi,a
		push esi
		calle "clsbl",9
		mov s_ret,eax
		add esp,8
#endif
	}

	friend bool operator<=(int64 a,int64 b)
	{
		return a<b||a==b;
	}

	friend bool operator==(int64 a,int64 b)
	{
		cesb a,b
		if(ebx)
		{
			cesb [ebp+(s_off a+4)],[ebp+(s_off b+4)]
		}
		mov s_ret,ebx
	}

	friend bool operator!=(int64 a,int64 b)
	{
		return !(a==b)
	}

	friend bool operator>(int64 a,int64 b)
	{
		return b<a;
	}

	friend bool operator>=(int64 a,int64 b)
	{
		return b<=a;
	}
	
	friend int64 operator neg(int64 a)
	{
		return 0-a;
	}

	void clear()
	{
		this=0
	}

	bool empty()
	{
		return 0==this
	}

	/*print()
	{
		rf.print this
	}

	printl()
	{
		rf.printl this
	}*/
}
﻿
class rbufm<T>
{
	rbuf<T> m_buf
	int m_level
	int m_row
	int m_column

	~rbufm<T>()
	{
	}

	rbufm<T>()
	{
	}

	rbufm<T>(int row,int column)
	{
		m_buf.realloc_n(row*column)
		m_level=0
		m_row=row
		m_column=column
	}

	rbufm<T>(int level,int row,int column)
	{
		m_buf.realloc_n(level*row*column)
		m_level=level
		m_row=row
		m_column=column
	}

	rbufm<T>(rbufm<T>& a)
	{
		m_buf=a.m_buf
		m_level=a.m_level
		m_row=a.m_row
		m_column=a.m_column
	}

	=(rbufm<T>& a)
	{
		m_buf=a.m_buf
		m_level=a.m_level
		m_row=a.m_row
		m_column=a.m_column
	}

	T& [](int i,int j)
	{
		return m_buf[i*m_column+j]
	}

	T& [](int i,int j,int k)
	{
		return m_buf[i*m_row*m_column+j*m_column+k];
	}

	friend bool ==(rbufm<T>& a,rbufm<T>& b)
	{
		if(a.m_buf!=b.m_buf)
			return false
		return (a.m_level==b.m_level&&
			a.m_row==b.m_row&&
			a.m_column==b.m_column)
	}

	friend bool !=(rbufm<T>& a,rbufm<T>& b)
	{
		return !(a==b)
	}
};
﻿class rp<T>
{
	rdp m_in

	~rp<T>()
	{
	}

	rp<T>()
	{
	}

	rp<T>(rp<T> a)
	{
		mov esi,this
		mov [esi],a
	}

	rp<T>(rp<T>& a)
	{
		mov esi,this
		mov edi,a
		mov [esi],[edi]
	}

	TYPE to<TYPE>()
	{
		mov esi,this
		mov s_ret,[esi]
	}
	
	template<>
	char to<char>()
	{
		return toint.tochar
	}
	
	template<>
	ushort to<ushort>()
	{
		return toint.toushort
	}
	
	template<>
	int64 to<int64>()
	{
		return toint.toint64
	}

	int toint()
	{
		mov esi,this
		mov s_ret,[esi]
	}

	uint touint()
	{
		mov esi,this
		mov s_ret,[esi]
	}

	void operator=(rp<T> a)
	{
		mov esi,this
		mov [esi],a
	}

	void operator=(rp<T>& a)
	{
		mov esi,this
		mov edi,a
		mov [esi],[edi]
	}
	
	void operator=(int a)
	{
		mov esi,this
		mov [esi],a
	}

	T& operator*()
	{
		mov esi,this
		mov s_ret,[esi]
	}
	
	//指针再取地址只能返回空指针，否则会产生递归定义
	rp<void> operator&()
	{
		mov s_ret,this
	}

	void operator++()
	{
		mov esi,this
		add [esi],sizeof(T)
	}

	void operator--()
	{
		mov esi,this
		sub [esi],sizeof(T)
	}

	void operator+=(int a)
	{
		a*=sizeof(T)
		mov esi,this
		add [esi],a
	}

	void operator+=(uint a)
	{
		a*=sizeof(T)
		mov esi,this
		add [esi],a
	}

	void operator-=(int a)
	{
		a*=sizeof(T)
		mov esi,this
		sub [esi],a
	}

	void operator-=(uint a)
	{
		a*=sizeof(T)
		mov esi,this
		sub [esi],a
	}

	T& operator[](int a)
	{
		a*=sizeof(T)
		mov esi,this
		mov esi,[esi]
		add esi,a
		mov s_ret,esi
	}

	T& operator[](uint a)
	{
		a*=sizeof(T)
		mov esi,this
		mov esi,[esi]
		add esi,a
		mov s_ret,esi
	}

	friend rp<T> operator+(rp<T> a,int b)
	{
		b*=sizeof(T)
		add a,b
		mov s_ret,a
	}

	friend rp<T> operator+(rp<T> a,uint b)
	{
		b*=sizeof(T)
		add a,b
		mov s_ret,a
	}

	friend rp<T> operator-(rp<T> a,int b)
	{
		b*=sizeof(T)
		sub a,b
		mov s_ret,a
	}

	friend rp<T> operator-(rp<T> a,uint b)
	{
		b*=sizeof(T)
		sub a,b
		mov s_ret,a
	}

	friend int operator-(rp<T> a,rp<T> b)
	{
		sub a,b
		idiv a,sizeof T
		mov s_ret,a
	}

	friend bool operator<(rp<T> a,rp<T> b)
	{
		_uclsb a,b
		mov s_ret,ebx
	}

	friend bool operator<=(rp<T> a,rp<T> b)
	{
		_uclesb a,b
		mov s_ret,ebx
	}

	friend bool operator>(rp<T> a,rp<T> b)
	{
		_ucgsb a,b
		mov s_ret,ebx
	}

	friend bool operator>=(rp<T> a,rp<T> b)
	{
		_ucgesb a,b
		mov s_ret,ebx
	}

	friend bool operator==(rp<T> a,rp<T> b)
	{
		cesb a,b
		mov s_ret,ebx
	}

	friend bool operator!=(rp<T> a,rp<T> b)
	{
		cnesb a,b
		mov s_ret,ebx
	}

	bool empty()
	{
		mov esi,this
		cesb [esi],0
		mov s_ret,ebx
	}

	void clear()
	{
		mov esi,this
		mov [esi],0
	}

	void print()
	{
		rf.print(this.touint)
	}

	void printl()
	{
		rf.printl(this.touint)
	}
}
﻿class uint
{
	rd32 m_in

	enum
	{
		c_min=0,
		c_max=0xffffffff,
	}

	~uint()
	{
	}

	uint()
	{
	}

	uint(uint a)
	{
		mov esi,this
		mov [esi],a
	}

	uint(uint& a)
	{
		mov edi,this
		mov esi,a
		mov [edi],[esi]
	}

	uint(int a)
	{
		mov esi,this
		mov [esi],a
	}

	uint(char a)
	{
		mov edi,this
		mov [edi],0
		movb [edi],a
	}

	TYPE to<TYPE>()
	{
		mov esi,this
		mov s_ret,[esi]
	}
	
	template<>
	char to<char>()
	{
		return toint.tochar
	}
	
	template<>
	ushort to<ushort>()
	{
		return toint.toushort
	}
	
	template<>
	int64 to<int64>()
	{
		return toint.toint64
	}

	int toint()
	{
		mov esi,this
		mov s_ret,[esi]
	}

	uint touint()
	{
		mov esi,this
		mov s_ret,[esi]
	}

	rstr torstr()
	{
		rstr ret(this)
		return ret
	}

	void operator=(uint a)
	{
		mov esi,this
		mov [esi],a
	}

	void operator=(uint& a)
	{
		mov edi,this
		mov esi,a
		mov [edi],[esi]
	}

	friend operator<->(uint& a,uint& b)
	{
		c=a
		a=b
		b=c
	}

	void operator+=(uint a)
	{
		mov esi,this
		add [esi],a
	}

	void operator-=(uint a)
	{
		mov esi,this
		sub [esi],a
	}

	void operator*=(uint a)
	{
		mov esi,this
		imul [esi],a
	}

	void operator/=(uint a)
	{
		mov esi,this
		_udiv [esi],a
	}

	void operator%=(uint a)
	{
		mov esi,this
		_umod [esi],a
	}

	void operator++()
	{
		mov esi,this
		add [esi],1
	}

	void operator--()
	{
		mov esi,this
		sub [esi],1
	}

	friend uint operator+(uint a,uint b) 
	{
		add a,b
		mov s_ret,a
	}

	friend uint operator-(uint a,uint b)
	{
		sub a,b
		mov s_ret,a
	}

	friend uint operator*(uint a,uint b)
	{
		imul a,b
		mov s_ret,a
	}

	friend uint operator/(uint a,uint b)
	{
		_udiv a,b
		mov s_ret,a
	}

	friend uint operator%(uint a,uint b)
	{
		_umod a,b
		mov s_ret,a
	}

	friend bool operator<(uint a,uint b)
	{
		_uclsb a,b
		mov s_ret,ebx
	}

	friend bool operator<=(uint a,uint b)
	{
		_uclesb a,b
		mov s_ret,ebx
	}

	friend bool operator==(uint a,uint b)
	{
		cesb a,b
		mov s_ret,ebx
	}

	friend bool operator!=(uint a,uint b)
	{
		cnesb a,b
		mov s_ret,ebx
	}

	friend bool operator>(uint a,uint b)
	{
		return b<a;
	}

	friend bool operator>=(uint a,uint b)
	{
		return b<=a;
	}

	void set(uint a)
	{
		mov esi,this
		mov [esi],a
	}

	void clear()
	{
		mov esi,this
		mov [esi],0
	}

	bool empty()
	{
		return 0==this
	}

	/*void print()
	{
		rf.print this
	}

	void printl()
	{
		rf.printl this
	}*/
}
﻿class ushort
{
	rd16 m_in

	~ushort()
	{
	}

	ushort()
	{
	}

	ushort(ushort& a)
	{
		mov esi,this
		mov edi,a
		movb [esi],[edi]
		movb [esi+1],[edi+1]
	}

	ushort(ushort a)
	{
		mov esi,this
		movb [esi],a
		movb [esi+1],[ebp+(s_off a+1)]
	}
	
	ushort(char a)
	{
		this=a.toint
	}
	
	/*short toshort()
	{
		mov esi,this
		movb s_ret,[esi]
		movb [ebp+(s_off s_ret+1)],[esi+1]
	}*/
	
	TYPE to<TYPE>()
	{
		xf.print("error\n")
	}
	
	template<>
	int to<int>()
	{
		return toint
	}
	
	template<>
	uint to<uint>()
	{
		return touint
	}

	int toint()
	{
		mov esi,this
		mov s_ret,0
		movb s_ret,[esi]
		movb [ebp+(s_off s_ret+1)],[esi+1]
	}

	uint touint()
	{
		mov esi,this
		mov s_ret,0
		movb s_ret,[esi]
		movb [ebp+(s_off s_ret+1)],[esi+1]
	}

	rstr torstr()
	{
		rstr ret(this.toint)
		return ret
	}

	void operator=(ushort& a)
	{
		mov esi,this
		mov edi,a
		movb [esi],[edi]
		movb [esi+1],[edi+1]
	}

	void operator=(ushort a)
	{
		mov esi,this
		movb [esi],a
		movb [esi+1],[ebp+(s_off a+1)]
	}
	
	void operator=(int a)
	{
		mov esi,this
		movb [esi],a
		movb [esi+1],[ebp+(s_off a+1)]
	}

	void operator=(uint a)
	{
		mov esi,this
		movb [esi],a
		movb [esi+1],[ebp+(s_off a+1)]
	}

	void operator++()
	{
		this=toint+1
	}

	void operator--()
	{
		this=toint-1
	}

	friend operator<->(ushort& a,ushort& b)
	{
		c=a
		a=b
		b=c
	}

	friend bool operator==(ushort a,ushort b)
	{
		return a.toint==b.toint
	}

	friend bool operator!=(ushort a,ushort b)
	{
		return a.toint!=b.toint
	}

	friend bool operator>(ushort a,ushort b)
	{
		return a.toint>b.toint
	}

	friend bool operator>=(ushort a,ushort b)
	{
		return a.toint>=b.toint
	}

	friend bool operator<(ushort a,ushort b)
	{
		return a.toint<b.toint
	}

	friend bool operator<=(ushort a,ushort b)
	{
		return a.toint<=b.toint
	}

	void clear()
	{
		this=0
	}

	bool empty()
	{
		return this.toint==0
	}

	/*print()
	{
		rf.print this.torstr
	}

	printl()
	{
		rf.printl this.torstr
	}*/
}
﻿#include "rp.rs"
#include "char.rs"
#include "int.rs"
#include "uint.rs"
#include "ushort.rs"
#include "int64.rs"
#include "double.rs"
#include "float.rs"

#include "ralgo.h"
#include "rbuf.h"
#include "rstr.h"
#include "rstrw.h"
#include "rcode.h"
#include "rf.h"
#include "rmutex.h"

#define vector rbuf
#define string rstr
#define bool int
#define rbool int
#define long int64
#define uchar char
#define wchar ushort
#define r_size sizeof
#define r_move
#define r_ceil_div(a,b) r_cond(0==(a)%(b),(a)/(b),(a)/(b)+1)

#define r_max(a,b) r_cond(a>b,a,b)
#define r_min(a,b) r_cond(a<b,a,b)

/*#define r_to_int(a) ((int)(a))
#define r_to_uint(a) ((uint)(a))
#define r_to_char(a) ((char)(a))
#define r_to_uchar(a) ((uchar)(a))
#define r_to_int64(a) ((int64)(a))
#define r_to_double(a) ((double)(a))

#define r_to_pint(a) ((int*)(a))
#define r_to_puint(a) ((uint*)(a))
#define r_to_pchar(a) ((char*)(a))
#define r_to_puchar(a) ((uchar*)(a))
#define r_to_pint64(a) ((int64*)(a))
#define r_to_pdouble(a) ((double*)(a))
#define r_to_prstr(a) ((rstr*)(a))*/

#define true 1
#define false 0

#define null 0p
#define NULL 0p

#define elif else if
#define while for
#define default else
#define namespace friend class
#define goto jmp
#define struct class
#define static friend
#define const
#define inline
#define asm
#define auto
#define then
#define volatile
#define register
#define signed
#define unsigned
#define operator
#define typename

#define <- =
#define :: .

//与do...while相反
mac until(a)
{
	if(a)
	{
		break;
	}
}

mac$ @ _word ( _mword )
{
	stdcall[#$0,$1]
}

mac$ @@ _word ( _mword )
{
	cdecl[#$0,$1]
}

cfunc void main_c()
{
	sub esp,4
	call &main
	add esp,4
}

int r_cond(bool cond,int a,int b)
{
	if(cond)
	{
		return a
	}
	return b
}

T r_cond<T>(bool cond,T a,T b)
{
	if(cond)
	{
		return a
	}
	return b
}

char r_char(rstr s)
{
	return s[0]
}

void print(rstr s)
{
	rf.print(s);
}

void printl(rstr s=rstr())
{
	rf.printl(s);
}

void* findf(rstr s)
{
	return xf.find_func(s.cstr)
}

//推荐使用函数进行位运算，
//如果一定要使用位运算符请自行DIY位运算符和优先级
int NOT(int a)
{
	bnot a
	mov s_ret,a
}

int AND(int a,int b)
{
	band a,b
	mov s_ret,a
}

int OR(int a,int b)
{
	bor a,b
	mov s_ret,a
}

int ORM(int num)
{
	int* p=&num+1
	int ret=*p
	p++
	for(i=1;i<num;i++)
		ret=OR(ret,*p)
		p++
	*p=ret
	mov ecx,sizeof(int)
	imul ecx,num
	add ecx,4
	pop ebp
	add esp,sizeof(s_local)
	mov eax,[esp]
	_reti(eax,ecx)
}

int XOR(int a,int b)
{
	bxor a,b
	mov s_ret,a
}

int SHL(int a,int b)
{
#ifdef _RVM
	bshl a,b
	mov s_ret,a
#else
	push b
	push a
	calle "bshl"
	mov s_ret,eax
	add esp,8
#endif
}

int SHR(int a,int b)
{
#ifdef _RVM
	bshr a,b
	mov s_ret,a
#else
	push b
	push a
	calle "bshr"
	mov s_ret,eax
	add esp,8
#endif
}

int SAR(int a,int b)
{
#ifdef _RVM
	bsar a,b
	mov s_ret,a
#else
	push b
	push a
	calle "bsar"
	mov s_ret,eax
	add esp,8
#endif
}

rbuf<T> array<T>(int num)
{
	T* p=&num+1
	rbuf<T>* pret=p+num
	pret->rbuf<T>()
	for(i=0;i<num;i++)
	{
		pret->push(*p)
		//T& temp
		//mov temp,p
		T.~T(*p)
		p++
	}
	mov ecx,sizeof(T)
	imul ecx,num
	add ecx,4
	pop ebp
	add esp,sizeof(s_local)
	mov eax,[esp]
	_reti(eax,ecx)
}

//采用类似的办法可以回溯函数的调用栈，
//即可从被调用函数访问到调用函数的局部变量
_reti(int addr,int i)
{
	mov ecx,addr
	mov eax,i
	pop ebp
	add esp,16//4+8+4
	add esp,eax
#ifdef _RNASM
	rn jmp ecx
#endif
#ifdef _RJIT
	jmp ecx
#endif
#ifdef _RVM
	jmp ecx
#endif
}

int stdcall(int count)
{
	count4=count*4
	char* name=(*(&count+1)).to<char*>
	pret=&count+count+1
	pfunc=xf.find_dll_func(name)
	if pfunc==null
		printl(name)
		return 0
	pstart=&count
	
	mov ebx,count
	sub ebx,1
	mov ecx,count4
	mov esi,pstart
	add esi,ecx
next:
	jebxz end
	push [esi]
	sub ebx,1
	sub esi,4
	jmp next
end:
	call pfunc
	mov edi,pret
	mov [edi],eax

	mov ecx,4
	imul ecx,count
	add ecx,4
	pop ebp
	add esp,sizeof(s_local)
	mov eax,[esp]
	_reti(eax,ecx)
}

void __declare()
{
	//todo:
	rbuf<char*> temp
}
﻿import xbase.rs

namespace xf
{
	enum
	{
		X_SEEK_SET=0,
		X_SEEK_END=2,
	};

	static void print(const char* s)
	{
		push s
		push "%s"
		calle "printf",8
		add esp,8
	}

	static void vsnprintf(char* dst,int count,const char* f,char* args)
	{
		push args
		push f
		push count
		push dst
		calle "_vsnprintf",16
		add esp,16
	}

	static void sscanf(const char* src,const char* f,uint* n)
	{
		push n
		push f
		push src
		calle "sscanf",12
		add esp,12
	}
	
	void sprintf(char* dst,char* format,int n)
	{
		push n
		push format
		push dst
		calle "sprintf",12
		add esp,12
	}

	void sprintf(char* dst,char* format,uint n)
	{
		push n
		push format
		push dst
		calle "sprintf",12
		add esp,12
	}
	
	void sprintf64(char* dst,char* format,int64 n)
	{
		lea esi,[ebp+s_off n]
		push [esi+4]
		push [esi]
		push format
		push dst
		calle "sprintf",16
		add esp,16
	}

	void sprintf64(char* dst,char* format,double n)
	{
		lea esi,[ebp+s_off n]
		push [esi+4]
		push [esi]
		push format
		push dst
#ifdef _RNASM
		calle "sprintf",16
#else
		calle "sprintf64",16
#endif
		add esp,16
	}

	static void itoa(void* dst,int n)
	{
		push n
		push "%d"
		push dst
		calle "sprintf",12
		add esp,12
	}

	static void utoa(void* dst,uint n)
	{
		push n
		push "%u"
		push dst
		calle "sprintf",12
		add esp,12
	}

	static void dtoa(void* dst,double n)
	{
		sprintf64(dst,"%f",n);
	}

	static void int64toa(void* dst,int64 n)
	{
#ifdef _RNASM
		sprintf64(dst,"%I64d",n);
#else
		lea esi,[ebp+s_off n]
		push [esi+4]
		push [esi]
		push dst
		calle "int64toa",12
		add esp,12
#endif
	}

	static int atoi(char* s)
	{
		int result;
		sscanf(s,"%d",&result);
		return result;
	}

	static uint atou(char* s)
	{
		uint result;
		sscanf(s,"%u",&result);
		return result;
	}

	static double atod(char* s)
	{
		double result;
		sscanf(s,"%lf",&result);
		return result;
	}

	static void atoint64(char* s,int64* result)
	{
		push result
		push s
		calle "atoint64",8
		add esp,8
	}

	static void exit(int a)
	{
		push a
		calle "exit",4
		add esp,4
	}

	static uchar* malloc(int size)
	{
		push size
		calle "malloc",5
		mov s_ret,eax
		add esp,4
	}

	static void free(void* p)
	{
		push p
		calle "free",4
		add esp,4
	}

	static void memcpy(void* dst,const void* src,int size)
	{
		push size
		push src
		push dst
		calle "memcpy",12
		add esp,12
	}

	static int strlen(const char* s)
	{
		push s
		calle "strlen",5
		mov s_ret,eax
		add esp,4
	}

	static int strlenw(const wchar* p)
	{
		int ret=0;
		while(*p!=0)
		{
			ret++;
			p++;
		}
		return ret;
	}

	static int tick()
	{
		calle "GetTickCount",1
		mov s_ret,eax
	}

	static void sleep(int milliseconds)
	{
		push milliseconds
		calle "Sleep",4
		add esp,4
	}

	static int getch()
	{
		calle "_getch",1
		mov s_ret,eax
	}

	/*static void srand()
	{
		::srand((uint)::time(null));
	}

	static int rand()
	{
		return ::rand();
	}*/

	static int cmd(const char* p)
	{
		push p
		calle "system",5
		mov s_ret,eax
		add esp,4
	}

	static int get_exe_name(wchar* buf,int size)
	{
		push size
		push buf
		push 0
		calle "GetModuleFileNameW",13
		mov s_ret,eax
		//return GetModuleFileNameW(null,buf,size)!=0;
	}

	static int get_cur_dir(wchar* buf,int size)
	{
		push buf
		push size
		calle "GetCurrentDirectoryW",9
		mov s_ret,eax
		//return GetCurrentDirectoryW(size,buf)!=0;
	}

	/*static int64 get_file_update_time(wchar* path)
	{
#ifdef _MSC_VER
		int64 ft;
		HANDLE hFile=::CreateFileW(path,
			GENERIC_READ,
			FILE_SHARE_READ,
			null,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			null);
		if(hFile==INVALID_HANDLE_VALUE)
			return 0;
		if(!::GetFileTime(hFile,null,null,(FILETIME*)&ft))
			return 0;
		::CloseHandle(hFile);
		return ft;
#else
		return 0;
		/*struct stat buf;
		int ret=stat(path,&buf);
		if(0!=ret)
		{
			return false;
		}
		*ft=(int64)buf.st_mtime;
		return true;*/
#endif
	}*/

	static int get_exe_size(uchar* data)
	{
		/*PIMAGE_DOS_HEADER dos_head=(PIMAGE_DOS_HEADER)data;
		PIMAGE_OPTIONAL_HEADER op_head=(PIMAGE_OPTIONAL_HEADER)(
			data+dos_head->e_lfanew+4+20);
		PIMAGE_FILE_HEADER file_head=(PIMAGE_FILE_HEADER)(
			data+dos_head->e_lfanew+4);
		PIMAGE_SECTION_HEADER sec=(PIMAGE_SECTION_HEADER)(
			data+dos_head->e_lfanew+r_size(IMAGE_NT_HEADERS));
		int size=op_head->SizeOfHeaders;
		for(int i=0;i<file_head->NumberOfSections;i++)
		{
			size+=sec[i].SizeOfRawData;
		}
		return size;*/
	}
	
	static int ftell(void* fp)
	{
		push fp
		calle "ftell",5
		add esp,4
		mov s_ret,eax
	}

	static int64 ftell64(void* fp)
	{
		return ftell(fp)
	}
	
	static int fseek(void* fp,int off,int start)
	{
		push start
		push off
		push fp
		calle "fseek",13
		add esp,12
		mov s_ret,eax
	}

	static int fseek64(void* fp,int64 off,int start)
	{
		return fseek(fp,off.toint,start)
	}

	static void* _wfopen(wchar* name,wchar* mode)
	{
		push mode
		push name
		calle "_wfopen",9
		mov s_ret,eax
		add esp,8
	}

	static int fclose(void* fp)
	{
		push fp
		calle "fclose",5
		add esp,4
		mov s_ret,eax
	}

	static int fread(void* buf,int size,int count,void* fp)
	{
		push fp
		push count
		push size
		push buf
		calle "fread",17
		add esp,16
		mov s_ret,eax
	}

	static int fwrite(const void* buf,int size,int count,void* fp)
	{
		push fp
		push count
		push size
		push buf
		calle "fwrite",17
		add esp,16
		mov s_ret,eax
	}

	static int _wremove(wchar* name)
	{
		push name
		calle "_wremove",5
		add esp,4
		mov s_ret,eax
	}

	/*static int rename(wchar* oldname,wchar* newname)
	{
		push newname
		push oldname
		calle "_wrename",9
		add esp,8
		mov s_ret,eax
	}*/

	static int create_thr(void* start,void* param=null)
	{
		int tid=_beginthreadex(null,0,start,param,0,null);
		if(0==tid||1==tid)
		{
			return 0;
		}
		else
		{
			return tid;
		}
	}

	static void wait_thr(int tid)
	{
		WaitForSingleObject(tid,-1);
	}

	static int gbk_to_utf16(const char* src,wchar* dst,int count)
	{
		push count
		push dst
		push (-1)
		push src
		push 0
		push 936
		calle "MultiByteToWideChar",25
		mov s_ret,eax
#ifndef _RNASM
		add esp,24
#endif
	}

	static int utf16_to_gbk(const wchar* src,char* dst,int buf_size)
	{
		push 0
		push 0
		push buf_size
		push dst
		push (-1)
		push src
		push 0
		push 936
		calle "WideCharToMultiByte"
		mov s_ret,eax

		//return ::WideCharToMultiByte(936,0,src,-1,dst,buf_size,null,null);
	}

	static uchar* alloc_v(int len)
	{
#ifdef _MSC_VER
		return (uchar*)VirtualAlloc(null,len,
			MEM_COMMIT,PAGE_EXECUTE_READWRITE);
#endif
	}

	static void free_v(uchar* addr)
	{
#ifdef _MSC_VER
		VirtualFree(addr,0,MEM_RELEASE);
#endif
	}
	
	static char* GetCommandLineA()
	{
		calle "GetCommandLineA",1
		mov s_ret,eax
	}
	
	static void* FindFirstFileW(wchar* name,void* wfd)
	{
		push wfd
		push name
		calle "_FindFirstFileW",9
		mov s_ret,eax
#ifndef _RNASM
		add esp,8
#endif
	}

	static rbool FindNextFileW(void* handle,void* wfd)
	{
		push wfd
		push handle
		calle "_FindNextFileW",9
		mov s_ret,eax
#ifndef _RNASM
		add esp,8
#endif
	}

	static void FindClose(void* handle)
	{
		push handle
		calle "_FindClose",4
#ifndef _RNASM
		add esp,4
#endif
	}
	
	static void InitializeCriticalSection(void* p)
	{
		push p
		calle "InitializeCriticalSection"
	}
	
	static void DeleteCriticalSection(void* p)
	{
		push p
		calle "DeleteCriticalSection"
	}
	
	static void EnterCriticalSection(void* p)
	{
		push p
		calle "EnterCriticalSection"
	}
	
	static void LeaveCriticalSection(void* p)
	{
		push p
		calle "LeaveCriticalSection"
	}
	
	static void* find_func(char* p)
	{
		push p
		calle "find_func"
		mov s_ret,eax
		add esp,4
	}
	
	void* get_stdin()
	{
		calle "__iob_func"
		mov s_ret,eax
	}

	void* get_stdout()
	{
		calle "__iob_func"
		add eax,32
		mov s_ret,eax
	}
	
	rstr scanl()
	{
		rstr result;
		result.clear();
		char c;
		void* fp=get_stdin();
		while(1==xf::fread(&c,1,1,fp))
		{
			if(13==c.toint||10==c.toint)
			{
				if(0==result.count())
				{
					continue;
				}
				else
				{
					return result;
				}
			}
			result+=c;
		}
		return result;
	}
	
	int _beginthreadex(void* _Security,int _StackSize,
		void* start,void* _ArgList,int _InitFlag,void* addr)
	{
		push addr
		push _InitFlag
		push _ArgList
		push start
		push _StackSize
		push _Security
		calle "_beginthreadex"
		add esp,24
		mov s_ret,eax
	}
	
	void WaitForSingleObject(int handle,int milliseconds)
	{
		push milliseconds
		push handle
		calle "WaitForSingleObject"
	}

	bool CloseHandle(int handle)
	{
		push handle
		calle "CloseHandle"
		mov s_ret,eax
	}
	
	void* find_dll_func(rstr s)
	{
		return find_dll_func(s.cstr)
	}

	void* find_dll_func(char* p)
	{
		push p
		calle "find_dll"
		mov s_ret,eax
		add esp,4
	}
}

#define FILE_ATTRIBUTE_DIRECTORY 0x00000010

struct R_WIN32_FIND_DATAW
{
	int dwFileAttributes;
	int64 ftCreationTime;
	int64 ftLastAccessTime;
	int64 ftLastWriteTime;
	int nFileSizeHigh;
	int nFileSizeLow;
	int dwReserved0;
	int dwReserved1;
	wchar cFileName[260];
	wchar cAlternateFileName[14];
};

struct R_CRITICAL_SECTION
{
	char buf[24];
};
